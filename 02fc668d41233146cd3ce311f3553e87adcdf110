{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d14afda3_017fb07b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2022-02-24T20:32:30Z",
      "side": 1,
      "message": "Why is this only implemented as a submit requirement predicate?\n\nI would assume the default should always be to implement as a regular change operator predicate unless there is some exceptional circumstance which is explained in the commit message.",
      "range": {
        "startLine": 7,
        "startChar": 27,
        "endLine": 7,
        "endChar": 55
      },
      "revId": "02fc668d41233146cd3ce311f3553e87adcdf110",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b8c8932_2167347c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2022-02-28T07:41:09Z",
      "side": 1,
      "message": "I don\u0027t think users have a use case for directly querying for this in the web UI. If there is an automated use-case, using the label predicate and a bit of post-processing gets you the same result.\n\nThis would be quite complex to do as indexed predicate, since the actual label names, counts and values are arguments. When I look at the label predicate, I think it has reached its complexity ceiling and not all cases it supports are actually interesting for querying (in the web UI).",
      "parentUuid": "d14afda3_017fb07b",
      "range": {
        "startLine": 7,
        "startChar": 27,
        "endLine": 7,
        "endChar": 55
      },
      "revId": "02fc668d41233146cd3ce311f3553e87adcdf110",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fdec33e_b9a1ca51",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2022-03-10T20:15:51Z",
      "side": 1,
      "message": "\u003e I don\u0027t think users have a use case for directly querying for this in the web UI. \n\nWhy not? This seems like a big assumption. At the very least, it\u0027s wonderfully useful (and well established practice) to test queries you want to use in configuration or automation with one of the query APIs.\n\n\u003e If there is an automated use-case, using the label predicate and a bit of post-processing gets you the same result.\n\nI\u0027ve shared this position before and I still think it\u0027s valid: Any post-processing you push onto a client results in duplicate effort for your clients. Not just in the per-request sense, but also in the \"every team that wants this feature has to write code for this now\" sense.\n\n\u003e \n\u003e This would be quite complex to do as indexed predicate, since the actual label names, counts and values are arguments. When I look at the label predicate, I think it has reached its complexity ceiling and not all cases it supports are actually interesting for querying (in the web UI).\n\nI brought this up on Youssef\u0027s change [1] and I\u0027ll include it here for completeness (but we should probably keep discussion on [1]). Why are we limited to \"indexed predicate\" for change search operators? We\u0027ve had plenty of non-index predicates in the past, so why wouldn\u0027t we augment index capabilities with non-index functionality when it makes sense to? I think creating this whole extra layer of SubmitRequirementPredicates goes away if we do that.\n\n[1] https://gerrit-review.googlesource.com/c/gerrit/+/331100/comments/b51886cc_acebe535",
      "parentUuid": "4b8c8932_2167347c",
      "range": {
        "startLine": 7,
        "startChar": 27,
        "endLine": 7,
        "endChar": 55
      },
      "revId": "02fc668d41233146cd3ce311f3553e87adcdf110",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "170d79a3_0a42309b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2022-03-14T07:34:32Z",
      "side": 1,
      "message": "\u003e At the very least, it\u0027s wonderfully useful (and well established practice) to test queries you want to use in configuration or automation with one of the query APIs.\n\nI agree to that. \n\n\u003e Not just in the per-request sense, but also in the \"every team that wants this feature has to write code for this now\" sense.\n\nI agree, but for this case specifically, not even a single team has asked if this could be used in queries. So I reside on the side of \"keep it as simple\".\n\n\u003e We\u0027ve had plenty of non-index predicates in the past, so why wouldn\u0027t we augment index capabilities with non-index functionality when it makes sense to? I think creating this whole extra layer of SubmitRequirementPredicates goes away if we do that.\n\nLuca is working on resolving an issue where certain queries (because of visibility-post-processing) bring down an entire server. You are right in that we could post process (and the visibility predicate works like that). But it comes at the risk of queries being very expensive in some corner cases that we then have to debug and figure out.",
      "parentUuid": "2fdec33e_b9a1ca51",
      "range": {
        "startLine": 7,
        "startChar": 27,
        "endLine": 7,
        "endChar": 55
      },
      "revId": "02fc668d41233146cd3ce311f3553e87adcdf110",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}