{
  "comments": [
    {
      "key": {
        "uuid": "7d96d959_4c71dfa5",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2013-05-31T15:07:36Z",
      "side": 1,
      "message": "This will unconditionally load all changes from the database which could be an unnecessary performance penalty.\n\nMost of the time we would like to search for changes that are contained in-a-ref of one project.\n\n  inref:stable project:X\n\nWhile a query like\n\n  inref:stable\n\nis possible, it is unlikely that someone will want to search for all changes in ALL projects that are contained in the refs/heads/stable on that project.\n\nI suggest looking at the ChangeQueryRewriter and trying to add an optimization for the (likely) case that the project is also specified. In that case a query which will fetch from the changes table but limited only to that project should be used.",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5de595f1_7b471f65",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2013-05-31T18:58:41Z",
      "side": 1,
      "message": "While I agree that for some users it will be unlikely that they will use this without specifying a project, it\u0027s actually our most common use case today. We have a common tag name across 500 or so projects, and using inref:refs/tags/\u003ctag name\u003e lets us find all changes tagged in all of those 500 projects.\n\nWe could still probably use the optimization you suggested, but our query would look like\n\n inref:refs/tags/foo (project:X OR project:Y OR ...)\n\nAnd I\u0027m not sure how easily that will fit into the query rewriter.\n\nI\u0027m fine with offering the optimized version as a follow-on change, but do you really feel it needs to be included in this change?",
      "parentUuid": "7d96d959_4c71dfa5",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fdb9e9f9_f8e9d136",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2013-05-31T20:38:00Z",
      "side": 1,
      "message": "If this is your realistic use case then I am also fine with the inref operator as it is now.\n\nLet\u0027s try to provide an optimised version in a follow-up change.",
      "parentUuid": "5de595f1_7b471f65",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bdd3f145_f6e9e036",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-05-31T21:16:51Z",
      "side": 1,
      "message": "I think there is a missunderstanding here.  I agree with Sasa, we can\u0027t have this load all the changes as a data source.  Let\u0027s go back to what we are trying to achieve.  \n\nPS3 behaves simply, and is likely the best PS to think about.  It adds a predicate and just behaves as any simple predicate does in Gerrit.  I believe that it is a standard default for Predicates to show only open changes, Project predicate is an exception (I think that exception comes in via r99_byProject.)  So PS3 is not coding the inref predicate to do that, the query framework is doing it by default.\n\nSo Sasa thinks that this predicate should return merged changes by default.  I agree it is a more sane policy to do that for this specific predicate, but I don\u0027t think that anyone knows how to do that?  That is the objective here, not to create a new data source, we just want to change the default.  I don\u0027t think this PS does that, it just causes all changes to be returned (which isn\u0027t the point of adding new datasources, they are for optimizing so you don\u0027t scan all the changes in the change table)?  \n\nDo we agree on the objective at least, PS3 was good except for the default?  If we agree, does anyone know what the appropriate way to achieve that is?",
      "parentUuid": "fdb9e9f9_f8e9d136",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bdd3f145_d6eee43c",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2013-05-31T21:20:58Z",
      "side": 1,
      "message": "Martin clarified some of the backstory on this for me and I realize now my comments were out of context.\n\nIt seems defaulting to status:open previously didn\u0027t need this optimization, but in trying to move the default to status:merged Kaushik took this approach. I understand that changing the default after merging would be confusing for users. I also definitely understand that unconditionally loading all changes from the database is not the right thing to do, but I\u0027m not sure we know a better way.\n\nDo you have any suggestions?",
      "parentUuid": "fdb9e9f9_f8e9d136",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ddbee5e1_97750494",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2013-06-03T14:49:00Z",
      "side": 1,
      "message": "\u003e Do we agree on the objective at least, PS3 was good except for the default?\n\nYes.\n\n\u003e If we agree, does anyone know what the appropriate way to achieve that is?\n\nI don\u0027t know yet. Will have to look at the QueryRewriter code a bit more in order to first understand how it works before I can propose anything.",
      "parentUuid": "bdd3f145_f6e9e036",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fdb9e9f9_d8c72d3d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/query/change/InRefPredicate.java",
        "patchSetId": 6
      },
      "lineNbr": 68,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2013-06-05T13:33:10Z",
      "side": 1,
      "message": "I tried understanding how the query rewriter works and tried adding rewrite rules that would:\n- rewrite \"inref:X\" to \"status:closed inref:X\"\n- stop rewriting if when both \"inref\" and \"status\" are contained in the predicate\n\nHowever, my trials ended up in an infinite rewrite which eventually fails with the StackOverflowError :-(\n\nI think, at this point, we need an input from someone who fully understands the query rewriter (probably only Shawn). I am not sure if my approach to this problem is good and/or if my implementation is good.\n\nBasically, I tried adding the following to the ChangeQueryRewriter:\n\n  @SuppressWarnings(\"unchecked\")\n  @Rewrite(\"S\u003d(status:*) I\u003d(inref:*)\")\n  public Predicate\u003cChangeData\u003e r80_inrefStatus(@Named(\"S\") final ChangeStatusPredicate s,\n      @Named(\"I\") final InRefPredicate i) {\n    return and(s, i);\n  }\n  \n  @SuppressWarnings(\"unchecked\")\n  @Rewrite(\"I\u003d(inref:*)\")\n  public Predicate\u003cChangeData\u003e r85_inref(@Named(\"I\") final InRefPredicate p) {\n    return and(ChangeStatusPredicate.closed(dbProvider), p);\n  }\n\nThe purpose of the first method was to stop rewriting once the predicate contains both status and the inref operators.\nThe purpose of the second method was to add the status:closed to the inref without status specified.\n\nAs said this fails with the StackOverflowError.",
      "parentUuid": "bdd3f145_d6eee43c",
      "revId": "0c9e2950dac1444eb1b0c21ee55d0713d88ccc3d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}