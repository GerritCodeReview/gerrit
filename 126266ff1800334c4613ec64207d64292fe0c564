{
  "comments": [
    {
      "key": {
        "uuid": "b070aa50_4dcd99b3",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 40,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "I\u0027m all for descriptive javadoc but this adds no information we didn\u0027t already have from the class name.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_6cfc1bb2",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 40,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T17:12:41Z",
      "side": 1,
      "message": "I\u0027ll add more information.",
      "parentUuid": "b070aa50_4dcd99b3",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_ad30bd17",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 50,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T17:12:41Z",
      "side": 1,
      "message": "\u003e I just looked at ChangeMergeQueue. It is not clear to me what you\n \u003e intend to happen if callers pass in two partially-overlapping\n \u003e ChangeSets.\n\nBy partially overlapping you mean overlapping in the project/branch dimension?\n\nThe idea is to have a lock on each branch (via a set containing all locked branches, `currentBranches`), so no overlapping change sets should be allowed at the same time.\nWe also need to track the individual groups which are asked to be merged or scheduled. That\u0027s why we\u0027ll have the `active` and `recheck` maps.",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 50,
        "endChar": 74
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_0c09d75e",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 50,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T17:22:08Z",
      "side": 1,
      "message": "Say change1, change2, and change3 are all on different branches A, B, and C.\n\n List\u003cChange\u003e changes1 \u003d Lists.newArrayList(change1, change2);\n List\u003cChange\u003e changes2 \u003d Lists.newArrayList(change2, change3);\n cmq.merge(changes1);\n cmq.merge(changes2);\n\nWhat should happen?",
      "parentUuid": "b070aa50_ad30bd17",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 50,
        "endChar": 74
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_2d1dad8f",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 50,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T17:31:46Z",
      "side": 1,
      "message": "`cmq.merge(changes1);` would lock branches A and B, so on `cmq.merge(changes2);` B is already locked and we cannot schedule it right away. (As we don\u0027t know that it\u0027s change2 in both cases. it could have been a change4 which also is meant to go to B), this is the safest, but slowest thing to do. Once the first set is finished, (and B is released,) we can run the merge on the second set of changes.",
      "parentUuid": "907f2621_0c09d75e",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 50,
        "endChar": 74
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_8c2b87af",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 50,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T18:01:22Z",
      "side": 1,
      "message": "I see. So the goals are:\n\n* _not_ immediately merge C\n* start a merge of [B, C] ASAP after the merge of [A, B] is finished.",
      "parentUuid": "b070aa50_2d1dad8f",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 50,
        "endChar": 74
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_4ccd9fb3",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 110,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "This has no effect. The ChangeSet will only be present in the active map only if there is a set in active containing exactly the changes in this set. Which will of course have the same branch set.\n\nIf you want this to avoid doing extra work here, you need a more complex data structure that maps branch -\u003e MergeEntry for all branches in the set.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_4d26f9e5",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 110,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T17:12:41Z",
      "side": 1,
      "message": "How are you convinced it has no effect?\n\nThe decision is made based on the branches intersecting with the already processing branches, so there may be other change sets in flight.",
      "parentUuid": "907f2621_4ccd9fb3",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_ad6bdded",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 110,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T18:01:22Z",
      "side": 1,
      "message": "I think I misread currentBranches as set.touchedBranches().\n\nBut I still don\u0027t think this is right. Going back to the example above, if set1 is active, then we would have called schedule from l. 97 above, because branch B is in common.\n\nBut then this e will be null, because set2.hash is not in active. Did you want e to somehow be the MergeEntry from set1?\n\nEven if you did that, setting needMerge on set1\u0027s MergeEntry will be insufficient, because that will tell it to recheck A and B once that merge is finished, in which case you\u0027re missing C.",
      "parentUuid": "b070aa50_4d26f9e5",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_4c26ffe5",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 110,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T21:43:38Z",
      "side": 1,
      "message": "I agree line 108 is off and wrong here (most likely a leftover from the current state where you\u0027d get the Merge entry first and check for non null).",
      "parentUuid": "b070aa50_ad6bdded",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_6dcad59e",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 203,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "The only time to use Key is if it\u0027s going in a gwtorm db, this is unnecessary.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_ecbd6bfa",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 227,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "You\u0027re reimplementing the perfectly good system Java already has for hashing. Don\u0027t do that. Use the Java system.\n\nIn the ChangeSet constructor, save all the Change.Ids in an ImmutableSet\u003cChange.Id\u003e. Implement equals and hashCode in terms of equals and hashCode on that set.\n\nIf after benchmarking you can prove that iterating the set on demand is too expensive, then you can cache the result of hashCode in a field. But that field should only be accessed from within the hashCode implementation.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_cddf4956",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 231,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "Defensively copy this into an ImmutableList.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b070aa50_0dd79141",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 243,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "Way overkill.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_8cc2a785",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 247,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "This is reasonably cheap to construct, so doing it lazily is premature optimization.",
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_acc76394",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 266,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2015-04-29T00:11:49Z",
      "side": 1,
      "message": "MoreObjects.ToStringHelper h \u003d new MoreObjects.toStringHelper(this);\n for (Change c : changes) {\n   h.addValue(c.getId() + \":\" + c.getDest());\n }\n return h.toString();",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 266,
        "endChar": 42
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907f2621_ec36cb14",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 15
      },
      "lineNbr": 266,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2015-04-29T21:43:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "907f2621_acc76394",
      "range": {
        "startLine": 258,
        "startChar": 0,
        "endLine": 266,
        "endChar": 42
      },
      "revId": "126266ff1800334c4613ec64207d64292fe0c564",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}