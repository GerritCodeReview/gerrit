{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "83cbaad4_f961efe5",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesCache.java",
        "patchSetId": 1
      },
      "lineNbr": 379,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T11:55:54Z",
      "side": 0,
      "message": "I am puzzled by this assignment: this is a side-effect outside the contract of the loader.\n\nThe `Loader.call()` contract is to load the value from the persistence layer, how come that stores the revision note map as instance variable shared across threads?",
      "range": {
        "startLine": 379,
        "startChar": 6,
        "endLine": 379,
        "endChar": 52
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "508f689b_392d9ea1",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesCache.java",
        "patchSetId": 1
      },
      "lineNbr": 379,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-01-11T12:13:50Z",
      "side": 0,
      "message": "the `revisionNoteMap` is explicitly marked as _mutable and non-threadsafe_ in it\u0027s javadoc L345.\n\nAlso, the `Loader` _is not_ shared between threads, it is created in L406, and then immutable `ChangeNotesCache.Value` was used. Theoretically, it was all good... till 3.7 and external server account IDs ;)\n\nI can see this being a performance optimization, as we already read and loaded everything into memory, we can \"just\" reuse it, as it **was** the same as the data in the git repo.\n\nI can\u0027t tell how much of the performance boost that gave in the past. It seems that it is doubtful that `ChangUpdate` will populate the cache. At least in my testing, the cache was populated upfront.\n\nThe contract of cache mirroring git data is broken now, so we can\u0027t use this approach.",
      "parentUuid": "83cbaad4_f961efe5",
      "range": {
        "startLine": 379,
        "startChar": 6,
        "endLine": 379,
        "endChar": 52
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e933ca41_c298f49a",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesCache.java",
        "patchSetId": 1
      },
      "lineNbr": 379,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T12:59:42Z",
      "side": 0,
      "message": "\u003e the `revisionNoteMap` is explicitly marked as _mutable and non-threadsafe_ in it\u0027s javadoc L345.\n\u003e \n\u003e Also, the `Loader` _is not_ shared between threads, it is created in L406, and then immutable `ChangeNotesCache.Value` was used. Theoretically, it was all good... till 3.7 and external server account IDs ;)\n\nGotcha. Because of the L407, the loader may have not been called *at all* if the key was already present in the cache.\n\nCould we consider this a bug in the way we adapted the mapping of the account-ids? The concept of a cache is that if data hasn\u0027t changed, the cached value and the persistent value read should be the same, which wasn\u0027t the case here.\n\n\u003e I can see this being a performance optimization, as we already read and loaded everything into memory, we can \"just\" reuse it, as it **was** the same as the data in the git repo.\n\nSure, in this case the cached data was different from the underlying stored data, that\u0027s why it broke.\n\n\u003e I can\u0027t tell how much of the performance boost that gave in the past. It seems that it is doubtful that `ChangUpdate` will populate the cache. At least in my testing, the cache was populated upfront.\n\nWell, you are not removing the cache as it is used still at L385. So I don\u0027t believe you are introducing any performance regression either.\n\n\u003e The contract of cache mirroring git data is broken now, so we can\u0027t use this approach.\n\nMaybe could be that the culprit of this inconsistency?",
      "parentUuid": "508f689b_392d9ea1",
      "range": {
        "startLine": 379,
        "startChar": 6,
        "endLine": 379,
        "endChar": 52
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b85532b_96ddf545",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesCache.java",
        "patchSetId": 1
      },
      "lineNbr": 379,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-01-11T13:34:27Z",
      "side": 0,
      "message": "\u003e Gotcha. Because of the L407, the loader may have not been called at all if the key was already present in the cache.\n\nExactly, this gives such a small window for this \"performance\" improvement to work that I don\u0027t think it\u0027s worth it.\n\n\u003e Could we consider this a bug in the way we adapted the mapping of the account-ids?\n\nI wouldn\u0027t call that a \"bug\", but rather an \"unforeseen consequence\".\n\n\u003e The concept of a cache is that if data hasn\u0027t changed, the cached value and the persistent value read should be the same, which wasn\u0027t the case here.\n\nThat depends on the cache contract. One can argue, that git data and `external-ids` do not change, then the cache value is still valid.\n\nBut this is changing the \"cache contract\", as instead of being _the cache of changes data in git_ it becomes a _**computed** value of change git data and external user IDs_.\n\nI do believe that the current approach with account external ID mapping is the way to go. As we have a single place where we do the mapping, we do that mapping once and everywhere in the code (apart from saving data back to the meta branch) we only care about the current instance account ID. Sure we can potentially split this into two caches, one for the Git data and another for the computed value, but IMO that would be overkill.\n\nAdditionally, the way how `ChangeNotesCache.Value.revisionNoteMap` is implemented do not add that much performance. And as we learned is error-prone.\n\nFinally, reverting back to the \"old cache\" contract would require more work, will probably be less performant and we still could hit similar problems when we\u0027re not careful about the data that is put into it.\n\n\u003e Sure, in this case the cached data was different from the underlying stored data, that\u0027s why it broke.\n\nIt\u0027s a bit more complicated, as the main reason here is not that the data were different. But that the data were evicted from the cache, AND loaded by `ChangeUpdate`, giving us modified `revisionNoteMap`. As long as we don\u0027t encounter cache miss when `ChangeUpdate` accesses the cache, we are fine.\n\n\u003e Well, you are not removing the cache as it is used still at L385. So I don\u0027t believe you are introducing any performance regression either.\n\nAgree, also the \"window of opportunity\" for that performance improvement is so small that we probably won\u0027t even notice it gone.\n\n\u003e Maybe could be that the culprit of this inconsistency?\n\nThis problem is so nuanced it\u0027s hard for me to name a single factor as a \"culprit\". For sure having a \"computed\" (or \"mutated\") values in the cache has its part, but without `ChangeNotesCache.Value.revisionNoteMap` being set by `Loader` and then used in `ChangeUpdate.getRevisionNoteMap()` this won\u0027t happen.",
      "parentUuid": "e933ca41_c298f49a",
      "range": {
        "startLine": 379,
        "startChar": 6,
        "endLine": 379,
        "endChar": 52
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "650da869_a4ce75ba",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesCache.java",
        "patchSetId": 1
      },
      "lineNbr": 379,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T15:05:07Z",
      "side": 0,
      "message": "\u003e \u003e Gotcha. Because of the L407, the loader may have not been called at all if the key was already present in the cache.\n\u003e \n\u003e Exactly, this gives such a small window for this \"performance\" improvement to work that I don\u0027t think it\u0027s worth it.\n\nSure, if that was reused across invocations, then yes. I would analyse the discussion on the review that introduced it in the first place.\n\n\u003e \u003e Could we consider this a bug in the way we adapted the mapping of the account-ids?\n\u003e \n\u003e I wouldn\u0027t call that a \"bug\", but rather an \"unforeseen consequence\".\n\nI believe it was a bug, as we created in memory an invalid `HumanComment` (see https://gerrit-review.googlesource.com/c/gerrit/+/376516/comment/eea9984a_401f2e38/).\n\n\u003e \u003e The concept of a cache is that if data hasn\u0027t changed, the cached value and the persistent value read should be the same, which wasn\u0027t the case here.\n\u003e \n\u003e That depends on the cache contract. One can argue, that git data and `external-ids` do not change, then the cache value is still valid.\n\u003e \n\u003e But this is changing the \"cache contract\", as instead of being _the cache of changes data in git_ it becomes a _**computed** value of change git data and external user IDs_.\n\nTrue, this cache is doing too much, agreed. One thing is caching the value, another one is parsing and mapping its ids.\n\n\u003e I do believe that the current approach with account external ID mapping is the way to go. As we have a single place where we do the mapping, we do that mapping once and everywhere in the code (apart from saving data back to the meta branch) we only care about the current instance account ID. Sure we can potentially split this into two caches, one for the Git data and another for the computed value, but IMO that would be overkill.\n\nSure, I tend to agree.\n\n\u003e Additionally, the way how `ChangeNotesCache.Value.revisionNoteMap` is implemented do not add that much performance. And as we learned is error-prone.\n\nCould that be addressed on master with a local refactoring?\n\n[...]\n\n\u003e \u003e Sure, in this case the cached data was different from the underlying stored data, that\u0027s why it broke.\n\u003e \n\u003e It\u0027s a bit more complicated, as the main reason here is not that the data were different. But that the data were evicted from the cache, AND loaded by `ChangeUpdate`, giving us modified `revisionNoteMap`. As long as we don\u0027t encounter cache miss when `ChangeUpdate` accesses the cache, we are fine.\n\nLet me give another look, there is still something fishy in that code. Honestly a Loader that load the data and generates a stateful side-effect looks very fishy. That\u0027s why I was interested in the review of that change, as it should have been highlighted years ago.\n\n\u003e \u003e Well, you are not removing the cache as it is used still at L385. So I don\u0027t believe you are introducing any performance regression either.\n\u003e \n\u003e Agree, also the \"window of opportunity\" for that performance improvement is so small that we probably won\u0027t even notice it gone.\n\nTrue, have you tried before and after with some E2E use-case?\n\n\u003e \u003e Maybe could be that the culprit of this inconsistency?\n\u003e \n\u003e This problem is so nuanced it\u0027s hard for me to name a single factor as a \"culprit\". For sure having a \"computed\" (or \"mutated\") values in the cache has its part, but without `ChangeNotesCache.Value.revisionNoteMap` being set by `Loader` and then used in `ChangeUpdate.getRevisionNoteMap()` this won\u0027t happen.\n\nSure, as it always happen in these cases, it\u0027s not a single event but the combination of multiple conditions together.",
      "parentUuid": "4b85532b_96ddf545",
      "range": {
        "startLine": 379,
        "startChar": 6,
        "endLine": 379,
        "endChar": 52
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84bf5079_bf07c5c2",
        "filename": "java/com/google/gerrit/server/notedb/ChangeUpdate.java",
        "patchSetId": 1
      },
      "lineNbr": 631,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T11:55:54Z",
      "side": 0,
      "message": "I believe this is the culprit: instead of reading the revision note map from the storage, we create one based on the one cached in the loader instance variable.\n\nCould we reduce this change to only this bit and still get the fix working?",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 631,
        "endChar": 7
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cc53392_8cbc079a",
        "filename": "java/com/google/gerrit/server/notedb/ChangeUpdate.java",
        "patchSetId": 1
      },
      "lineNbr": 631,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-01-11T12:21:48Z",
      "side": 0,
      "message": "Yes, exactly that\u0027s the culprit. The rest of the change in the PS is just a cleanup of the code that is not needed anymore after this is removed.\n\nI will verify the simplified patch and get back to you.",
      "parentUuid": "84bf5079_bf07c5c2",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 631,
        "endChar": 7
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e6a8a08_dfa9ca34",
        "filename": "java/com/google/gerrit/server/notedb/ChangeUpdate.java",
        "patchSetId": 1
      },
      "lineNbr": 631,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T15:09:11Z",
      "side": 0,
      "message": "I would separate this change in two parts:\n1. Removing this low-level optimisation on change updates on `stable-3.7`, just verify with Gating that we are not introducing any performance penalty\n2. Cleaning up the code on `master`.\n\nI would still address [1] also on stable-3.7 as a separate change, because the parsing was incorrect IMHO.\n\n[1] https://gerrit-review.googlesource.com/c/gerrit/+/376516/comment/eea9984a_401f2e38/",
      "parentUuid": "7cc53392_8cbc079a",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 631,
        "endChar": 7
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9faefbe_63fd0d59",
        "filename": "java/com/google/gerrit/server/notedb/ChangeUpdate.java",
        "patchSetId": 1
      },
      "lineNbr": 631,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-01-11T15:28:26Z",
      "side": 0,
      "message": "I prefer to keep things together, in case something gets reverted then you don\u0027t end up with a broken codebase and a need to find the second part of that commit.\n\nBut if that\u0027s the only way to get this merge, I can split it 😄",
      "parentUuid": "8e6a8a08_dfa9ca34",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 631,
        "endChar": 7
      },
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6607df33_ced70ec7",
        "filename": "javatests/com/google/gerrit/server/notedb/ChangeNotesTest.java",
        "patchSetId": 1
      },
      "lineNbr": 1968,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-01-11T11:55:54Z",
      "side": 0,
      "message": "Why do we need also to change the test? Was this added for triggering a side-effect in the way the change notes are loaded?",
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfdbd2ab_f28ed9b2",
        "filename": "javatests/com/google/gerrit/server/notedb/ChangeNotesTest.java",
        "patchSetId": 1
      },
      "lineNbr": 1968,
      "author": {
        "id": 1010134
      },
      "writtenOn": "2024-01-11T12:21:48Z",
      "side": 0,
      "message": "even before this change this was a \"dead code\", as the return value for `readNote` was never used. Sure it read the data from cache (that this change is removing now), but it wasn\u0027t testing anything.\n\nWe can\u0027t keep this code as with the other changes we\u0027ll get a compilation error in L3947, as the `notes.revisionNoteMap` is now removed.\n\nYes, we need this change in order to accommodate the code clean up after the fix.",
      "parentUuid": "6607df33_ced70ec7",
      "revId": "18408fb7e2366695660f685a9016fe783203073d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}