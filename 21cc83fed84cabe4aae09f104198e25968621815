{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5a41122c_7a91b7a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-04-25T09:15:34Z",
      "side": 1,
      "message": "Hi all, here https://gist.github.com/geminicaprograms/a8b8e0bfe954782866396ee11c7c3967 is a code snippet that I have used to gather timings vs different number of threads and different java versions.\nI have also compared it against the existing call to get deadlocks so that we have some reference.\n\nUnder Java15 it looks not bad... but I would like others to speak up in terms of the measurement (I was not able to start more than 4k threads on my laptop).",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134cb5cd_f4a5629e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-04-25T21:51:21Z",
      "side": 1,
      "message": "If the numbers in the table are \u0027msec\u0027 then it is definitely not a good idea to use a callback-style metric.\n\nOn Java 11, with 4000 threads, spending 230 ms of CPU time for 1 call per second means using 23% of the CPU. I believe we need to check for blocked threads on a regular basis and contribute the metric, so that we can limit the CPU utilisation, rather than calculating it on a callback basis.",
      "parentUuid": "5a41122c_7a91b7a2",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f3598c3_bf2ca3f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1004034
      },
      "writtenOn": "2021-04-26T08:36:46Z",
      "side": 1,
      "message": "yep, this seems too slow to be called all the time.\nMaybe it could be an optional metric which can be switched on and off at runtime.",
      "parentUuid": "134cb5cd_f4a5629e",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b31f7ae_8eca63a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-04-28T20:35:48Z",
      "side": 1,
      "message": "Metric was meant to support primary the healthchek plugin but it will be costly (especially on the older JVMs). I have introduced check https://gerrit-review.googlesource.com/c/plugins/healthcheck/+/304528 that is not metric based for now (it can be disabled). By default it fails when half of the JVM threads are blocked (can be reconfigured).\n\nAt this point I can see the following options for this change:\n* abandon it and forget about metric (rely solely on the healthcheck)\n* make it configurable (disabled by default) so that it could be consumed by the plugin (also visible in graphana etc. charts, prometheus alarms ;)). It would have to be modified to keep the ratio between the blocked and all threads in such case.",
      "parentUuid": "8f3598c3_bf2ca3f9",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19701e4c_de53c56f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-04-28T23:29:51Z",
      "side": 1,
      "message": "Let\u0027s abandon this change, as the metrics alone doesn\u0027t really tell much anyway.\nIt should be more tailored to what we want to monitor, therefore it should be directly computed in the healthcheck plugin.",
      "parentUuid": "9b31f7ae_8eca63a7",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c0a248c_f2daf371",
        "filename": "java/com/google/gerrit/metrics/proc/ProcMetricModule.java",
        "patchSetId": 4
      },
      "lineNbr": 323,
      "author": {
        "id": 1004034
      },
      "writtenOn": "2021-04-21T20:56:41Z",
      "side": 1,
      "message": "if both these metrics aren\u0027t supported by the JVM we could skip adding this metric",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a6aa7226_43a049b6",
        "filename": "java/com/google/gerrit/metrics/proc/ProcMetricModule.java",
        "patchSetId": 4
      },
      "lineNbr": 323,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-04-22T05:03:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7c0a248c_f2daf371",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10065256_f4ccd14e",
        "filename": "java/com/google/gerrit/metrics/proc/ProcMetricModule.java",
        "patchSetId": 4
      },
      "lineNbr": 330,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2021-04-22T07:37:19Z",
      "side": 1,
      "message": "Can\u0027t we use existing ThreadDeadlockHealthCheck: [1] from metrics-healthchecks library: [2]?\n\nLooking into the implementation, ThreadDeadlockHealthCheck is using: ThreadDeadlockDetector: [3], that is using ThreadMXBean#findDeadlockedThreads(): [4]. There is also ThreadMXBean#findMonitorDeadlockedThreads(): [5].\n\n[1] https://www.javadoc.io/doc/io.dropwizard.metrics/metrics-healthchecks/4.0.3/com/codahale/metrics/health/jvm/ThreadDeadlockHealthCheck.html\n[2] https://repo1.maven.org/maven2/io/dropwizard/metrics/metrics-healthchecks/4.1.19/\n[3] https://github.com/dropwizard/metrics/blob/release/4.1.x/metrics-jvm/src/main/java/com/codahale/metrics/jvm/ThreadDeadlockDetector.java#L41\n[4] https://docs.oracle.com/en/java/javase/11/docs/api/java.management/java/lang/management/ThreadMXBean.html#findDeadlockedThreads()\n[5] https://docs.oracle.com/en/java/javase/11/docs/api/java.management/java/lang/management/ThreadMXBean.html#findMonitorDeadlockedThreads()",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1045eaa5_491f3297",
        "filename": "java/com/google/gerrit/metrics/proc/ProcMetricModule.java",
        "patchSetId": 4
      },
      "lineNbr": 330,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-04-22T09:02:15Z",
      "side": 1,
      "message": "\u003e Can\u0027t we use existing ThreadDeadlockHealthCheck: [1] from metrics-healthchecks library: [2]?\n\u003e \n\u003e Looking into the implementation, ThreadDeadlockHealthCheck is using: ThreadDeadlockDetector: [3], that is using ThreadMXBean#findDeadlockedThreads(): [4]. There is also ThreadMXBean#findMonitorDeadlockedThreads(): [5].\n\nThe all point of this change is to create a metric with the number of *BLOCKED* threads and not of deadlocks.\n\nYou may have a zombie Gerrit with 90% of BLOCKED threads that aren\u0027t technically in deadlock: we don\u0027t have a metric to detect that situation.",
      "parentUuid": "10065256_f4ccd14e",
      "revId": "21cc83fed84cabe4aae09f104198e25968621815",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}