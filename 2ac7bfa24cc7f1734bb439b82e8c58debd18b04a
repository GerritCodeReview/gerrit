{
  "pushCert": "certificate version 0.1\npusher A0D0EF51 1487608141 +0100\nnonce AFJA6odUfufL69ff8biQuwMMYrCayOr2nMCAaBstbOeQwJ6R8525GyCdexPEPYrwl7YRrrzaxrh3\n\n0000000000000000000000000000000000000000 2ac7bfa24cc7f1734bb439b82e8c58debd18b04a refs/for/master\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJYqxlNAAoJEFG1/Zeg0O9RaAsH/0BjsjItU4bopPyJiJmivCuN\ndaLWwPW/rsjnK3dwx9lrs5wRwnPxPn4ZX+GFq03J24jxK9or2uvQACItIxXKINLu\nCR5R/SMueMdjHeKT5G5RvQmSYf18qBreEm9Z+AZ7ey5/nf+Y/3hDv1oYIL+MubJe\nN3DOkZMgnP2678Jge0blKR03ltJHN43Qjk5lRBPfpU1yohRDTAw7TYh32Ncj+0yM\nQJsHjR8fDYBO5725/qzHMobuMnVYmX/2ZHv0pr/pSVW/lGqz8rmkhXhy9i6uM0fZ\nbBvDJNJjFhlYo8lcwiwd7e35fEw+t6drL4f1Dl1ieKLMOPlKvdm3XOQiN/xrdOc\u003d\n\u003dH86Y\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "e424d86d_2e48efaa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2017-02-20T17:14:40Z",
      "side": 1,
      "message": "I don\u0027t quite understand the problem. There are two options how to do it:\n\n* 1. on the fly conversion. Do not extend the table and do not write to it. You are removing it anyway. Instead, read non hashed password from the database, convert it on the fly to hashed password, write the hashed password to NoteDb. When ready the table is removed.\n* 2. intermediate step conversion. Do not update and delete the table in one single step. Make it in two steps:\n* 2.1 migrate passwd to hash passwords in its own migration step 141 -\u003e 142: after this step the table ACCOUNT_EXTERNAL_IDS doesn\u0027t has passwd column, but only has hashed_passwd column\n* 2.2 do what is done in this step now: drop the table ACCOUNT_EXTERNAL_IDS, you have hashed_passwd populated.",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "295d19c5_fa0c9e38",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2017-02-21T07:30:14Z",
      "side": 1,
      "message": "Thanks for looking at this. What you are saying basically confirm what I\u0027m thinking about this so far.\n\n\u003e 1. on the fly conversion. Do not extend the table and do not write to it.\n\u003e You are removing it anyway. Instead, read non hashed password from the\n\u003e database, convert it on the fly to hashed password, write the hashed password\n\u003e to NoteDb. When ready the table is removed.\n\nThis is not as straight-forward as it seems. \nHashed passwords are a precondition for migrating external IDs to NoteDb (because we don\u0027t want to have plain passwords in NoteDb) and the external ID migration has to be done in 2 parts (for upgrade of multimaster instances). This means we can\u0027t squash those changes together and we have (at least) two migrations:\n\n- 142: Conversion of plain passwords to hashed passwords in ReviewDb.\n- 144: Migration of external IDs to NoteDb + Deletion of ACCOUNT_EXTERNAL_IDS table.\n\nThe second migration (144) is not a big problem as it can just read the plain password and redo the hashing.\nThe problem is with the first migration (142) as it now can\u0027t write the hashed password to ReviewDb anymore (as the hash_password field is not there).\nSo this would only work if:\n\n- we keep the plain password in the database so that migration 144 can do the rehashing\n- at this point we change migration 142 to a no-op and rely on migration 144 to do the hashing\n\nThe second point feels a little weird.\n\n\u003e 2. intermediate step conversion. Do not update and delete the table in one single step.\n\nIt\u0027s not a single step as explained above.\n\n\u003e Make it in two steps:\n\u003e 2.1 migrate passwd to hash passwords in its own migration step 141 -\u003e 142:\n\u003e after this step the table ACCOUNT_EXTERNAL_IDS doesn\u0027t has passwd column, but only has hashed_passwd column\n\u003e 2.2 do what is done in this step now: drop the table ACCOUNT_EXTERNAL_IDS, you have hashed_passwd populated.\n\nThis is what I wanted to do, but it\u0027s only working if each site does the upgrade in these 2 steps (upgrade to schema 142, then upgrade to 142+).\nIt fails if any site with schema 141 or older attempts to upgrade directly to a schema where the table is deleted. Deleting the table only later is not solving the issue, but just post-pones the problem.\n\nOther possibilities that I proposed to Han-Wen yesterday:\n\n- convert password in schema migration 142 in place: Do not add a new field for hashed passwords, but just write the hashed password back to the existing password field\n\nThis would work, but has the disadvantage that the plain passwords are immediately gone. This means there is no way to go back to recover them if anything went wrong with the hashing.\n\n- Add a new plain_password field to AccountExternalIds instead of a hashed_password field. Schema migration 142 could then copy the plain password from the password field into the plain_password field before writing the hashed password back to the existing password field. This means the plain passwords are still preserved after the migration. We include this migration into the 2.14 release and gain confidence there that hashed passwords work. In 2.15 we then rewrite migration 142 so that it\u0027s only doing the in place hashing of the password in the password field, but no longer copies the plain password to the plain_password field (because this field is not there if an upgrade from an older schema is done to a schema where the table is deleted). This means plain password will now be gone immediately after the hashing, but since this was tested with 2.14 it should be safe.\n\nSuch a migration path would work since we are anyway about to branch of 2.14 soon.",
      "parentUuid": "e424d86d_2e48efaa",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e22b24c0_b2932022",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2017-02-21T07:54:39Z",
      "side": 1,
      "message": "I think I still don\u0027t understand the problem. Can\u0027t we decouple this series eintirely from introducing hash password? And only migrate ACCOUNT_EXTERNAL_IDS later, after this table has both fields: passwd + hashed_passwd? Themost recent schema now is 141. So say all what 142 is dong is adding hashed_passwd. We have two columns. Then this series migrates in 143 from ACCOUNT_EXTERNAL_IDS to NoteDb in two parts, to support multi master installations?",
      "parentUuid": "295d19c5_fa0c9e38",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "95909151_6e9f7d07",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2017-02-21T08:13:54Z",
      "side": 1,
      "message": "Okay, let me try explaining the issue in more details:\n\nUpgrade from schema 141 to 142 (works):\n\n- old schema: In the database ACCOUNT_EXTERNAL_IDS has only the \u0027password\u0027 field.\n- new schema: The AccountExternalId class has both fields, \u0027password\u0027 and \u0027hashedPassword\u0027.\n- The migration framework makes all new fields available in the database before it runs the migration, hence the database has both fields when the migration 142 is executed.\n- migration 142 popoulates the \u0027hashed_password\u0027 field\n\nUpgrade from schema 142 to 144 (works):\n\n- old schema: In the database ACCOUNT_EXTERNAL_IDS has both fields \u0027password\u0027 and \u0027hashed_password\u0027\n- new schema: The AccountExternalId class is deleted which deletes the ACCOUNT_EXTERNAL_IDS table.\n- The migration framework applies the table deletion only after the migrations are done, hence the database has both fields when the migration 144 is executed.\n- migration 144 can migrate the external IDs to NoteDb and can access both the plain password and the hashed password from the database\n\nUpgrade from schema 141 to 144 (doesn\u0027t work):\n\n- old schema: In the database ACCOUNT_EXTERNAL_IDS has only the \u0027password\u0027 field.\n- new schema: The AccountExternalId class is deleted which deletes the ACCOUNT_EXTERNAL_IDS table.\n- The migration framework applies the table deletion only after the migrations are done, but it doesn\u0027t know earlier versions of the AccountExternalId class and hence it doesn\u0027t know that the hashed_password field ever existed. This means the \u0027hashed_password\u0027 field is not added to the database.\n- migration 142 fails because it tries to populate the \u0027hashed_password\u0027 field which doesn\u0027t exist",
      "parentUuid": "e22b24c0_b2932022",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23540e26_1719dbdb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2017-02-21T08:15:14Z",
      "side": 1,
      "message": "In the meantime I have agreed with Han-Wen that we just do the migration in place without adding any new field. This means schema migration 142 will just overwrite the plain password in the \u0027password\u0027 field with the hashed password.",
      "parentUuid": "95909151_6e9f7d07",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c72dbe7e_313c2dd9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 10
      },
      "lineNbr": 60,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2017-02-21T09:08:41Z",
      "side": 1,
      "message": "Thanks. Now it\u0027s clear. So, then why my first suggestion doesn\u0027t work?\n\n* 1. on the fly conversion.\n\nThis means we can\u0027t squash those changes together and we have (at least) two  migrations:\n* 142: Conversion of plain passwords to hashed passwords in ReviewDb.\n* 144: Migration of external IDs to NoteDb + Deletion of ACCOUNT_EXTERNAL_IDS  table.\n\nWhy do we need 142 in the first place? Why can\u0027t we let non hashed passwords to be forever in the database and always do on-the-fly conversion/hashing in NoteDb? Why it is differently to have two steps to support zero-downtimes for multi master installations? In every single step, every multi master node is either converted or not. If not converted, it is read always from the database  and written always to both backends, dining on-the-fly hashing. The converted nodes read and write from the NoteDb, hashed-only passwords. When all nodes are converted another online conversion step is executed that convert the rest accounts, that weren\u0027t converted during migration phase. Now the table ACCOUNT_EXTERNAL_IDS oddly be dropped.\n\nThe advantage of this approach is that the database preserves forever the plain passwords.",
      "parentUuid": "95909151_6e9f7d07",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b2121637_56d2d803",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIdCache.java",
        "patchSetId": 10
      },
      "lineNbr": 54,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:07:20Z",
      "side": 1,
      "message": "Return Set? Otherwise why is this inconsistent with the other byAccount below?",
      "range": {
        "startLine": 54,
        "startChar": 2,
        "endLine": 54,
        "endChar": 12
      },
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68ebe7e2_d99b7eb6",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIdCacheImpl.java",
        "patchSetId": 10
      },
      "lineNbr": 56,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:13:21Z",
      "side": 1,
      "message": "It occurred to me that we might get extra cache loads during the following race:\n\n* thread 1 reads ref at revision A\n* thread 2 updates ref to revision B, stores data derived from B in the cache\n* thread 1 attempts to read data at A in the cache, and misses\n* later threads attempt to read at B\n\nWe could avoid the load in step 3 by increasing the cache size. However, I don\u0027t think we need to: the race window between reading the ref value and looking it up in the cache is short, and the size of the cached data is potentially pretty large, so doubling the memory usage just to deal with this rare race condition doesn\u0027t seem worth it.",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0f53579e_e5abcb96",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIdCacheImpl.java",
        "patchSetId": 10
      },
      "lineNbr": 213,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:07:20Z",
      "side": 1,
      "message": "Move this line to right above the put call, so it\u0027s clear which line might throw?",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e6ec774_618335ae",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIdCacheImpl.java",
        "patchSetId": 10
      },
      "lineNbr": 219,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:07:20Z",
      "side": 1,
      "message": "Just checking the reasoning here: it is possible that the body of this method runs concurrently with a call to Loader#load for the same ObjectId key. Multiple calls to updateCache can\u0027t happen concurrently due to the lock, but the Cache internals don\u0027t know about that lock. But racing with Loader is not a problem, because the actual Multimap value is the same for a given ObjectId, regardless of whether it takes the fast path (here) or the slow path (Loader)",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82dedda2_00f31ae7",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIds.java",
        "patchSetId": 10
      },
      "lineNbr": 58,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:07:20Z",
      "side": 1,
      "message": "Same comment as in parent change, this seems too big.",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0cefb778_7bab0468",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/account/ExternalIds.java",
        "patchSetId": 10
      },
      "lineNbr": 107,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-02-21T17:07:20Z",
      "side": 1,
      "message": "Move out of the try.",
      "revId": "2ac7bfa24cc7f1734bb439b82e8c58debd18b04a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}