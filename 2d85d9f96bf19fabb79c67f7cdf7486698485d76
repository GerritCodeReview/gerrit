{
  "comments": [
    {
      "key": {
        "uuid": "bfaa1cea_0cb01778",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Mergeable.java",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-13T21:07:59Z",
      "side": 1,
      "message": "If force is true, then isStale() is ignored and then this case is hit, that hundreds of nop op database updates take place.  But it can be that lastSha1MergeTested still differs. So for isStale() to wirk poperly it should be checked that both are equal to skip database and index operation on line 174 below.",
      "range": {
        "startLine": 125,
        "startChar": 6,
        "endLine": 128,
        "endChar": 7
      },
      "revId": "2d85d9f96bf19fabb79c67f7cdf7486698485d76",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1feec834_1f18238d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Mergeable.java",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1015382
      },
      "writtenOn": "2014-06-13T22:13:44Z",
      "side": 1,
      "message": "I don\u0027t know anything about java, and maybe there is some magic going on.. but:\nwhat guarantee that between line 171 and here  or even line 172 and here some other thread does not have altered the \u0027mergeability\u0027 ?\nI do not see any Enqueue/Dequeue, any locking mechanism that would pin the result of isMergeable in place.\n\nIf you are going to have mutiple thread operating on a shared data structure (here a git repo + a database + whatever else)\nIt seems to me that you would need at least some kind of read-write-lock on the change_id to synchronize these threads",
      "revId": "2d85d9f96bf19fabb79c67f7cdf7486698485d76",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df9d10d5_6dbd5550",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Mergeable.java",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-14T15:58:28Z",
      "side": 1,
      "message": "Hey Norbert, nice to see you aroud and commenting on my changes.\n\nAs you assumed, there is some magic inside these lines and this magic is called ORM (object relational mapping framework) in generall and optimistic locking in particluar (used by Gerrit). So every single row is stumped with version and every update operation increases the version.\n\nSay you and me are trying to alter the same change 4711 in two different threads. We both have read is simulateneously and say this current version \u003d 42. We both changed something. In the end ORM would try to execute something like that:\n\n _david_: update changes set foo \u003d bar, version \u003d 43 where change_id \u003d 4711 and version \u003d 42;\n shm_get: update changes set baz \u003d qux, version \u003d 43 where change_id \u003d 4711 and version \u003d 42;\n\nORM then checks, that exact one statement (and not zero) was altered, if not: there was no change with that version, i. e. it was already altered by somebody else and stale row manipulation exception is thrown. See also my investigation result of sporadic database corruption problems:\n\n [1] https://groups.google.com/forum/#!topic/repo-discuss/KUUBaI29QO8",
      "parentUuid": "1feec834_1f18238d",
      "revId": "2d85d9f96bf19fabb79c67f7cdf7486698485d76",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f07a8cc_b74de886",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Mergeable.java",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1015382
      },
      "writtenOn": "2014-06-14T16:44:04Z",
      "side": 1,
      "message": "Ok but what about git.\nYou are trying essentially to change 2 resource (db and git) atomically\nthe \u0027optimistic locking\u0027 of the database would be fine if only the db transaction was involved.. but how do you rollback git in that case or how do you detect change to git (depending if you do git then db or db then git... and btw is the order db then git or git then db consistently enforce in the product ? )\nor is the Open() line 121 take an exclusive lock on the repo ?\nand everywhere the code is\n\nlock git repo\ndo database changes in txn\nif sucessfull do git change\nunlock git\n?\nIf it was then you would not have to worry about optimistinc locking of the database, since presumably no-one would update the same rows in the database without holding a lock on git so you could not have race there.. yet you have so I assume that OpenRepository is not exclusive.. so you have a possibilitily of race windows between git and db\nWhere \n1 - you test for a git state\n2 - if it is the state you want: update the database\n3 - if sucessful at updating the database\n4 - do the git operation\n\nanywhere after 1 and before 4 if git change in such a way that the git state you tested for in 1 change, you can\u0027t do 4... yet the db change is committed.",
      "parentUuid": "df9d10d5_6dbd5550",
      "revId": "2d85d9f96bf19fabb79c67f7cdf7486698485d76",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}