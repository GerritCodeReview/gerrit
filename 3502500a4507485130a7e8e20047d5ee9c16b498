{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "257cc798_07002768",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1091982
      },
      "writtenOn": "2022-11-24T10:44:16Z",
      "side": 1,
      "message": "according to [1], maybe create multiple branches then invoke an API with a \u0027base\u0027 rev parameter and supply the first one or two characters of the SHA-1, which will hopefully match with more than one?\n\n[1] https://gerrit.googlesource.com/jgit/+/3d522c6900f73f2d6d9741d987e2db2c68387a35/org.eclipse.jgit/src/org/eclipse/jgit/lib/ObjectReader.java#131",
      "revId": "3502500a4507485130a7e8e20047d5ee9c16b498",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "593a8e05_b68d4901",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2022-11-24T11:55:08Z",
      "side": 1,
      "message": "If we write a test for this it must be 100% deterministic. \n\nAccording to [1] the abbreviation must have a length of at least 2 characters. Since SHA1 uses hexadecimal numbers, there are 16 * 16 \u003d 256 possibilities for a 2 digit prefix. This means to test this reliable we would need to create 257 different commits to make sure that at least one of the 2 digit prefixes is used twice. Then we would need to iterate over all possible 2 digit prefixes and check that at least for 1 of them the \"base revision ... is ambiguous\" message is returned.\n\nThis fix seems simple enough. Not sure if it\u0027s worth to make so much effort to test this.",
      "parentUuid": "257cc798_07002768",
      "revId": "3502500a4507485130a7e8e20047d5ee9c16b498",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}