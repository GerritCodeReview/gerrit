{
  "comments": [
    {
      "key": {
        "uuid": "6a20d105_9fd9deb4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T15:08:57Z",
      "side": 1,
      "message": "I would favor an approach that does not leave the decision of accepting unknown options to the command, but rather to put that policy decision into the control of the calling application. So, for example if I have a plugin option named --plugin--option, then I could as a caller do something like \"--ignore-if-missing --plugin-option\". This prevents callers who expect an option to exist from silently having their option ignored.\n\nI am also worried that this approach does not seem to be adaptable to being able to ignore options that have values since it is impossible for the application to know whether a non existing option will take values or not, and how many. If we leave this up to the caller, the call will know this information even if a plugin is not installed, so the caller could do something like \"--ignore-if-missing --ignore-if-missing-value --plugin-option value\".",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b533ac3d_41198f36",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-12T16:18:55Z",
      "side": 1,
      "message": "\u003e I would favor an approach that does not leave the decision of accepting unknown options to the command, but rather to put that policy decision into the control of the calling application. So, for example if I have a plugin option named --plugin--option, then I could as a caller do something like \"--ignore-if-missing --plugin-option\". This prevents callers who expect an option to exist from silently having their option ignored.\n\nIs there a specific worst case scenario you\u0027re thinking of? For REST requests, we also ignore unknown parameters in the JSON body input. So, we already have that situation.\n\nPutting the decision into the control of the caller does not sound like a good idea to me. Quite some callers would not know about this or forget it and hence they would not specify the --ignore-if-missing option even though they should. This causes unforeseen issues if the plugin vanishes unexpectedly and the dependent caller breaks because of this. Such callers should rather be written in a way that they are resilient enough to deal with this situation. If they really have a strong dependency on the plugin, they need to ensure it via other means.\n\nIf we really do want to support the case that callers can control the behavior via an option, I would do it exactly the other way around and add an option which makes plugin parameters mandatory to be resolved. Thus, callers would need to explicitly think about this behavior. However, this would add another complexity to our system and hence I would rather like to avoid it.\n\n\u003e \n\u003e I am also worried that this approach does not seem to be adaptable to being able to ignore options that have values since it is impossible for the application to know whether a non existing option will take values or not, and how many. If we leave this up to the caller, the call will know this information even if a plugin is not installed, so the caller could do something like \"--ignore-if-missing --ignore-if-missing-value --plugin-option value\".\n\nI don\u0027t understand why you think that options with values are an issue. Our parsing framework automatically identifies which options and which values belong together. The check for known options is independent of that.",
      "parentUuid": "6a20d105_9fd9deb4",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3047a02_9ae00683",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T16:37:02Z",
      "side": 1,
      "message": "\u003e For REST requests, we also ignore unknown parameters in the JSON body input. So, we already have that situation.\n\nI would favor fixing that, \"explicit over implicit\", ignoring unexpected data silently leads to many hidden bugs.\n\n\u003e Quite some callers would not know about this or forget it and hence they would not specify the --ignore-if-missing option even though they should. This causes unforeseen issues if the plugin vanishes unexpectedly and the dependent caller breaks because of this. \n\nIf the plugin is not written to handle missing options it will have unforseen issues one way or another. By not failing silently, the unforseen issue will be an explicit failure of the command. By silently ignoring the missing option, the unforseen failure has the chance of becoming corrupted data or bad unexpected behavior. Failure is generally favored over wrong behavior.\n\n\u003e Such callers should rather be written in a way that they are resilient enough to deal with this situation.\n\nBut if the callers are not aware of the fact that it could disappear they won\u0027t get written that way. By forcing the caller to indicate explicitly that they have been written to handle the situation of a missing option, it makes it safe to ignore the missing option silently for that case.\n\n\u003e I don\u0027t understand why you think that options with values are an issue. Our parsing framework automatically identifies which options and which values belong together. The check for known options is independent of that.\n\nHow can the framework know how many \"arguments\" an option in a plugin that is not installed has?",
      "parentUuid": "b533ac3d_41198f36",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "555e9f1e_c83ac0cd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-07-15T15:37:36Z",
      "side": 1,
      "message": "Martin, thanks for your comments. I think this triggered a valuable discussion.\nI just discussed this with Alice on the whiteboard and I think we have now a better understanding of the possible approaches and their pros and cons. Unfortunately I\u0027m on a run and can write our reply only tomorrow. But I\u0027m confident that we will find a solution that works for all of us.",
      "parentUuid": "b3047a02_9ae00683",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03eba637_1bd634af",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-07-16T12:57:36Z",
      "side": 1,
      "message": "First of all it\u0027s a bit unfortunate that this got submitted right when you posted your comment.\nI think it\u0027s best to revert these 2 changes and then start again on a clean base.\n\n\u003e How can the framework know how many \"arguments\" an option in a plugin that is not installed has?\n\nCmdLineParser#parseOptionMap(ListMultimap\u003cString, String\u003e) gets a ListMultimap as input, which maps option names to the option values. So in the context of this method we already know which values belong to which options. The framework is able to build this map because everywhere where this method is used (REST API, options on push) users specify options in the format \u0027\u003coption-name\u003e\u003d\u003coption-value\u003e\u0027. This means if \u0027myplugin--foo\u003dbar\u0027 is specified, we can tell that \u0027bar\u0027 is the value of \u0027myplugin--foo\u0027 even if myplugin is not installed.\n\nThe problem that you point out only exists for SSH, where this method is not used. I believe for SSH the parsing is done in BaseCommand#parseCommandLine(Object). This means my commit message was wrong when it claimed that this change also applied also for SSH (sorry about that).\n\nIf we forget about plugin options for a moment, I think with SSH you may run into similar issues already today. Imagine you have a class with the following fields:\n\n  @Option(name \u003d \"--with-retry\", usage \u003d \"...\")\n  private boolean retry\n\n  @Argument(index \u003d 0, required \u003d false, usage \u003d \"numeric ID\")\n  private Integer id;\n\nIf now a user calls\n\n  mycommand --with-retry 0\n\nit may be interpreted as (with-retry\u003dfalse, id\u003dnull) or (with-retry\u003dtrue, id\u003d0). AFAIK the way to resolve this ambiguity is for callers to use \u0027--\u0027 to separate options from arguments, e.g.: mycommand --retry -- 0. I think bot callers should always use \u0027--\u0027 to be unaffected by such issues.\n\nAnyway, I agree that if we would handle unknown plugin options for SSH the same way as we did implement it in this change for REST, that kind of issues are more likely to happen, which would be bad.\n\nSo if we start thinking about supporting to ignore unknown plugin options from scratch (after reverting this change), the following options are feasible:\n\n1. always ignore unknown plugin options silently (what is implemented by this change and the follow-up change)\n\n   + for most callers extra data from plugins is optional,\n     with this approach these callers don\u0027t need to be changed\n     to make them resilient against disabled plugins\n   - callers may not be aware that some data in the response may\n     be missing if a plugin is not available, this may be bad\n     if the caller relies on the presence of this data (but we\n     think that these are only a minority of callers)\n   - callers that rely on the presence of plugin data don\u0027t have\n     a possibility to make this work for them\n\n2. Let the caller specify that unknown plugin options should be ignored (what you propose)\n\n   + this is backwards compatible to the current behavior (which\n     is fail for unknown plugin options)\n   - all callers for which the plugin data is optional must be adapted\n   - new callers for which plugin data is optional likely forget to\n     set the option and will then fail suddenly when a plugin gets\n     disabled\n\n3. Let the caller specify that unknown plugin options should cause a failure (what Alice proposes)\n\n   + this is consistent with how unknown JSON fields in input\n     objects are silently ignored\n   + by default callers are resilient against disabled plugins\n   - existing callers that rely on the presence of extra plugin\n     data need to be adapted, otherwise they would start to fail\n     silently if a plugin gets disabled (but we think this is a\n     minority of callers)\n\nSome questions:\n\n1. Do you agree to the pros and cons of these options, or did we forget anything?\n\n2. Do you see any further possibilities?\n\n3. IIUC option 1 doesn\u0027t work for you because of \"callers that rely on the\n   presence of plugin data don\u0027t have a possibility to make this work for them\",\n   is this correct?\n\n4. Would option 3 work for you? If not, why not?\n\nFor options 2 and 3 we see different degrees for implementing this. For the initial implementation we would do:\n\n1. Support ignoring unknown plugin options only for REST and push,\n   SSH can be done later\n\n2. Have only one --ignore-unknown[1]/--strict option on command level\n   that applies to all unknown (plugin) options of that command,\n   and support --ignore-unknown\u003d\u003coption-name\u003e/--strict\u003d\u003coption-name\u003e only\n   later when there is a real use-case to control this per option [2]\n\n[1] We think from the callers perspective \"--ignore-unknown\" is a better\n    name for this option than \"--ignore-if-missing\".\n\n[2] For SSH we likely would need to support\n    --ignore-unknown\u003d\u003coption-name\u003e/--strict\u003d\u003coption-name\u003e and\n    --ignore-unknown-with-value\u003d\u003coption-name\u003e/--strict-with-value\u003d\u003coption-name\u003e\n    due to the problem that you pointed out. But this limitation of SSH\n    shouldn\u0027t lead to additional complexity in the other APIs (e.g. REST).\n\nWhat do you think?",
      "parentUuid": "555e9f1e_c83ac0cd",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "692130a7_807a49e2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-16T19:02:39Z",
      "side": 1,
      "message": "I am not sure, but it seems like you might be making assumptions based on the RESTAPI, because for SSH many of these things seem like they don\u0027t quite make sense.\n\nQ1) #1 \"for most callers extra data from plugins is optional, with this approach these callers don\u0027t need to be changed to make them resilient against disabled plugins\"\n\nHow can this be true since it isn\u0027t even supported to make things optional? I don\u0027t believe I have any plugins where this is currently optional (as mentioned, I would like to build one, but no such thing is currently possible).\n\nQ1) #3 \"+by default callers are resilient against disabled plugins\"\n\nI don\u0027t understand this?\n\nQ1) #1 \u0026 #3 \"(but we think this is a minority of callers)\"\n\nThis doesn\u0027t make sense to me, why would callers have written code that way already since it wasn\u0027t supported? Literally none of our existing callers that expect data would expect a silent failure.\n\nQ1) I think that you missed the problem of missing behavior, for example in the manifest plugin we have options provided by the batch plugin that tell it to place updates in a batch, if this option is supplied and ignored, it will write data to the wrong place. So \"missing data\" is the \"lighter\" of the two problems, \"missing behavior\" is a much bigger problem.\n\nQ1) I think for #1 and #3 you should add that \"Ignoring options is generally an extremely risky approach and out of the ordinary approach and it goes against modern principles of design, and thus will be counter intuitive to most callers\".\n\nQ2) Not that I would propose.\n\nQ3) Correct\n\nQ4) No because I can\u0027t likely educate unknown users to plan for missing options, most people expect missing options to create an error message. I don\u0027t think any of my users would even imagine planning ahead to add a switch to suddenly get an error message for a situation they don\u0027t expect (a plugin not being installed) in the first place.\n\n\n. As for implementations, I think #1 is not a good API and will lead to many bugs.\n\n. --ignore-unknown is fine. \n\n. I don\u0027t think --ignore-unknown-with-value\u003d\u003coption-name\u003e will cover the situation when there is more than one value for an option.  For example we have many manifest plugin options that take 3 arguments, a project, a branch, and a file. So maybe something like --ignore-unknown-1  --ignore-unknown-2 ...? I think its fine to let whoever needs these implement them.",
      "parentUuid": "03eba637_1bd634af",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdea66ad_59a93489",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T15:08:57Z",
      "side": 1,
      "message": "We have had a need for this in the past. One plugin would like info in the WUI from another plugin if it happens to be installed, but wanted to be able to just ignore that data if it wasn\u0027t there. So we wanted queries to not fail given potentially non-existing options.",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71357e4c_2ee34366",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-12T16:18:55Z",
      "side": 1,
      "message": "What does WUI stand for?",
      "parentUuid": "fdea66ad_59a93489",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0d51057_9f2c4d1a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T16:37:02Z",
      "side": 1,
      "message": "Web User Interface. In other words, we have plugins that want to display data form other plugins on the change page, and we want that plugin to degrade nicely if the other plugin is not installed. Basically the plugin does a change query with an option telling the other plugin to add its attributes to the change output. But if the attributes aren\u0027t there it\u0027s ok, but we still need the query to succeed to provide other change data without having to retry the query without the option now. However, we have scripts that also need that data, and those scripts should outright fail if the option is not there. i.e. those scripts should never be run against a server without that plugin installed and they expect a hard failure, not a silent coverup.",
      "parentUuid": "71357e4c_2ee34366",
      "revId": "35b37e19eb10f63852707556a2e9b84f137d2a91",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}