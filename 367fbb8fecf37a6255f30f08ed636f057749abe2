{
  "pushCert": "certificate version 0.1\npusher Dave Borowitz \u003cdborowitz@google.com\u003e 1524670753 -0400\nnonce AFN+CTIpYudUhBxrE3IErpjbbKLNxN/mGFWTcSZPw2SOqZ0dAvZfB1gByYISZ744UOI/RitbY19B\n\n0000000000000000000000000000000000000000 367fbb8fecf37a6255f30f08ed636f057749abe2 refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCgAzFiEEpPm/sOxWgSqG5grhX9fFmpoSiIwFAlrgoSEVHGRib3Jvd2l0\nekBnb29nbGUuY29tAAoJEF/XxZqaEoiMdGcQAJMcEXdnOXLbwaqcPj1QYeU5pVIC\nzMjQ1pmo0QHwIKiM2pHZXsL6/qHefwUxXkv72b+XsgIjWjxQYsBomVph11/LI7hP\nXIHhgE+ICZQil8hJgTuAazDLEJILgYHM3Lj1ugBwu7TNJY8s8NDK71+REBFVpGFY\nJEA0latnn1APCc+L6rhvwZOACcjHgFO0lSzfbdaWXthQ0ENCdLNTSsKJzmdSnMnO\nKAxV5HFZPB5sx1cPHa9i/NSMHgfCd/DLCFsCfA0wA1ov0NbI6KMq2jwloL28NTIG\nZfliqgqTD5ICwqAUeaGt0GEQSm4ZYPkNZIh7F4VWZUfC3gItW8tnQGIzt4t6iTcQ\nA4l4PLMBSayBclXVTxq9ErUnbbFBxvljU3+n+UMsIHBd5+JGm0sRpXGEe/K+atX8\nWIkVYIZHOiE3ePW3fKtpqWsWziMUcTYjL/lHL9KL8E6+n8SqvufJIZVxGT+UAfYA\nF0wbd63E04/Gk53OE5cW2F/AnbPy6let/uyc4+T0IEMV01RWBGaY6A/mnxgU1hrN\nP9NabMo0s9xMXnmFoV6GKvIfrakqWq1yv8FSosCxv69Gp+UPz8+nGi+O8VE7oP1+\n4EqS7RPDMafayIbnya/rk3XSVXutX43bnCLxAZft3SAEX592w4TKLUZrGfd0Fh/T\nF2LeMBuLr484xpr3\n\u003dpcec\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "e9e0d558_81edaf12",
        "filename": "java/com/google/gerrit/server/change/ChangeKindCacheImpl.java",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-04-26T12:33:06Z",
      "side": 1,
      "message": "How much do we care about getting the exact same bytes here? Protobuf serialization isn\u0027t guaranteed to be deterministic by default (see CodedOutputStream#useDeterministicSerialization).\n\nFor cache values, we should not need not care. We just have to keep this in mind for the cache keys, for which we might also decide to use a compact hand-written string format (to be independent from potential Protobuf changes).\n\nOr do you rather prefer a consistent serialization mechanism across keys and values?",
      "range": {
        "startLine": 185,
        "startChar": 67,
        "endLine": 185,
        "endChar": 80
      },
      "revId": "367fbb8fecf37a6255f30f08ed636f057749abe2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fee6c845_98cd0c76",
        "filename": "java/com/google/gerrit/server/change/ChangeKindCacheImpl.java",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-26T12:42:37Z",
      "side": 1,
      "message": "Ah, determinism is a new idea to me because when I learned proto there were no maps :)\n\nI don\u0027t have particularly strong feelings. I have weak feelings in favor of keeping protobuf for the keys, because:\n\n* I would prefer a consistent serialization mechanism (for types more complex than primitives/String/Enum)\n* I dislike hand-writing parsers (although I have done it many times and am confident in my ability to do so)\n* It should be easy to make this deterministic, the implementation of toByteArray is just a trivial wrapper around CodedOutputStream + writeTo.\n\nWhat are your thoughts?",
      "parentUuid": "e9e0d558_81edaf12",
      "range": {
        "startLine": 185,
        "startChar": 67,
        "endLine": 185,
        "endChar": 80
      },
      "revId": "367fbb8fecf37a6255f30f08ed636f057749abe2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f30e5a8_eb9cd0bf",
        "filename": "java/com/google/gerrit/server/change/ChangeKindCacheImpl.java",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-26T13:46:05Z",
      "side": 1,
      "message": "The latest patch set uses deterministic serialization, it was not hard.",
      "parentUuid": "fee6c845_98cd0c76",
      "range": {
        "startLine": 185,
        "startChar": 67,
        "endLine": 185,
        "endChar": 80
      },
      "revId": "367fbb8fecf37a6255f30f08ed636f057749abe2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92678e95_ccc8f723",
        "filename": "java/com/google/gerrit/server/change/ChangeKindCacheImpl.java",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-04-26T13:51:19Z",
      "side": 1,
      "message": "Perfect. I was just about to send the following comment.\n\nPros for Protobuf for keys:\n- The three aspects you already mentioned. I totally agree with them.\n- Protobuf is much easier to get right. Other developers might not have so much experience with writing parsers.\n\nCons:\n- Even CodedOutputStream#useDeterministicSerialization doesn\u0027t ensure determinism across different versions of Protobuf. If I read the documentation right, it might not just be about maps.\n\nWhy I don\u0027t think that the \u0027Cons\u0027 are so bad:\n- It\u0027s only a possibility that we might never encounter.\n- Even if we do, it probably only affects a small subset of all keys.\n- For those, we would still not get wrong results. Instead, this would only represent an invalidation for those keys.\n\nSo, I would also lean towards Protobuf for non-primitive keys. My only condition would be that we introduce helper code for a deterministic toByteArray() and use it wherever we serialize Protobufs (which you just did with the latest patch set :-) ).",
      "parentUuid": "fee6c845_98cd0c76",
      "range": {
        "startLine": 185,
        "startChar": 67,
        "endLine": 185,
        "endChar": 80
      },
      "revId": "367fbb8fecf37a6255f30f08ed636f057749abe2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f11f397d_eef115b1",
        "filename": "java/com/google/gerrit/server/change/ChangeKindCacheImpl.java",
        "patchSetId": 7
      },
      "lineNbr": 185,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-26T14:03:37Z",
      "side": 1,
      "message": "Sounds like we\u0027ll stick with this, then.\n\n\u003e If I read the documentation right, it might not just be about maps.\n\nI skimmed the code and it seemed to be just about maps, but I can see why they would not write the docs to encourage people to rely on that implementation detail.\n\n\u003e It\u0027s only a possibility that we might never encounter.\n\nAgreed, I think this is likely to be quite rare. Protobuf is a pretty stable format.\n\n\u003e For those, we would still not get wrong results. Instead, this would only represent an invalidation for those keys.\n\nYes, although they would not be immediately pruned, since we wouldn\u0027t know that they exist. But they would presumably never get touched and thus be eligible for size-based pruning, which is fine by me.",
      "parentUuid": "92678e95_ccc8f723",
      "range": {
        "startLine": 185,
        "startChar": 67,
        "endLine": 185,
        "endChar": 80
      },
      "revId": "367fbb8fecf37a6255f30f08ed636f057749abe2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}