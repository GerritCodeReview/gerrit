{
  "comments": [
    {
      "key": {
        "uuid": "ba51a0aa_5cc69d52",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1013267
      },
      "writtenOn": "2016-07-14T08:24:46Z",
      "side": 1,
      "message": "it\u0027s good practice to explain why you are doing that.",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51a0aa_fc28c9e4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-14T09:32:37Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "ba51a0aa_5cc69d52",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a4cdc15_9bf42b8e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-14T09:32:37Z",
      "side": 1,
      "message": "I think I understand why you need that but I am not sure if this is the best way to do it. Have you checked the GitOverHttpServlet which extends JGit\u0027s GitServlet? The GitServlet is configured with RepositoryResolver, UploadFilter, etc.. \n\nCould we try to follow that pattern for the LfsProtocolServlet?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 44
      },
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a4cdc15_9b2d0bf4",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-14T09:47:06Z",
      "side": 1,
      "message": "This looks like a missing functionality in JGits LfsProtocolServlet.\nEvery LFS implementation which extends the LfsProtocolServlet would have to do a similar thing.\n\nJGit\u0027s LfsProtocolServlet would extract the (project,operation) and it could provide a callback interface which it calls to check if the operation should be allowed. Then the application can implement that callback and apply permission control.",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a2db077_0894a74d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-15T03:55:29Z",
      "side": 1,
      "message": "In Gerrit the LfsProtocolServlet is implemented at plugin level. The LfsPluginServlet only extends HttpServlet. As far as I can see the only thing LfsPluginServlet knows about the LFS plugin is its name; it doesn\u0027t do anything to verify that the given plugin actually implements LfsProtocolServlet.\n\nSo unless I\u0027m missing something, this means that per the current implementation each LFS plugin would need to supply the implementation of the callback.",
      "parentUuid": "9a4cdc15_9b2d0bf4",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4aee1374_e1e406d7",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-15T12:58:10Z",
      "side": 1,
      "message": "\u003e In Gerrit the LfsProtocolServlet is implemented at plugin level.\n\nYes. This was intentional.\n\n \u003e The LfsPluginServlet only extends HttpServlet. As far as I can see\n \u003e the only thing LfsPluginServlet knows about the LFS plugin is its\n\nCorrect.\n\nIdeally, Gerrit core doesn\u0027t need and doesn\u0027t want to know anything about LFS.\nEven before the LfsPluginServlet was added to Gerrit it was possible\nto implement an LFS Gerrit plugin which implements the LFS protocol.\nOne small issue in that case would be that plugins can only expose\nservlets under /plugins/\u003cplugin-name\u003e. This would require that every user\nconfigures its LFS client to use this non-default LFS endpoint.\nThis is exactly the issue which is solved by the LfsPluginServlet:\nIt allows a plugin to expose a servlet under the standard LFS endpoint i.e:\n\n  https://gerrit/\u003cproject\u003e/info/lfs/*\n\nFor me, this is also the only purpose of the LfsPluginServlet in Gerrit core.\nEverything else should be done by LFS plugin(s).\n\n\n \u003e name; it doesn\u0027t do anything to verify that the given plugin\n \u003e actually implements LfsProtocolServlet.\n\nCorrect.\n\n \u003e \n \u003e So unless I\u0027m missing something, this means that per the current\n \u003e implementation each LFS plugin would need to supply the\n \u003e implementation of the callback.\n\nYes. Assuming JGit\u0027s LFS protocol implementation provides a callback\nlike:\n\n  public interface LfsOperationFilter {\n    public boolean accept(project, operation);\n  }\n\na LFS plugin could implement such callback if it wants to filter\nwhich operations are allowed or not allowed.",
      "parentUuid": "3a2db077_0894a74d",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a2db077_c8a28fab",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-15T14:16:46Z",
      "side": 1,
      "message": "\u003e a LFS plugin could implement such callback if it wants to filter\n\u003e which operations are allowed or not allowed.\n\nThis isn\u0027t ideal if we want to do something like allowing to configure per project if LFS is enabled or not.  This should be independent of which LFS backend (provided by the plugin) is used. If the callback must be implemented by the plugin, the same has to be implemented in each plugin.",
      "parentUuid": "4aee1374_e1e406d7",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2aef1f71_4073ae1a",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-18T09:28:48Z",
      "side": 1,
      "message": "\u003e \u003e a LFS plugin could implement such callback if it wants to filter\n \u003e \u003e which operations are allowed or not allowed.\n \u003e \n \u003e This isn\u0027t ideal if we want to do something like allowing to\n \u003e configure per project if LFS is enabled or not.  This should be\n \u003e independent of which LFS backend (provided by the plugin) is used.\n \u003e If the callback must be implemented by the plugin, the same has to\n \u003e be implemented in each plugin.\n\nAs you describe it, it doesn\u0027t look ideal... at least from the plugin implementation point of view.\n\nHowever, before we make a decision on how to proceed, let\u0027s consider\na few more scenarios.\n\n1. My assumption was that a Gerrit server would typically use one LFS\nbackend at a time and that migrating from one LFS backend to another\nis not something that would happen on weekly or monthly basis.\nIn that case there is still one place with LFS configuration.\nImplementation-wise: LFS request parsing can still occur at one place only.\nMigrating large objects between different LFS backends is probably going\nto be much more work than migrating the configuration (white list of projects\nfor which LFS is enabled).\n\n2. We may envision a Gerrit server supporting *multiple* LFS backends\nat the same time. So a project A could use the local-fs backend, a project B could use Amazon S3 and a project C yet another LFS backend. If we would maintain part of the LFS configuration in Gerrit core (white list of projects for which LFS is enabled) and another part of the LFS configuration in the LFS plugin (mapping: project -\u003e LFS backend) this also wouldn\u0027t be ideal as one would have to think about\ntwo configurations when enabling LFS for one project.\n\n3. Supporting the configuration of 2. (multiple LFS backends at the same time) in Gerrit core would likely introduce dependencies to each particular LFS backend implementation into Gerrit core (for example: pre signing of Amazon S3 requests). Supporting 2. from a plugin would mean merging existing LFS plugins into one, which shouldn\u0027t be a big issue as they are quite small.\n\nA few more implementation related points:\n\n1. with the current LFS support, an LFS plugin is not required to depend on JGit\u0027s LFS protocol servlet.\nIt can use it as a convenience but it can also decide to implement the LFS protocol from scratch if\nthe author believes he can do it better. Whatever we agree upon, I would prefer not to loose this flexibility.\n\n2. pre-parsing LFS request in Gerrit-core (as proposed by this change) and then parsing it again in the\nLFS plugin again is not ideal. As the LFS protocol evolves we would need to maintain both implementations. Reusing the parsing code (from JGit) would be likely a better choice but would\nalso introduce a new dependency into Gerrit core.",
      "parentUuid": "3a2db077_c8a28fab",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2aef1f71_80509664",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2016-07-18T19:50:44Z",
      "side": 1,
      "message": "In order to support multiple plugins at the same time one could or rather should ;) add lfs.plugin value to project.configuration (gerrit.config value could have been still used as a default fallback) and route requests to corresponding servlets depending on that.\n\nIf we agree on this assumption (but I am open for different ideas :)) we need to pre-read request data (doesn\u0027t matter if we depend on JGit or maintain our own implementation of it) to properly route it. This seems to be not ideal but I would say that even if leave it to the plugin to decide, we at least need to agree on interface based implementation (that contains method like \u0027boolean handles(request)\u0027) - cleaner or check otherwise if request was consumed by plugin. Also making sure that it can be re-read by multiple plugins (request wrapper still needs to be implemented at Gerrit core site) as otherwise plugins could easily consume request stream (there is no mechanism to make sure they will not) making it for the other plugins not usable.\n\nI will look into possibilities there soon so any suggestions or further ideas are welcomed.",
      "parentUuid": "2aef1f71_4073ae1a",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a33a8d7_0aef3bb9",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-19T02:22:42Z",
      "side": 1,
      "message": "I don\u0027t think we should try to support multiple LFS backends. This will add more complexity, for something that is not (in my opinion) likely to be widely used.  It would make things a lot easier to only support one backend, and if anyone wants to switch between them it\u0027s up to them deal with the migration of data.",
      "parentUuid": "2aef1f71_80509664",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ad3d7eb_527ff411",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2016-07-19T04:58:19Z",
      "side": 1,
      "message": "Yeap agree :) cuz all above is pretty easy for API request but how to properly route data request? Correct me if I am wrong but, it contains only SHA of an object to read/store... pretty not sufficient to make efficient decision to which servlet it should be routed to :). Maybe newer versions of protocol...",
      "parentUuid": "7a33a8d7_0aef3bb9",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "caacc370_859c425c",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-19T08:05:34Z",
      "side": 1,
      "message": "\u003e I don\u0027t think we should try to support multiple LFS backends. This\n\nLooks like we agree on that. At least this shouldn\u0027t be supported from\nGerrit core. If someone wants to write a plugin which supports multiple\nLFS backends it is up to the plugin author.\n\n \u003e will add more complexity, for something that is not (in my opinion)\n \u003e likely to be widely used.  It would make things a lot easier to\n \u003e only support one backend, and if anyone wants to switch between\n \u003e them it\u0027s up to them deal with the migration of data.",
      "parentUuid": "7a33a8d7_0aef3bb9",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ad3d7eb_b2b0a0d9",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-07-19T08:05:34Z",
      "side": 1,
      "message": "\u003e Yeap agree :) cuz all above is pretty easy for API request but how\n \u003e to properly route data request? Correct me if I am wrong but, it\n \u003e contains only SHA of an object to read/store... pretty not\n \u003e sufficient to make efficient decision to which servlet it should be\n \u003e routed to :). Maybe newer versions of protocol...\n\nRouting of the data request is the task of its preceding LFS protocol request. When an LFS client needs to upload object A it will first perform a LFS protocol request like:\n\n  POST \u003cproject-X\u003e/info/lfs\n\n  operation: upload\n  object: SHA256 of A\n\nThe LFS protocol handler then return a URL which the client uses\nfor the upload. The LFS protocol can, of course, compute the URL\nbased on its configuration. For example, it could see that the project-X is mapped to use the Amazon S3 storage and then pre-sign \nan Amazon S3 URL and return it to the client.\nSuch a design of LFS is intentional as streaming of large objects should\noccur directly between the lfs client and LFS storage.",
      "parentUuid": "6ad3d7eb_527ff411",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a348866_c2a722b9",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-14T05:14:07Z",
      "side": 1,
      "message": "This is only called once, from the constructor.  Inline it there?",
      "range": {
        "startLine": 72,
        "startChar": 2,
        "endLine": 77,
        "endChar": 3
      },
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a348866_a2a21eaa",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestValidator.java",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-14T05:14:07Z",
      "side": 1,
      "message": "nit: wrong indentation",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 89,
        "endChar": 6
      },
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a348866_82ba7acc",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-14T05:14:07Z",
      "side": 1,
      "message": "inline this in the call to toByteArray on the next line",
      "range": {
        "startLine": 34,
        "startChar": 21,
        "endLine": 34,
        "endChar": 43
      },
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a348866_62bdf6c4",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-14T05:14:07Z",
      "side": 1,
      "message": "nit: missing blank line between methods.",
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a348866_22b7eee6",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/plugins/lfs/LfsRequestWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2016-07-14T05:14:07Z",
      "side": 1,
      "message": "listener",
      "range": {
        "startLine": 56,
        "startChar": 47,
        "endLine": 56,
        "endChar": 51
      },
      "revId": "3f821a8a9e6f1f675480cbde127fa0e1055538e9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}