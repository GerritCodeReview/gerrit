{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6cef2bc0_5210be52",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 34,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-03-27T19:09:23Z",
      "side": 1,
      "message": "I believe this mechanism is a \"same time load\" only mechanism. In other words if the API is available at the time other plugins are loaded, such as on startup, it will be loaded before them. I believe this mechanism has the following downsides:\n\n1) I believe this mechanism requires the APIs to be loaded before the other plugins when loading plugins dynamically well after server startup?\n\n1a) i.e. admins need to be aware of and manage plugin load ordering except on server startup when all plugins are already available to be loaded.\n\n1b) Consumer plugins can be designed to run without a producer plugin, however I believe this will still require the producer\u0027s API plugin to be installed before loading the consumer plugin? So on a server where the producer plugin will never be installed, the producer plugin\u0027s API will still need to be installed if the consumer plugin is desired? I am imagining a consumer plugin that is designed to work with many other types of producer plugins, say bugtracker connectors, and it is likely that consumers will only ever be running with a single bugtracker connector (the one their organization uses), the consumer plugin users will be required to install all the other unused bugtracker connector APIs. This would create a scalability problem for the consumer plugin discouraging it from supporting more bugtrackers.\n\nIn our use case, we specifically want to be able run both our depends-on and our PD plugins on servers without the other plugin installed. I believe this proposal would require us to always have the depends-on-api plugin installed anytime we install the PD plugin, even on servers where the depends-on plugin will never be installed.",
      "revId": "4171f1892d55d43cee24c276f0bd5618d174ddb7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfc7cca5_f7319dc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 34,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-03-29T00:02:10Z",
      "side": 1,
      "message": "\u003e I believe this mechanism is a \"same time load\" only mechanism. In other words if the API is available at the time other plugins are loaded, such as on startup, it will be loaded before them. I believe this mechanism has the following downsides:\n\u003e \n\u003e 1) I believe this mechanism requires the APIs to be loaded before the other plugins when loading plugins dynamically well after server startup?\n\nThe class of the API interface needs to be available to other plugins, otherwise there will be a class-loading issue.\nAt the end of the day there is no way to download a plugin if some of its classes it depends on aren\u0027t loaded.\n\nThe key aspect of this change is the separation between:\n1. API interface\n2. API provider\n3. API consumer\n\n1. is required to be loaded at startup, before all other plugins. 2. and 3. can be loaded/unloaded/reloaded at any time, at load-time or runtime.\n\n\u003e 1a) i.e. admins need to be aware of and manage plugin load ordering except on server startup when all plugins are already available to be loaded.\n\nNot really, the plugin loader will manage the loading of the Gerrit-ApiModule automatically. The suffix \u0027.api.jar\u0027 is just for the PoC and is supposed to be removed as limitation in the final solution, I\u0027ll get rid of it if possible on Monday.\n\n\u003e 1b) Consumer plugins can be designed to run without a producer plugin, however I believe this will still require the producer\u0027s API plugin to be installed before loading the consumer plugin? \n\nYes, correct. At the end of the day, for a consumer to be able to run an API, the API\u0027s interfaces need to be known upfront, otherwise the consumer\u0027s developer won\u0027t know what they look like and won\u0027t be able to refer to them in their code, unless the consumer uses reflection, isn\u0027t it?\n\n\u003e So on a server where the producer plugin will never be installed, the producer plugin\u0027s API will still need to be installed if the consumer plugin is desired?\n\nCorrect, but only the API interface definition, not their implementation.\n\n\u003e I am imagining a consumer plugin that is designed to work with many other types of producer plugins, say bugtracker connectors, and it is likely that consumers will only ever be running with a single bugtracker connector (the one their organization uses), the consumer plugin users will be required to install all the other unused bugtracker connector APIs. This would create a scalability problem for the consumer plugin discouraging it from supporting more bugtrackers.\n\nAll the bugtracker\u0027s would have some differences of course but at least they are tracking bugs and could have a common part of the interface API isn\u0027t it?\nIf they do, only the common interface would need to be loaded and not all the specific ones. If all specific interfaces are completely different, then the example-pd would need to have specific code for each one of them and therefore would have available all the APIs. They can either be shaded inside the plugin\u0027s jar or loaded as external plugins.\n\n\u003e In our use case, we specifically want to be able run both our depends-on and our PD plugins on servers without the other plugin installed. I believe this proposal would require us to always have the depends-on-api plugin installed anytime we install the PD plugin, even on servers where the depends-on plugin will never be installed.\n\nI see what you mean, if you would like example-pd to be able to run without having its dependent classes of the interfaces it needs to call, then there is no other option other than reflection.\nThe problem here isn\u0027t about Gerrit and its plugins, but rather calling a Java method without having the interface definition for it. If you have the interface, you can call it directly, otherwise you need to use reflection.\n\nThere is anything wrong for a plugin to use reflection, if that is what he needs because it doesn\u0027t have access or doesn\u0027t want to have the corresponding interface definition and class file. This PoC would still apply, because you could just define a DynamicMap\u003cPluginProvidedApi\u003e (where PluginProvidedApi is the dummy interface proposed in your PoC) in a single Gerrit-ApiModule and then the example-pd could call the extra methods using reflection. In that case, the only plugin that will be required will be a provided-api-plugin which contains PluginProvidedApi.\n\nNevertheless, if other Gerrit users would like to use a proper type-safe interface, they will still have all the infrastructure to do so.\n\nBottom line: either approaches (type-safe and reflection-based) are possible with this PoC.",
      "parentUuid": "6cef2bc0_5210be52",
      "revId": "4171f1892d55d43cee24c276f0bd5618d174ddb7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d41d4fcb_0e1e9984",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 34,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-03-29T07:42:36Z",
      "side": 1,
      "message": "@Martin I performed the split \u0027depends-on\u0027 into \u0027depends-on\u0027 + \u0027depends-on-api\u0027. Going to address your concern of \u0027depends-pd\u0027 working without access to the interface in a separate change (follow-up of this) so that is clear the difference between the two.\n\nAt the end of the day, it is all about trace-offs:\n\n1. More type-safety and compile-time resolution \u003d\u003e requirements of full class resolution.\n2. Less type-safety and run-time resolution \u003d\u003e full class resolution not needed\n\nI prefer 1. but you may prefer 2. and that\u0027s OK, both approaches need to be possible in a plugin-freedom-world :-)",
      "parentUuid": "cfc7cca5_f7319dc8",
      "revId": "4171f1892d55d43cee24c276f0bd5618d174ddb7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}