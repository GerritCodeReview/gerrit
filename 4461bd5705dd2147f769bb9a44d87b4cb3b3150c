{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9388ca9d_e827e7f3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 7,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2021-06-01T15:20:12Z",
      "side": 1,
      "message": "Is there going to be an SSH equivalent of this?",
      "range": {
        "startLine": 7,
        "startChar": 7,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df6ffdc3_4d0f12a4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 7,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-06-02T08:41:24Z",
      "side": 1,
      "message": "Not implemented by us. \n\nIs there even a single choke point where you could generically introduce this? \n\nFor example: the Query command decides on its own whether to output JSON or text. How would the SSH command framework know where to insert extra information, if it doesn\u0027t know what format is being used?  \n\nIn the original design, incoming requests could also specify multiple X-Gerrit-NeedRef headers as precondition (to deal with replication in multi-primary systems). Is there a single choke point where you could process such preconditions?\n\nIn general, the SSH API is not well structured. The coverage is incomplete, and the commands return data in whatever format they like, which means that there is no side-band to provide extra data (such as X-Gerrit-UpdatedRef).",
      "parentUuid": "9388ca9d_e827e7f3",
      "range": {
        "startLine": 7,
        "startChar": 7,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "718f6427_ab6a349d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 7,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2021-06-02T16:02:40Z",
      "side": 1,
      "message": "\u003e Is there even a single choke point where you could generically introduce this? \n\nUnlikely.\n\n\u003e \n\u003e For example: the Query command decides on its own whether to output JSON or text. How would the SSH command framework know where to insert extra information, if it doesn\u0027t know what format is being used?\n\nI think you would have to modify the actual responses.\n\n\u003e \n\u003e In the original design, incoming requests could also specify multiple X-Gerrit-NeedRef headers as precondition (to deal with replication in multi-primary systems). Is there a single choke point where you could process such preconditions?\n\nNot that I know of.\n\n\u003e \n\u003e In general, the SSH API is not well structured. The coverage is incomplete, and the commands return data in whatever format they like, which means that there is no side-band to provide extra data (such as X-Gerrit-UpdatedRef).\n\nAck.\n\nThis approach has the downside that it does further diverge SSH and REST functionality. It seems like that has been the trend for a while now. I get it that Google isn\u0027t running sshd at all for Gerrit and so there\u0027s just going to be less of a focus on it from that alone. However, are we really ok with features that intentionally diverge it? That seems like it puts us on a path to eventually removing the SSH apis.",
      "parentUuid": "df6ffdc3_4d0f12a4",
      "range": {
        "startLine": 7,
        "startChar": 7,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14a44d3b_829813a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2021-06-01T15:20:12Z",
      "side": 1,
      "message": "I think this was briefly discussed in the hackathon, but what\u0027s the tradeoff of this approach vs returning the SHA1s of the updated refs in the regular api response objects?",
      "range": {
        "startLine": 14,
        "startChar": 25,
        "endLine": 16,
        "endChar": 37
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74142f22_56f48498",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-06-02T08:41:24Z",
      "side": 1,
      "message": "We\u0027d have to add the field to all the response objects, update all the documentation, and find a way to generically insert this data into the response. That would be a lot of work.",
      "parentUuid": "14a44d3b_829813a0",
      "range": {
        "startLine": 14,
        "startChar": 25,
        "endLine": 16,
        "endChar": 37
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65df485e_16267aeb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2021-06-02T16:02:40Z",
      "side": 1,
      "message": "Which responses don\u0027t already have this data? I would assume the ones that update a meta ref. Are those all needed for the customer need you have now?",
      "parentUuid": "74142f22_56f48498",
      "range": {
        "startLine": 14,
        "startChar": 25,
        "endLine": 16,
        "endChar": 37
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89c5c054_e43d2a3c",
        "filename": "java/com/google/gerrit/httpd/WebSession.java",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1091982
      },
      "writtenOn": "2021-06-01T16:17:50Z",
      "side": 1,
      "message": "Did you miss the annotation at the class level?",
      "range": {
        "startLine": 51,
        "startChar": 76,
        "endLine": 51,
        "endChar": 89
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ecf5a39_960bbd52",
        "filename": "java/com/google/gerrit/httpd/WebSession.java",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-06-02T09:06:45Z",
      "side": 1,
      "message": "All the implementors have it, so I think it\u0027s OK.\n\nWhen trying to add @RequestScoped here it threw me a Guice error:\nWebSession is annotated with RequestScopred, but scope annotations are not supported for abstract types.\n\nI added a warning to this class header, though.",
      "parentUuid": "89c5c054_e43d2a3c",
      "range": {
        "startLine": 51,
        "startChar": 76,
        "endLine": 51,
        "endChar": 89
      },
      "revId": "4461bd5705dd2147f769bb9a44d87b4cb3b3150c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}