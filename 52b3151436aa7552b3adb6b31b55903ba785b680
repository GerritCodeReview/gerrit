{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eaaad2de_c8e2ab0e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 11,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-02-11T01:06:56Z",
      "side": 1,
      "message": "This is already possible today: the replication plugin exposes an API that is consumed by the multi-site plugin.\n\nCan you explain what is the problem with the current inter-plugin communication system and what is this change going to add as functionality?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 45
      },
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c03d148_c43a7009",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 11,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2021-02-19T19:06:05Z",
      "side": 1,
      "message": "\u003e This is already possible today: the replication plugin exposes an API that is consumed by the multi-site plugin.\n\nI don\u0027t believe this is an accurate statement. From my understanding, technically the \"lib\" mechanism exposes the API, not the plugin. While the code may live in the same source tree, that does not make it part of the plugin as it not loaded/unloaded when the plugin is loaded/unloaded, it is loaded when the lib is loaded and it is never unloaded. Is my understanding correct?\n\n\u003e Can you explain what is the problem with the current inter-plugin communication system and what is this change going to add as functionality?\n\nCould you explain how you think this can be done currently? I am not aware of any current plugin based mechanism to allow plugins to expose APIs for other plugins to consume, can you elaborate on how you think this can currently be done?",
      "parentUuid": "eaaad2de_c8e2ab0e",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 45
      },
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d9820b4_0a876fa1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 11,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-02-19T21:36:13Z",
      "side": 1,
      "message": "\u003e \u003e This is already possible today: the replication plugin exposes an API that is consumed by the multi-site plugin.\n\u003e \n\u003e I don\u0027t believe this is an accurate statement. From my understanding, technically the \"lib\" mechanism exposes the API, not the plugin. \n\nYou are indeed correct, it is documented at [1]. Because Davido\u0027s change about plugins dependency mechanism in the plugin loader was not merged, we still have to use this technical solution to expose a common API.\n\n\u003e While the code may live in the same source tree, that does not make it part of the plugin as it not loaded/unloaded when the plugin is loaded/unloaded, \n\nWhen you have a plugin that is *statically loaded* from the \u0027/lib\u0027 directory, it cannot technically unloaded because its classes are part of the main Gerrit class loader.\n\n\u003e it is loaded when the lib is loaded and it is never unloaded. Is my understanding correct?\n\nThat is correct.\n\n\u003e \u003e Can you explain what is the problem with the current inter-plugin communication system and what is this change going to add as functionality?\n\u003e \n\u003e Could you explain how you think this can be done currently? I am not aware of any current plugin based mechanism to allow plugins to expose APIs for other plugins to consume, can you elaborate on how you think this can currently be done?\n\nLet me rephrase: I was interested to know what is the functional use-case that is not possible with the current \u0027/lib\u0027 loading mechanism. From the technical functionality perspective, I agree with you, it is not possible to share a common interface between plugins at the moment, if not through the \u0027/lib\u0027.\n\nIf it is the technical problem that you are willing to address, I do understand your point and I believe we should involve Davido in the discussion as he had some interesting ideas to share.\n\nThanks for sharing your views and proposals in this area.\n\nLuca.\n\n\n[1] https://gerrit.googlesource.com/plugins/replication/+/refs/heads/master/src/main/resources/Documentation/extension-point.md",
      "parentUuid": "7c03d148_c43a7009",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 45
      },
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc78b244_55ddd75d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 11,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2021-02-20T00:54:23Z",
      "side": 1,
      "message": "\u003e \u003e \u003e This is already possible today: the replication plugin exposes an API that is consumed by the multi-site plugin.\n\u003e \u003e \n\u003e \u003e I don\u0027t believe this is an accurate statement. From my understanding, technically the \"lib\" mechanism exposes the API, not the plugin. \n\u003e \n\u003e You are indeed correct, it is documented at [1]. Because Davido\u0027s change about plugins dependency mechanism in the plugin loader was not merged, we still have to use this technical solution to expose a common API.\n\nThat change does something very cool, it has this class:\n\nhttps://gerrit-review.googlesource.com/c/gerrit/+/54428/25/gerrit-server/src/main/java/com/google/gerrit/server/plugins/MultiParentClassLoader.java\n\nwhich I wanted to implement also, but had not tried yet to see if it would work. If that class works, then I have a proposal that I am trying to get prototyped that will avoid the load ordering issues of that change, which I believe was the major downside of that specific approach.\n\nThe basic idea is to take advantage of the fact that most execution paths are \"short lived\", i.e. they start with a request, and they end when the request is finished. This means that you only need the MultiParentClassloader available for that short duration. Since for request based use cases you do not need the MultiParentClassloader available at plugin load time, you can simply ignore the plugin ordering issue altogether! It only matters at request time whether the other plugins are loaded. If they aren\u0027t, then the functionality of the dependent plugin can be gracefully unavailable as if none of the plugins were loaded.\n\nBasically my new proposal will combine the MultiParentClassloader with the ideas of this change: https://gerrit-review.googlesource.com/c/gerrit/+/129917 and this change: https://gerrit-review.googlesource.com/c/gerrit/+/129918 We can define another interface that would allow DynamicBeans to explicitly (the approach in those changes is implicit and can only use one other plugin) specify which other plugins to add to the current request\u0027s MultiParentClassloader and core can instantiate the DynamicBean from that classloader.\n\nCombine the approach above with this change, and I believe you will be able to access the APIs from other plugins without the need for reflection since you should now have the other plugin\u0027s classloader as a parent classloader! @DavidO, do you think this would work?\n\n\u003e Let me rephrase: I was interested to know what is the functional use-case that is not possible with the current \u0027/lib\u0027 loading mechanism. From the technical functionality perspective, I agree with you, it is not possible to share a common interface between plugins at the moment, if not through the \u0027/lib\u0027.\n\nGotcha, thanks. We will try to capture that better in the next patchset.\n\n\u003e If it is the technical problem that you are willing to address, I do understand your point and I believe we should involve Davido in the discussion as he had some interesting ideas to share.\n\nYes, agreed! I hope he will join the discussion.\n\n\u003e Thanks for sharing your views and proposals in this area.\n...\n\u003e [1] https://gerrit.googlesource.com/plugins/replication/+/refs/heads/master/src/main/resources/Documentation/extension-point.md\n\nThanks for your review and pointers, this one was very helpful, I hadn\u0027t seen it.",
      "parentUuid": "4d9820b4_0a876fa1",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 45
      },
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd423ea1_64456620",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 11,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-03-10T19:44:56Z",
      "side": 1,
      "message": "\u003e \u003e \u003e \u003e This is already possible today: the replication plugin exposes an API that is consumed by the multi-site plugin.\n\u003e \u003e \u003e \n\u003e \u003e \u003e I don\u0027t believe this is an accurate statement. From my understanding, technically the \"lib\" mechanism exposes the API, not the plugin. \n\u003e \u003e \n\u003e \u003e You are indeed correct, it is documented at [1]. Because Davido\u0027s change about plugins dependency mechanism in the plugin loader was not merged, we still have to use this technical solution to expose a common API.\n\u003e \n\u003e That change does something very cool, it has this class:\n\u003e \n\u003e https://gerrit-review.googlesource.com/c/gerrit/+/54428/25/gerrit-server/src/main/java/com/google/gerrit/server/plugins/MultiParentClassLoader.java\n\u003e \n\u003e which I wanted to implement also, but had not tried yet to see if it would work. If that class works, then I have a proposal that I am trying to get prototyped that will avoid the load ordering issues of that change, which I believe was the major downside of that specific approach.\n\u003e \n\u003e The basic idea is to take advantage of the fact that most execution paths are \"short lived\", i.e. they start with a request, and they end when the request is finished. This means that you only need the MultiParentClassloader available for that short duration. Since for request based use cases you do not need the MultiParentClassloader available at plugin load time, you can simply ignore the plugin ordering issue altogether! It only matters at request time whether the other plugins are loaded. If they aren\u0027t, then the functionality of the dependent plugin can be gracefully unavailable as if none of the plugins were loaded.\n\u003e \n\u003e Basically my new proposal will combine the MultiParentClassloader with the ideas of this change: https://gerrit-review.googlesource.com/c/gerrit/+/129917 and this change: https://gerrit-review.googlesource.com/c/gerrit/+/129918 We can define another interface that would allow DynamicBeans to explicitly (the approach in those changes is implicit and can only use one other plugin) specify which other plugins to add to the current request\u0027s MultiParentClassloader and core can instantiate the DynamicBean from that classloader.\n\nBut that means that the plugin making the request needs to know the list of other plugins that are needed for serving that request, which is exactly the opposite of the Dynamic* approach in Gerrit.\n\nDo you have the code of your prototype, so that I can run and understand better how it works?\n\n\u003e Combine the approach above with this change, and I believe you will be able to access the APIs from other plugins without the need for reflection since you should now have the other plugin\u0027s classloader as a parent classloader! @DavidO, do you think this would work?\n\nI\u0027ve posted a PoC (see Change-Id: I63c9b7f2a) where plugins have other plugins in their parent class-loader, based on the definition of an exported ApiModule, but I believe you want to do that at *request time* and not through the plugin loader.\n\nVery intriguing idea, similar to what Voyager did in Java around 18 years ago: did you have a look at Voyager ORB and why their idea did not have success? (nobody uses Voyager in Java anymore).\n\n\u003e \u003e Let me rephrase: I was interested to know what is the functional use-case that is not possible with the current \u0027/lib\u0027 loading mechanism. From the technical functionality perspective, I agree with you, it is not possible to share a common interface between plugins at the moment, if not through the \u0027/lib\u0027.\n\u003e \n\u003e Gotcha, thanks. We will try to capture that better in the next patchset.\n\u003e \n\u003e \u003e If it is the technical problem that you are willing to address, I do understand your point and I believe we should involve Davido in the discussion as he had some interesting ideas to share.\n\u003e \n\u003e Yes, agreed! I hope he will join the discussion.\n\nHe did and pointed out that, actually, we already have plugins that depends on other plugins :-O and I was the author of it, just had forgotten about it :-(",
      "parentUuid": "bc78b244_55ddd75d",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 45
      },
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "733fc14c_28bdaa29",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 19,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-02-11T01:06:56Z",
      "side": 1,
      "message": "That is already possible with the current mechanism in Gerrit, and we actually use it in multi-site.\n\nI do not disagree with this alternative approach, however, it would be best to understand the differences and benefits of this approach against the current one implemented in Gerrit.\n\nI know that this change is small enough to not require a design document. However, a simple markdown file that describes what Gerrit can do today, what are the limits and problems with the current approach and what this new approach provides as benefits, would help me and other reviewers to better understand and appreciate this change.\n\nThanks for your time coding this solution and answering to my questions and comments, I do appreciate it.",
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0db1fe3b_18a2977a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 19,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-03-10T19:37:40Z",
      "side": 1,
      "message": "I\u0027ve created a simple PoC of how you could reuse the current plugin loader mechanism to achieve exactly this use-case.\n\nI tested with the replication plugin and works like a charm :-)\nNo need to use libModules, just define an ApiModule and with the extra interfaces, ready to be used by any other plugin.\n\nSee the PoC Change-Id: I63c9b7f",
      "parentUuid": "733fc14c_28bdaa29",
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c5f55522_5e0e0422",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1162066
      },
      "writtenOn": "2023-06-23T21:57:15Z",
      "side": 1,
      "message": "apply plugin:\u0027application\u0027\nmainClassName \u003d \u0027HelloWorld\u0027\n\nrun { standardInput \u003d System.in }\nsourceSets { main { java { srcDir \u0027./\u0027 } } }\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    // add dependencies here as below\n    implementation group: \u0027org.apache.commons\u0027, name: \u0027commons-lang3\u0027, version: \u00273.9\u0027\n}",
      "revId": "52b3151436aa7552b3adb6b31b55903ba785b680",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}