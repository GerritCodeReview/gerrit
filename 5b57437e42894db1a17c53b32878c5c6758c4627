{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "431ddb94_97cba7ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-21T07:17:07Z",
      "side": 1,
      "message": "Tested E2E with Gatling and stale check enabled",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5f8b564_cfdc1207",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-21T07:18:45Z",
      "side": 1,
      "message": "@Dmitrii I\u0027ve rebased the whole series and tested E2E with a suite of Gatling tests: all is fully working.\n\nDo we have a light at the end of the tunnel? Are we good? Any further feedback?",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2db1cd0f_3fe6df18",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-21T18:46:22Z",
      "side": 1,
      "message": "We had 30 patch-sets and 51 resolved comments, I\u0027m assuming we\u0027re good to go and I\u0027ll start the merge up to stable-3.1.\n\nAs agreed, the merge to stable-3.2 will be a noop as we don\u0027t want this code to be merged upstream.\n\n@Dmitrii feel free to send more feedback if you any additional concerns.",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb9de42b_d9ce5de7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T06:58:57Z",
      "side": 1,
      "message": "\u003e Do we have a light at the end of the tunnel?\n\nI think yes. But I want to make a final look on PerThreadCache/RepoRefCache. I don\u0027t expect to find any major problem, but there is some unclarity for me.\nI will write back in 1 hour.",
      "parentUuid": "e5f8b564_cfdc1207",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7969b546_67270728",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T07:14:20Z",
      "side": 1,
      "message": "\u003e \u003e Do we have a light at the end of the tunnel?\n\u003e \n\u003e I think yes.\n\nCool stuff, thanks a lot! I\u0027ve also made all the merges up to stable-3.3, showing that the commits aren\u0027t ported beyond stable-3.1.\n\n\u003e But I want to make a final look on PerThreadCache/RepoRefCache. I don\u0027t expect to find any major problem, but there is some unclarity for me.\n\u003e I will write back in 1 hour.\n\nSure, thanks.",
      "parentUuid": "bb9de42b_d9ce5de7",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce055500_a8250444",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T08:07:54Z",
      "side": 1,
      "message": "Sorry, I found something else to fix. But this looks like the last thing to fix",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08fff707_4320e713",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2022-04-22T08:17:56Z",
      "side": 1,
      "message": "Test comment.",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7acc3e58_7d529e02",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T08:32:10Z",
      "side": 1,
      "message": "@Dmitrii good catch, but that\u0027s a current problem we already have on stable-2.16 and is unrelated to this change. Let me address that as a separate change.",
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c2a53b0_dac27dd7",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T08:07:54Z",
      "side": 1,
      "message": "if cache.size() \u003e\u003d PER_THREAD_CACHE_SIZE, then loader is called and RepoRefCache is created, repo.incrementOpen is called. However repoRefCache.close() will never be called.\nIn my other comment I suggested how to update PerThreadCache and solve this problem.",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e8c1846_80500075",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1083225
      },
      "writtenOn": "2022-04-22T08:21:20Z",
      "side": 1,
      "message": "Testing, please ignore.",
      "parentUuid": "2c2a53b0_dac27dd7",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e91d6bf3_e0698b65",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T08:32:10Z",
      "side": 1,
      "message": "True but that is independent from this change isn\u0027t it? The problem is already in stable-2.16. Let me address that as a separate change: one change \u003d one thing :-)",
      "parentUuid": "2c2a53b0_dac27dd7",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134bbac5_856aa09d",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T08:39:32Z",
      "side": 1,
      "message": "\u003e True but that is independent from this change isn\u0027t it? The problem is already in stable-2.16\n\nNot sure, that it is already in stable-2.16. repo.incrementOpen/repo.close are added to RepoRefCache in this change (and IIUC repo.incrementOpen/repo.close are required only for staleness check)",
      "parentUuid": "e91d6bf3_e0698b65",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2aad8fcb_2a6ddd99",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T09:19:59Z",
      "side": 1,
      "message": "The problem of the repo being used after close was there already, because we are returning a cached RepoRefCache instance that holds a reference to a refDatabase which could have been closed already.\n\nWith the *currently merged code* in stable-2.16:\n\n1. RepoRefCache object is created, holding a reference to the refDatabase of a Repository\n```\n  public RepoRefCache(Repository repo) {\n    this.refdb \u003d repo.getRefDatabase();\n    this.ids \u003d new HashMap\u003c\u003e();\n  }\n```\n\n2. The method RepoRefCache.get() can be called at any time, even when the underlying Repository has been already closed.\n\n```\n  @Override\n  public Optional\u003cObjectId\u003e get(String refName) throws IOException {\n    Optional\u003cObjectId\u003e id \u003d ids.get(refName);\n    if (id !\u003d null) {\n      return id;\n    }\n    Ref ref \u003d refdb.exactRef(refName);\n    id \u003d Optional.ofNullable(ref).map(Ref::getObjectId);\n    ids.put(refName, id);\n    return id;\n  }\n```\n\nThe refdb used in the above code could use an already closed Repository.\n\nHence, we have this issue already now in stable-2.16 and we need to fix it regardless of this change.",
      "parentUuid": "134bbac5_856aa09d",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87a3033d_42188051",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T09:48:34Z",
      "side": 1,
      "message": "Just to clarify *WHY* I want to address this as a separate issue: the problem exists *regardless* of the thread-local caching of RepoRefCache objects. The fix would need to be merged up to master as we are also today risking to run a get() on the refDatabase of a closed Repository object.\n\nThanks for raising and spotting this out.",
      "parentUuid": "2aad8fcb_2a6ddd99",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7e773a0_6c90bbb6",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T09:58:39Z",
      "side": 1,
      "message": "\u003e The problem of the repo being used after close was there already, because we are returning a cached RepoRefCache instance that holds a reference to a refDatabase which could have been closed already.\n\nI might be wrong, but as I can see in https://gerrit-review.git.corp.google.com/c/gerrit/+/334539, all RepoRefCache usages are local, i.e. the pattern is (simplified):\n  // local variable\n  Optional\u003cRepoRefCache\u003e repoRefCache \u003d RepoRefCache.getOptional(repo);\n  ...use repoRefCache if present, otherwise use repo\n  // end of method, forget about repoRefCache\n  \nThe repo is always open when RepoRefCache.getOptional(repo) is called, so we are 100% sure that repoRefCache uses opened repo here.\n\nAnd RepoRefCache is never used anywhere else (i.e. PerThreadCache doesn\u0027t clean it up later), so stable-2.16 shouldn\u0027t have this problem. The problem appears because here we are trying to check stale references later.\n\n\u003e Just to clarify *WHY* I want to address this as a separate issue\nWhat do you think about my idea with unloaders, which should solve both problems (ownership of Repository + this one)?\nIn overall, I\u0027m ok with fixing it as a separate issue, but I would like to have a full picture - parts depends on each other. I noticed this problem when I started to think about unloaders and I would say existing code is not easy to analyse because repo.incrementOpen and repo.close are processed differently (i.e. RepoRefCache is responsible for calling incrementOpen, but PerThreadCache is responsible for close).\nI am afraid that splitting fix into a different change makes it harder for review. So, if the fix is small - I would like to see it as a part of this change.",
      "parentUuid": "2aad8fcb_2a6ddd99",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35064c3b_84aea144",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 30
      },
      "lineNbr": 244,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-22T10:17:41Z",
      "side": 1,
      "message": "\u003e \u003e The problem of the repo being used after close was there already, because we are returning a cached RepoRefCache instance that holds a reference to a refDatabase which could have been closed already.\n\u003e \n\u003e I might be wrong, but as I can see in https://gerrit-review.git.corp.google.com/c/gerrit/+/334539, all RepoRefCache usages are local, i.e. the pattern is (simplified):\n\u003e   // local variable\n\u003e   Optional\u003cRepoRefCache\u003e repoRefCache \u003d RepoRefCache.getOptional(repo);\n\u003e   ...use repoRefCache if present, otherwise use repo\n\u003e   // end of method, forget about repoRefCache\n\u003e   \n\u003e The repo is always open when RepoRefCache.getOptional(repo) is called, so we are 100% sure that repoRefCache uses opened repo here.\n\nCorrect, but that doesn\u0027t deny the fact that the current code could lead to this problem, isn\u0027t it?\n\n\u003e And RepoRefCache is never used anywhere else (i.e. PerThreadCache doesn\u0027t clean it up later), so stable-2.16 shouldn\u0027t have this problem. The problem appears because here we are trying to check stale references later.\n\nThe same apply for stale reference check that is triggered by the auto-close in a local context. The cached objects are not long running and never last for longer than the current scope of the block.\n\nThe issue is more about the fragility of holding a reference to a Repository that *may be later closed*. I\u0027m uploading a simple test with the fix that shows the issue.\n\nAll these problems are theoretical of course, because none of them are actually happening at the moment, the get() or staleness check after close.\n\n\u003e \u003e Just to clarify *WHY* I want to address this as a separate issue\n\n\u003e What do you think about my idea with unloaders, which should solve both problems (ownership of Repository + this one)?\n\n\u003e In overall, I\u0027m ok with fixing it as a separate issue, but I would like to have a full picture - parts depends on each other. I noticed this problem when I started to think about unloaders and I would say existing code is not easy to analyse because repo.incrementOpen and repo.close are processed differently (i.e. RepoRefCache is responsible for calling incrementOpen, but PerThreadCache is responsible for close).\n\u003e I am afraid that splitting fix into a different change makes it harder for review. So, if the fix is small - I would like to see it as a part of this change.\n\nIt is actually easier to review because is more focused on the context and objective: see Change-Id: I7193952483b3",
      "parentUuid": "d7e773a0_6c90bbb6",
      "range": {
        "startLine": 241,
        "startChar": 6,
        "endLine": 244,
        "endChar": 7
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81520c0c_d5652de6",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 30
      },
      "lineNbr": 55,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T08:07:54Z",
      "side": 1,
      "message": "The thing which worries me here is that the ownership of the repo is unclear.\nI.e. repo.incrementOpen is called in the RepoRefCache, but refCache.close is called from the PerThreadCache.\nAt the same time, RepoRefCache doesn\u0027t implement AutoClosable - so, we can\u0027t expect that close() will be called.\n\nI don\u0027t think that we should add \"implements AutoClosable\" to RepoRefCache. Without merging to master this can lead to more divergence between master and old-branches.\n\nAnother idea (which I like more): allow to add unloader for cached elements.\nI.e.\n  public static Optional\u003cRefCache\u003e getOptional(Repository repo) {\n    ...\n    return cache.tryGet(PerThreadCache.Key.create(RepoRefCache.class, repo),\n      // Loader\n      () -\u003e { repo.incrementOpen(); new RepoRefCache(repo); },\n      // Unloader\n      (repoRefCache) -\u003e {\n        repoRefCache.checkStaleness();\n        repoRefCache.repo.close(); \n      } );\n     }\n    ...\n  }\nHere repo.incrementOpen/close are isolated and RepoRefCache object is not responsible for a Repository lifetime.\n\n\nAnd PerThreadCache can be updated with additional unloaders cache and tryGet method:\n  class PerThreadCache {\n    private final Map\u003cKey\u003c?\u003e, Consumer\u003c?\u003e\u003e unloaders \u003d\n      Maps.newHashMapWithExpectedSize(PER_THREAD_CACHE_SIZE);\n    ...\n    public \u003cT\u003e Optional\u003cT\u003e tryGet(Key\u003cT\u003e key, Supplier\u003cT\u003e loader, Consumer\u003cT\u003e unloader) {\n      if (disabledTypes.contains(key.clazz.getCanonicalName())) {\n        return loader.get();\n      }\n      @SuppressWarnings(\"unchecked\")\n      T value \u003d (T) cache.get(key);\n      if (value \u003d\u003d null \u0026\u0026 cache.size() \u003c PER_THREAD_CACHE_SIZE) {\n        // Call loader only if there is enough space in cache.\n        // Otherwise, cache can\u0027t call unloader\n        value \u003d loader.get();\n        cache.put(key, value);\n        unloaders.put(key, unloader);\n      }\n      return Optional.ofNullable(value);\n    }\n    private void removeKey(Key key) {\n      Consumer\u003cT\u003e unloader \u003d unloaders.get(key);\n      if(unloader !\u003d null) unloader(cache.get(key))\n    }\n    public void close() {\n      // Call removeKey for each key in dictionary\n      ...\n      CACHE.remove();\n    }           \n    private void removeRepoRefsCaches() {   \n      for(...) {//Iterate over all entries in cache\n        if (entry.value instanceof RepoRefCache) {\n         removeKey(key);\n        }\n      }\n    }\n  }\n  \nWith this solution, CacheStalenessCheck interface is not required - we can call required method from the unloader. Also, we can remove CacheStalenessCheck code from the PerThreadCache.",
      "range": {
        "startLine": 55,
        "startChar": 4,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "5b57437e42894db1a17c53b32878c5c6758c4627",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}