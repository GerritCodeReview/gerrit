{
  "comments": [
    {
      "key": {
        "uuid": "b5054619_1c13d8fd",
        "filename": "gerrit-acceptance-framework/src/test/java/com/google/gerrit/acceptance/AbstractNotificationTest.java",
        "patchSetId": 15
      },
      "lineNbr": 55,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-06-07T19:50:59Z",
      "side": 1,
      "message": "AbstractDaemonTest#name(String) is already designed to prefix an arbitrary resource name string with a suffix that is guaranteed unique per test method. Is there a reason that\u0027s not sufficient?",
      "revId": "5fa70e24e2d4a4001672f2d1f5c24e5cce1e2a62",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2aac6a8_7043ab3e",
        "filename": "gerrit-acceptance-framework/src/test/java/com/google/gerrit/acceptance/AbstractNotificationTest.java",
        "patchSetId": 15
      },
      "lineNbr": 170,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-06-07T19:50:59Z",
      "side": 1,
      "message": "It\u0027s not obvious to me at first reading whether this implies this is some subset of recipients, or the exact set of recipients, i.e. whether it\u0027s like IterableSubject#contains or IterableSubject#containsExactly.\n\nAre there any tests where you *don\u0027t* want to assert an exact set match over all of to/cc/bcc? ISTM it should pretty much always be exact. In that case maybe this would be clearer if you just did\n\n assertThat(...)\n     .toExactly(a, b, c)\n     .ccExactly(d, e, f)\n     .bccExactly(g, h, i)",
      "revId": "5fa70e24e2d4a4001672f2d1f5c24e5cce1e2a62",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f96d8021_86fdbd9e",
        "filename": "gerrit-acceptance-framework/src/test/java/com/google/gerrit/acceptance/AbstractNotificationTest.java",
        "patchSetId": 15
      },
      "lineNbr": 291,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2017-06-07T19:50:59Z",
      "side": 1,
      "message": "ISTM the approach of one unique per NotifyType makes your tests unable to detect a certain class of bugs. Specifically, a bug might cause a single account to be mentioned twice in the recipient list if the account is both an explicit recipient and also an implicit recipient via a watch. Since these accounts have names that are just the watch type, they will never appear anywhere else, so you would not be able to tell if this bug exists.\n\nYou could avoid this limitation by taking a Multimap\u003cString, NotifyType\u003e instead of a List\u003cNotifyType\u003e. Though honestly, the chance/severity of this bug might not on its own justify making that change.\n\nThat said, I think there may *also* be a readability improvement in test methods if you take a Multimap\u003cString, NotifyType\u003e instead. Specifically, a line like:\n\n StagedChange sc \u003d stageReviewableChange(ABANDONED_CHANGES);\n\ndoesn\u0027t scream to me \"create a user named \u0027ABANDONED_CHANGES\u0027 and set up a watch for them\"; in fact the first time I saw that in an actual test, I had to come back here to the implementation to see what it actually means.\n\nSimilarly:\n\n assertThat(sender).bcc(ABANDONED_CHANGES);\n\nis a bit of a head-scratcher at first glance.\n\nIf it were instead:\n\n stageReviewableChange(ImmutableListMultimap.of(\"watcher1\", ABANDONED_CHANGES));\n assertThat(sender).bcc(\"watcher1\");\n\nthen maybe that would be clearer.\n\n(Or you could come up with some more clever builder DSL thing, but at some point the readability returns are diminishing.)",
      "revId": "5fa70e24e2d4a4001672f2d1f5c24e5cce1e2a62",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}