{
  "comments": [
    {
      "key": {
        "uuid": "78522cda_2b955dc1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-12-14T09:38:08Z",
      "side": 1,
      "message": "I don\u0027t think that this functionality should be implemented by labels. Labels are intended for voting on changes. Using a label to disable existing permissions to vote on other labels sounds weird to me and I would prefer to not do this in Gerrit core.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "935a1a19_beecec70",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1073507
      },
      "writtenOn": "2018-12-20T23:17:17Z",
      "side": 1,
      "message": "We want to lock label changes while CI system is evaluating changes. How do you propose to do this? \n\nThis change was implemented following the idea of patchset lock (implemented in https://gerrit-review.googlesource.com/c/gerrit/+/72174/1)\n\nSome of the advantages of having a label function to do this are:\n1. Label locks would be visible to everyone.\n2. It can be easily removed by admins.\n3. It can be accompanied with comments that explains the reason for the label lock.\n4. It can be managed by the existing ACL framework.",
      "parentUuid": "78522cda_2b955dc1",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66524e98_ac86e860",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-12-21T08:12:20Z",
      "side": 1,
      "message": "I think you can just write a plugin that implements the SubmitRule extension point.\nHave a look at the simplesubmitrules plugin for an example.",
      "parentUuid": "935a1a19_beecec70",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81c00394_ec35b92f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-12-21T08:16:17Z",
      "side": 1,
      "message": "Oh wait maybe not. Because you want to prevent applying of new labels while the lock is there.\nThis won\u0027t work with the SubmitRule extension point, which for me is rather a proof that what you are trying to do here shouldn\u0027t be done by labels.\n\nI\u0027m aware of the patchset lock, I think doing this with labels was a mistake too.\n\nSo I would prefer if there was a clean extension point that allows plugin to validate/reject votes that are being done on a change and then have the lock logic in a plugin.",
      "parentUuid": "66524e98_ac86e860",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "989b4bff_c0a9d1c4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-12-21T08:17:06Z",
      "side": 1,
      "message": "Also keep in mind that there is active work being done to remove Prolog from Gerrit core.",
      "parentUuid": "81c00394_ec35b92f",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ac18f98_563e25ca",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2018-12-21T16:06:40Z",
      "side": 1,
      "message": "We prevent applying of new labels, prevent modification of existing labels, and prevent removal of reviewers (and their labels) (except by admins). We view all of those as essential for ensuring a CI system can safely evaluate a change.\n\nI don\u0027t think a single extension point would cover the 4 advantages Sabari listed above. Those are all significant pluses to using labels.\n\nThe Prolog integration is trivial and should be easy to adopt to whatever happens with the rest, so I\u0027m not worried about that.\n\nWe\u0027re happy to do this through a plugin or other method, but currently those other methods either don\u0027t meet our needs or feel like we\u0027d be reimplementing labels.",
      "parentUuid": "989b4bff_c0a9d1c4",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bcb84bab_74ad9b62",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-12-24T08:16:07Z",
      "side": 1,
      "message": "I think implementing this by labels is not providing any good user experience.\nIf this feature is done in Gerrit core it should be very obvious in the UI when a change is locked so that users have a chance to understand why they can\u0027t vote. I think a vote an some label isn\u0027t clear enough. It would be quite confusing if some labels lock the change, how would a user know that a label results in a lock? Also for locked changes there shouldn\u0027t be any voting buttons in the UI. Letting the users click and then fail is not a nice UX, and an AuthException is not really appropriate in this case (since authentication worked and the user has all necessary permissions to vote).",
      "parentUuid": "3ac18f98_563e25ca",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b276cc48_ebcdedaf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-18T14:39:32Z",
      "side": 1,
      "message": "I agree with Edwin here. Thanks for improving the original proposal and adjusting the voting buttons to not show when locking is in place. I just think that this is not sufficient. As Edwin pointed out, the label in general is not clear enough, especially for users who are not (yet) that familiar with Gerrit.\n\nCan you also provide more details why the label locking mechanism is necessary? I saw some explanations above regarding CI integration. What I would like to understand is in which way exactly this is relevant (e.g. should reviewer votes be frozen and if so, why; or is this rather relevant to freeze labels used for CI integration). If we understand the user case better, it\u0027s easier to discuss a solution for it.",
      "parentUuid": "bcb84bab_74ad9b62",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "923aa5c4_c61d594a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-07-18T15:49:09Z",
      "side": 1,
      "message": "\u003e I agree with Edwin here. Thanks for improving the original proposal and adjusting the voting buttons to not show when locking is in place. I just think that this is not sufficient. As Edwin pointed out, the label in general is not clear enough, especially for users who are not (yet) that familiar with Gerrit.\n\nI can understand the concern about users clearly knowing when a change is label locked. We\u0027ve had this feature on our fork for almost 5 years now, so I can\u0027t perfectly recall how users reacted to it at first. We chose a simple name for the label \"Approval Lock\" and that seemed to be pretty self-explanatory for most users. We\u0027re very open to ideas on how to improve this further though.\n\n\u003e \n\u003e Can you also provide more details why the label locking mechanism is necessary? I saw some explanations above regarding CI integration. What I would like to understand is in which way exactly this is relevant (e.g. should reviewer votes be frozen and if so, why; or is this rather relevant to freeze labels used for CI integration). If we understand the user case better, it\u0027s easier to discuss a solution for it.\n\nSure. The problem we had before adding this lock was that sometimes users would modify labels such that a change was no longer submittable, but we were already running CI on that change which expected to be able to submit the change on success.\n\nSo the timeline would look something like this:\n\n1) change 1 uploaded for review\n2) change 1 reviewed (Code-Review +2)\n3) CI finds changes with Code-Review +2 and no V-1/CR-2 (i.e. will be submittable after CI gives V+1)\n4) CI starts on change 1 (CI runs for 1-2 hours)\n5) user who gave Code-Review +2 looks at change 1 again, finds an issue, and modifies their Code-Review +2 to be a Code-Review -1\n6) CI completes and marks the change V+1\n7) CI tries to submit the change and it fails\n\nNow I\u0027d like to point out that the \"resolution\" we picked here is not the only way to solve this in a CI system. The CI system could just fail, or it could detect labels changing (mid-way or at the end) and fail gracefully. Our customers chose to highly value CI job time and therefore wanted a way to ensure step 7 wouldn\u0027t fail due to some user action. Further supporting that, often we found that the user acting in step 5 did so without realizing the impact to CI. Those users have actually been quite happy that they\u0027re prevented from accidentally breaking CI now (since they too value CI job time).\n\nTo make sure I\u0027m answering all your questions, I would summarize the need as being able to partially (the CI user needs to be able to do step 6) freeze labels that control submitability of a change.\n\nI apologize for not providing that background up front. Hopefully it helps understand the use case we\u0027ve found.",
      "parentUuid": "b276cc48_ebcdedaf",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "174de39a_d8fd2f70",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T13:39:03Z",
      "side": 1,
      "message": "Thanks for providing the details on your specific use case. Running CI in vain, especially if it takes some hours, can be very frustrating for users and admins alike. Besides the valuable CI job time you already mentioned, I can also imagine that users are annoyed if they have to wait for CI to finish again if they unintentionally interrupted it (or just did it for some minor reason). In addition, the interrupts could also mean that the load on the CI system is unnecessarily higher in general and hence waiting time per change is higher, which might also lead to unhappy users. Hence, I\u0027m highly in favor of finding a solution for it.\n\nThat said, I think that the label locking approach suggested in this change solves this use case only partially. Labels are just one aspect which can prevent a change from being submitted. Besides merge conflicts, which could happen if other changes are merged in the meantime, I\u0027m most concerned about other submit rules. We don\u0027t have many in core Gerrit yet but I think this will change in the future. In addition, plugins are allowed to bring their own submit rules. Hence, the situation you described could still occur and might even be more severe (e.g. a user adds an unresolved comment and submit is now blocked as the plugin requires that all comments must be resolved before submit). It would be good if we found a solution which encompasses those aspects as well and which provides a good overall user experience.",
      "parentUuid": "923aa5c4_c61d594a",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73052469_6b1842a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-07-23T15:39:21Z",
      "side": 1,
      "message": "\u003e That said, I think that the label locking approach suggested in this change solves this use case only partially. Labels are just one aspect which can prevent a change from being submitted. Besides merge conflicts, which could happen if other changes are merged in the meantime, I\u0027m most concerned about other submit rules. We don\u0027t have many in core Gerrit yet but I think this will change in the future. In addition, plugins are allowed to bring their own submit rules. Hence, the situation you described could still occur and might even be more severe (e.g. a user adds an unresolved comment and submit is now blocked as the plugin requires that all comments must be resolved before submit). It would be good if we found a solution which encompasses those aspects as well and which provides a good overall user experience.\n\nWhile I appreciate that there could be situations in the future that would require improvements to this solution, I don\u0027t understand the resistance to at least having this *optional* feature available now. No one has to use label locking if they don\u0027t want to. I\u0027m all for a solution that can be as future proof as possible, but without such a proposal from anyone, your reasoning sounds a bit like perfect being the enemy of good. Rarely do we need perfect.\n\nCan this change please move forward or do you have an alternate proposal for us to consider?",
      "parentUuid": "174de39a_d8fd2f70",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 26
      },
      "revId": "627a5db2884f3203e9f75f73730886789fe0f08a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}