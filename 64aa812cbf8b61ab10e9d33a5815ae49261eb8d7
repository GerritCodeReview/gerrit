{
  "pushCert": "certificate version 0.1\npusher Dave Borowitz \u003cdborowitz@google.com\u003e 1532444563 -0700\nnonce APISObTB1lIfT4Y2KrwEccFW60yUbiyLm6yYs9S11mPCueO+3/ukG+sB5misxhRf9PzMpVw5kEj4\n\n0000000000000000000000000000000000000000 64aa812cbf8b61ab10e9d33a5815ae49261eb8d7 refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCgAzFiEEpPm/sOxWgSqG5grhX9fFmpoSiIwFAltXP5MVHGRib3Jvd2l0\nekBnb29nbGUuY29tAAoJEF/XxZqaEoiMA2UQAJLyvx3OKFLovlDSRIR6m5Z3FN04\nULvR99wlEAlx3ySH2uBe+eNcHiB7hIJn4kCO8S4+PRymUg3/qWG85aD49ATwwnJm\nLI1AYHo2+bSYjCfsorpWNIMDa03nGCHkbUr1NK7BMEjhYmP7jr3JQkgAUk2d6NoX\nei+mkmQvYkGUiRsOUcpJNyZLC8srAIPfBK0HB25ayhalBrr69Dpy8p4RY/HhELuv\nhx49F26hzxkVUrN+I4yToHyDn5fyqDT49IIVwfdtPh3Cpc+dqvpyscXgGb8RtMrK\nUxAbNTG4FhXBAPc/iu1/hvqZSBn8TV1jsUpuFhWydl+t0rP0IJP/N4oSC5g/V7sV\n3WHZSIRRBpxGNj6J9S8MtYITNdWtAEiqLhk0kXjr9uH5og6Vvxa1YoFTJ03AO1Fz\nYcLb/oRrDxI7AYScWG/xKFeqf3fU+nl8pkoN7DXed7QOhFpOAAvWX/iY0QcHP3wp\nD8hIP7Oa3gDWKGqezhQ7PM/BxGV8TdOQRKwXlfo3HCQF3CMcdhK5VHhZeQK6D6Bi\neCpww3eMQVYiETqkfYrVVwJzFzZIsLMWhnJJEiPxDkI5PlOs3ZsCc26oAizBwNGi\nAu6Pd/mbKc0hBqaQM5MbDUFtzVk7cRDmkpdmawQk8wZeKR6xdO8US0wUzTbH9ktC\nrNqmvr92h8xcf3IM\n\u003d2jQ7\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "c60472f6_265ab3ec",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 4
      },
      "lineNbr": 48,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-07-27T14:49:58Z",
      "side": 1,
      "message": "In my opinion, this method should be close to toProto().",
      "range": {
        "startLine": 48,
        "startChar": 16,
        "endLine": 48,
        "endChar": 25
      },
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c2d0f90_bcc10118",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 4
      },
      "lineNbr": 48,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-27T23:11:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c60472f6_265ab3ec",
      "range": {
        "startLine": 48,
        "startChar": 16,
        "endLine": 48,
        "endChar": 25
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fee43cc0_3affbcf3",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-07-27T14:49:58Z",
      "side": 1,
      "message": "Can this be null?",
      "range": {
        "startLine": 410,
        "startChar": 55,
        "endLine": 410,
        "endChar": 60
      },
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14c31467_b8a2509c",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-27T23:11:04Z",
      "side": 1,
      "message": "In practice I think it never is, and this method is only used in test assertion failures. But we don\u0027t have nearly enough null checks (such as in the constructor) to rely on this. Done.",
      "parentUuid": "fee43cc0_3affbcf3",
      "range": {
        "startLine": 410,
        "startChar": 55,
        "endLine": 410,
        "endChar": 60
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2109032a_a4c8101f",
        "filename": "java/com/google/gerrit/server/git/TagSetHolder.java",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-07-27T14:49:58Z",
      "side": 1,
      "message": "Just double-checking: Can we be sure that this is not null? We have a check one line up but the field is marked as volatile and hence probably used in multi-threaded contexts. In theory, object.tags could change between those lines.",
      "range": {
        "startLine": 112,
        "startChar": 18,
        "endLine": 112,
        "endChar": 29
      },
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "042334ab_c7f702c7",
        "filename": "java/com/google/gerrit/server/git/TagSetHolder.java",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-27T23:11:04Z",
      "side": 1,
      "message": "Forgot this was volatile, factored into a local.",
      "parentUuid": "2109032a_a4c8101f",
      "range": {
        "startLine": 112,
        "startChar": 18,
        "endLine": 112,
        "endChar": 29
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df77e8a1_5a6b8c20",
        "filename": "java/com/google/gerrit/server/git/TagSetHolder.java",
        "patchSetId": 4
      },
      "lineNbr": 122,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-07-27T14:49:58Z",
      "side": 1,
      "message": "Is this the same as proto.hasTags()? If not, what\u0027s the difference and why do we need it? (Sorry for asking. I just don\u0027t know protobuf well enough.)",
      "range": {
        "startLine": 122,
        "startChar": 10,
        "endLine": 122,
        "endChar": 67
      },
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af7940cd_6bfc4a81",
        "filename": "java/com/google/gerrit/server/git/TagSetHolder.java",
        "patchSetId": 4
      },
      "lineNbr": 122,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-27T23:11:04Z",
      "side": 1,
      "message": "If proto.hasTags() is false, then this expression will be true. But not the converse: hasTags() can return true and this expression can still be true. So this is analogous to treating null and the default value the same.\n\nI guess my thinking was, there is no reason you would want to create a TagSet with an empty project name, so if you see this, surely the caller meant to leave the field unset.\n\nBut I think it\u0027s probably easier to reason about if we just treat !hasTags as null and hasTags as non-null, since that\u0027s the exact inverse of the logic in serialize. Done.\n\n(Maybe we could also add a variety of checkArguments to the TagSet constructor so that we don\u0027t end up with degenerate instances with null or empty project names, but that seems largely orthogonal to what this method is trying to do.",
      "parentUuid": "df77e8a1_5a6b8c20",
      "range": {
        "startLine": 122,
        "startChar": 10,
        "endLine": 122,
        "endChar": 67
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6fc47efe_2f4f97bf",
        "filename": "javatests/com/google/gerrit/server/git/TagSetHolderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2018-07-27T14:49:58Z",
      "side": 1,
      "message": "Here and below: Verifying that the deserialized value matches the original value is missing.",
      "range": {
        "startLine": 25,
        "startChar": 14,
        "endLine": 25,
        "endChar": 34
      },
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7f854de_5778ede8",
        "filename": "javatests/com/google/gerrit/server/git/TagSetHolderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-27T23:11:04Z",
      "side": 1,
      "message": "The actual problem here is determining equivalence of TagSets. I didn\u0027t want to have to reproduce TagSetTest#assertEqual, so I punted.\n\nThe reason I can\u0027t use #equals is explained in the commit message. One answer might be to implement a TagSetSubject class with a method isEquivalentTo(TagSet other), and put the current contents of TagSetTest#assertEqual in there. The problem with that is, according to our package layout conventions, it would have to go in a separate subpackage, so we would have to make CachedRef and Tag public. I didn\u0027t really want to do that, though if you think it\u0027s the best available solution, I can.\n\n(I suspect if you ask a Java stylist \"What if I want my testing utilities to have access to package-private details of the classes under test?\" their answer would be \"design a better API that doesn\u0027t require you to do that\" :)\n\nAnother alternative would be to change get{Refs,Tags}ForTesting to return an immutable copy of the CachedRef/Tag maps, using types which can also be made public, and build TagSetSubject on that. But that would be another conversion layer which arguably would require its own set of tests, so it doesn\u0027t actually solve the problem.\n\nYet another alternative is to change CachedRef/Tag such that we can actually call equals on them, then we could just implement TagSet#equals. That would work for CachedRef, but it\u0027s impossible for Tag, because AnyObjectId#equals is final. (Regardless of what you think of that decision, it means that callers in the wild can and do depend the fact that you can call equals on different subclasses of AnyObjectId containing different sets of extra fields, and the semantics will be that it just compares the SHA-1 portions.) This could still be made to work if we change Tag to simply not be an ObjectIdOwnerMap.Entry, but that would have unknown performance consequences (most likely memory increases).\n\nAll that being said, as you point out, this test really does need to have that assertion. IOW, when I punted, I punted too far.\n\nFixed by the simple expedient of calling TagSetTest#assertEqual. Another short-term workaround would just be to combine the two test classes into one.\n\nLet me know what you think.",
      "parentUuid": "6fc47efe_2f4f97bf",
      "range": {
        "startLine": 25,
        "startChar": 14,
        "endLine": 25,
        "endChar": 34
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "64aa812cbf8b61ab10e9d33a5815ae49261eb8d7",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}