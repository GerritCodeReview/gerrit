{
  "comments": [
    {
      "key": {
        "uuid": "2a3188d1_a7f82a60",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T18:49:32Z",
      "side": 1,
      "message": "Why null and not key.getOldId()?",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a3188d1_67ef1290",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2014-05-19T19:09:22Z",
      "side": 1,
      "message": "The code is correct as written.\n\nWe want paths to be a set of path strings modified between Base and the B side, aka what files you changed in the commit. Passing in null will lookup the ancestor for the path list.\n\nWhat I find odd is why we don\u0027t recursively use the cache to fetch this \"Base..B\" compare. That is probably already computed and already in cache, as it is what we displayed when the user first loaded the change in the UI before being able to change the revision to compare against.\n\nMaybe the recursive lookup causing deadlock because it needed to acquire two bucket locks in the cache? So its not a good idea to reuse the cache from within itself?\n\nI wonder if getIfPresent() is safe to use within the loader. I suspect it would return a hit a very large majority if the time.",
      "parentUuid": "2a3188d1_a7f82a60",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a26849c_86f32a85",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T20:08:14Z",
      "side": 1,
      "message": "I told Edwin in a previous patch set not to recursively load. In general recursive load on an old history and an empty cache (like the first time this change is pushed to production) will be slow at best and blow the stack at worst.\n\nIt may be the case that we can prove the recursion is bounded after one or two calls, but in that case it is easier to reason about if we just don\u0027t use recursion and factor out the base case logic to be called directly. That is basically what the implementation of setPaths boils down to.",
      "parentUuid": "2a3188d1_67ef1290",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff23b49a_b68e486a",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:28:38Z",
      "side": 1,
      "message": "Loading it recursively from the cache would work. With the tests it\u0027s always already present in the cache, but even if I forcefully invalidate all cache entries right before I call patchListCache.get(key) here, which enforces a recursive loading, it just works fine. No deadlock. I believe with this approach the performance would be slightly better since it\u0027s using what is already cached. On the other hand, having the code in getPaths() looks cleaner and safer. Just let me know which solution is preferred. I\u0027m fine with both approaches.",
      "parentUuid": "0a26849c_86f32a85",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a26849c_c6fd224f",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T20:33:15Z",
      "side": 1,
      "message": "Recursive cache loads by work by design for Guava caches. My concern is specifically in this application that an empty cache may result in many thousands of recursive calls to load.",
      "parentUuid": "ff23b49a_b68e486a",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff23b49a_968b4c5a",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:35:13Z",
      "side": 1,
      "message": "Ok, now I got your point.\n\nShawn, should we stay with the getPaths(...) method then as it is now?",
      "parentUuid": "0a26849c_c6fd224f",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a3188d1_871c0601",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 153,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2014-05-19T19:09:22Z",
      "side": 1,
      "message": "I think this is more clear:\n\n  if (paths \u003d\u003d null || paths.contains(newPath) || paths.contains(oldPath)) {\n    entries.add(...)\n  }\n\nLess negation around the filtering predicate is more readable.",
      "range": {
        "startLine": 149,
        "startChar": 8,
        "endLine": 153,
        "endChar": 9
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca1f0c44_c4fd1e4f",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 153,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:28:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2a3188d1_871c0601",
      "range": {
        "startLine": 149,
        "startChar": 8,
        "endLine": 153,
        "endChar": 9
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}