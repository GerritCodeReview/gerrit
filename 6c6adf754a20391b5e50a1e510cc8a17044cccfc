{
  "comments": [
    {
      "key": {
        "uuid": "2a3188d1_a7f82a60",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T18:49:32Z",
      "side": 1,
      "message": "Why null and not key.getOldId()?",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a3188d1_67ef1290",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2014-05-19T19:09:22Z",
      "side": 1,
      "message": "The code is correct as written.\n\nWe want paths to be a set of path strings modified between Base and the B side, aka what files you changed in the commit. Passing in null will lookup the ancestor for the path list.\n\nWhat I find odd is why we don\u0027t recursively use the cache to fetch this \"Base..B\" compare. That is probably already computed and already in cache, as it is what we displayed when the user first loaded the change in the UI before being able to change the revision to compare against.\n\nMaybe the recursive lookup causing deadlock because it needed to acquire two bucket locks in the cache? So its not a good idea to reuse the cache from within itself?\n\nI wonder if getIfPresent() is safe to use within the loader. I suspect it would return a hit a very large majority if the time.",
      "parentUuid": "2a3188d1_a7f82a60",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a26849c_86f32a85",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T20:08:14Z",
      "side": 1,
      "message": "I told Edwin in a previous patch set not to recursively load. In general recursive load on an old history and an empty cache (like the first time this change is pushed to production) will be slow at best and blow the stack at worst.\n\nIt may be the case that we can prove the recursion is bounded after one or two calls, but in that case it is easier to reason about if we just don\u0027t use recursion and factor out the base case logic to be called directly. That is basically what the implementation of setPaths boils down to.",
      "parentUuid": "2a3188d1_67ef1290",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff23b49a_b68e486a",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:28:38Z",
      "side": 1,
      "message": "Loading it recursively from the cache would work. With the tests it\u0027s always already present in the cache, but even if I forcefully invalidate all cache entries right before I call patchListCache.get(key) here, which enforces a recursive loading, it just works fine. No deadlock. I believe with this approach the performance would be slightly better since it\u0027s using what is already cached. On the other hand, having the code in getPaths() looks cleaner and safer. Just let me know which solution is preferred. I\u0027m fine with both approaches.",
      "parentUuid": "0a26849c_86f32a85",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a26849c_c6fd224f",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-05-19T20:33:15Z",
      "side": 1,
      "message": "Recursive cache loads by work by design for Guava caches. My concern is specifically in this application that an empty cache may result in many thousands of recursive calls to load.",
      "parentUuid": "ff23b49a_b68e486a",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff23b49a_968b4c5a",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:35:13Z",
      "side": 1,
      "message": "Ok, now I got your point.\n\nShawn, should we stay with the getPaths(...) method then as it is now?",
      "parentUuid": "0a26849c_c6fd224f",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a26849c_66ef0e90",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2014-05-19T22:20:31Z",
      "side": 1,
      "message": "I don\u0027t see Dave\u0027s concern about the recursive calls.\n\nThe recursive call is exactly 1 deep. Its not some unbounded number. We won\u0027t blow the stack unless we mess up the recursion \"base case\" condition, which is to compare \"Base..N\". Which is the common diff Gerrit does almost all of the time. If you don\u0027t like 1 deep recursion with a clear base case then we should just never, ever use recursion, ever. :)\n\nOn an empty cache with many \"1..2\" types of requests, in the recursive version we first have to compute \"Base..2\" and then \"1..2\". So the cache fills up with many \"Base..2\" entries that aren\u0027t strictly required.\n\nI don\u0027t think that matters. The web UI will probably have already asked for \"Base..2\" before asking for \"1..2\", because that is how most humans interact with it.\n\nEven if you say all \"1..2\" requests are from automated bots that will never ask for \"Base..2\", at some point this is a code review system. A human may ask for \"Base..2\". In fact its likely as that is the default view in ChangeScreen2. So we might as well cache \"Base..2\" as part of the computation to create \"1..2\".\n\nThe cache is pretty big. In every major installation of Gerrit its backed by an even bigger disk cache. The cache entries themselves are fairly small (avg 1719 bytes). I\u0027m not worried about the cache size.\n\nIf index rebuilds use the PatchListLoader cache, they only ask for \"Base..2\" and never (currently) index \"1..2\". So they wouldn\u0027t trip the recursion. And they are already demanding the cache to build and store the thing that the recursion would be able to replay rather than recompute from Git.\n\n\ntl;dr: I\u0027m not sure which is faster. Using the cache or using Git. I suspect using the cache when renames are involved is faster. Using Git may be break-even when there are no adds or deletes to trigger rename/copy detection. But long ago we put the cache in place because Git wasn\u0027t always fast enough to do this on the fly. So in the absence of benchmark data on sufficient number of changes to show that Git is always faster than the immutable cache, I am inclined to recursively fill the immutable cache. My bet is the entry is already in there anyway.\n\nreal tl;dr: Recursively load.",
      "parentUuid": "ff23b49a_968b4c5a",
      "range": {
        "startLine": 141,
        "startChar": 14,
        "endLine": 141,
        "endChar": 18
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a3188d1_871c0601",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 153,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2014-05-19T19:09:22Z",
      "side": 1,
      "message": "I think this is more clear:\n\n  if (paths \u003d\u003d null || paths.contains(newPath) || paths.contains(oldPath)) {\n    entries.add(...)\n  }\n\nLess negation around the filtering predicate is more readable.",
      "range": {
        "startLine": 149,
        "startChar": 8,
        "endLine": 153,
        "endChar": 9
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca1f0c44_c4fd1e4f",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/patch/PatchListLoader.java",
        "patchSetId": 8
      },
      "lineNbr": 153,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-05-19T20:28:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2a3188d1_871c0601",
      "range": {
        "startLine": 149,
        "startChar": 8,
        "endLine": 153,
        "endChar": 9
      },
      "revId": "6c6adf754a20391b5e50a1e510cc8a17044cccfc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}