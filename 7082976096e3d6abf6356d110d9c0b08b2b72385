{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6e382b6c_4ac1cd81",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-12-22T08:54:46Z",
      "side": 1,
      "message": "We don\u0027t support inter-plugin dependency. If it currently works, then it works by accident.\n\nThe problem with inter-plugin dependency - besides complexity - is the diamond dependency problem.\n\nI explored inter-plugin dependency in the past and the conclusion was, that with the current plugin implementation in Guice, there is no good way of supporting it. We briefly considered using more established frameworks, but it wasn\u0027t worth the investment / additional complexity.",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cac74ce_f5aa06f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1096442
      },
      "writtenOn": "2020-12-22T10:32:05Z",
      "side": 1,
      "message": "can you kindly help me understand the diamond dependency problem with plugins...\n\n   A                  A\n /   \\              /   \\\nB     C            B     C\n \\   /             |     |\n   D               D     D1\n\nLets suppose, plugin A depends on B and C, plugin B and C depend on D. When a new version of D is release as D1 (lets say D1 has API interface changes which are being used by B and C). Lets say plugin B and C are already deployed onto server and plugin D1 is now deployed onto server in the place of D. So now plugin A, B and C will break as they are not compatible with D1. Is this use-case correct..?\n\nI think we don\u0027t support to deploy newer version of a particular plugin.., rather A1, B1, C1 (which adapts to D1 API changes) and war w1 also needs to be deployed onto the server along with D1..?",
      "parentUuid": "6e382b6c_4ac1cd81",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d87629f3_fd05a914",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-12-22T10:51:33Z",
      "side": 1,
      "message": "Yes, that use case illustrates the problem.\n\n\u003e I think we don\u0027t support to deploy newer version of a particular plugin\n\nI think there is no guarantee that there exists a version of plugin D that is compatible with all plugins that depend on it.\n\nAsking differently, what is your use case for this? Maybe there\u0027s an easier way to serve that.",
      "parentUuid": "1cac74ce_f5aa06f0",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cd2ee82_d2865413",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1096442
      },
      "writtenOn": "2020-12-22T11:20:21Z",
      "side": 1,
      "message": "Use-case: Plugin A provides a dynamic option (lets say --sample) for QueryChanges ssh/http request. Plugin A has custom code specific to org, --sample option uses the org specific logic and wants to invoke a generic plugin logic residing on Plugin B. \n\nThis is the use-case we are trying to address..",
      "parentUuid": "d87629f3_fd05a914",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a55cd161_8f644ae0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-12-23T08:46:12Z",
      "side": 1,
      "message": "And plugin A is open-source? Because otherwise you could just mold the two plugins together into one.\n\nCould you solve this at compile time instead of at runtime? For example, provide the functionality of --sample in a Java library that each plugin that needs it can compile in.",
      "parentUuid": "1cd2ee82_d2865413",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18ed2cf9_f39cf47d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-12-23T15:03:26Z",
      "side": 1,
      "message": "\u003e We don\u0027t support inter-plugin dependency. If it currently works, then it works by accident.\n\nI\u0027m not sure what you specifically mean by this, but several upstream features were introduced to support several inter plugin dependency approaches already.\n\nOne example of inter plugin dependencies might be a plugin designed to access the switches of another plugin on a core command. too support this better we added the @RequiresOptions() https://gerrit-review.googlesource.com/Documentation/dev-plugins.html#_calling_command_options annotation I help ensure that another plugin is installed before exposing functionality which may depend on it.\n\nWe specifically created a class loader which combines the class loader of two different plugins to support a plugin being able to add switches to another plugins command. See here for a bit more in this https://gerrit-review.googlesource.com/Documentation/dev-plugins.html#_calling_command_options\n\n\n\u003e The problem with inter-plugin dependency - besides complexity - is the diamond dependency problem.\n\nI don\u0027t think this applies to the current proposal, perhaps you could give a specific example if you think it does?",
      "parentUuid": "a55cd161_8f644ae0",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb05b642_23e44c0d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-01-07T08:46:05Z",
      "side": 1,
      "message": "\u003e I\u0027m not sure what you specifically mean by this, but several upstream features were introduced to support several inter plugin dependency approaches already.\n\nRequiredOptions was the only one I could find. Are there others?\n\nRequiredOptions looks pretty light-weight to me. It\u0027s just saying \"I need some other plugin to have implemented an option called foo but I don\u0027t care about more\".\n\nI am not a fan of inter-plugin dependencies, but this simple form of stating a requirement seems OK to me, especially because it uses just a single string for communicating a requirement.\n\nThe defininition/usage seems to follow that premise:\n@RequiresOptions(\"--help\")\n@Option(\"--help-as-json\")\n\nWhen I read the code, though, it seems it\u0027s doing something more complicated:\n\n\u003e The entity which provided additional options may need a way to receive a reference to the DynamicBean it provided (or) to the DynamicBean provided by other plugin.  \n\nNow we are passing objects around between the plugins, which is a completely different story because now you depend on a specific implementation of the other plugin and might have a binary dependency on the objects you share (or you copy them).\n\nFrom your use case, could this be solved at compile time?\n\n\u003e Use-case: Plugin A provides a dynamic option (lets say --sample) for QueryChanges ssh/http request. Plugin A has custom code specific to org, --sample option uses the org specific logic and wants to invoke a generic plugin logic residing on Plugin B. \n\nSo Plugin A has an interface definition of what it needs and instead of having plugin B provide that, it\u0027s a library that provides it that you bake in at compile time?\n\nWhy am I making these noises?\nThe logic around our usage of Guice especially for plugins is immensely complicated. For someone new to Gerrit, it takes quite some time to understand and propose sane changes that don\u0027t break. So I am trying to challenge any new complexity in this area.",
      "parentUuid": "18ed2cf9_f39cf47d",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5d66a3c_28baad4a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-01-07T19:30:54Z",
      "side": 1,
      "message": "\u003e \u003e We specifically created a class loader which combines the class loader of two different plugins to support a plugin being able to add switches to another plugins command. See here for a bit more in this https://gerrit-review.googlesource.com/Documentation/dev-plugins.html#_calling_command_options\n\n\u003e RequiredOptions was the only one I could find. Are there others?\n\nYes, sorry I got the link above for classloaders wrong. The classloader stuff is described here: https://gerrit-review.googlesource.com/Documentation/dev-plugins.html#command_options\n\n\u003e Now we are passing objects around between the plugins, which is a completely different story because now you depend on a specific implementation of the other plugin and might have a binary dependency on the objects you share (or you copy them).\n\nYes, correct. If a plugin A uses plugin B, it is important that when a bug is fixed in plugin B, that the fix also be in plugin A by loading a new copy of plugin B. This will not happen if you copy code from plugin B into plugin A. Also, if you copy code to another plugin, it will not only duplicate running code, but it will also duplicate running data, particularly harmful here are caches. It is generally bad practice in most software engineering environments to duplicate code. We did that many years ago and ran into the issues mentioned. I would not advocate this practice to plugin developers, and I would like to find good solutions to avoid this. I would qualify a good solution as one which adds less complexity to core than the complexity it saves in plugins. If it also encourages more code to be in plugins, then it is inherently reducing complexity in core.\n\n\u003e Now we are passing objects around between the plugins, which is a completely different story because now you depend on a specific implementation of the other plugin and might have a binary dependency on the objects you share (or you copy them).\n\nYes. I think this is generally a versioning problem that exists already in Gerrit since it does not check when loading plugins if they will even work with the version of Gerrit running. Today the responsibility for making sure there aren\u0027t plugin version miss-matches is put on the shoulders of admins. I think that is a reasonable solution, however if things become more complex I would definitely support solutions which help alleviate this burden.\n\n\u003e Why am I making these noises?\n\u003e The logic around our usage of Guice especially for plugins is immensely complicated. For someone new to Gerrit, it takes quite some time to understand and propose sane changes that don\u0027t break. So I am trying to challenge any new complexity in this area.\n\nThis is very understandable. I also think this solution is a bit hacky, and I would consider that hackiness a form of complexity. I think we proposed this solution because it uses an existing mechanism (so we can use it today to meet our current needs), but it might be better to have a more generic solution to allow plugins to interact better. I have struggled coming up with good solutions to this problem in the past, however I would like to propose a new less hacky approach in a different change. I suggest we discuss more of the sharing needs and complexity on that change. I\u0027ll post a pointer here once that is ready. Thanks for clarifying your feedback!",
      "parentUuid": "cb05b642_23e44c0d",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28de8959_64c224dd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-01-11T18:39:11Z",
      "side": 1,
      "message": "\u003e I would like to propose a new less hacky approach in a different change. \n\nHere it is: https://gerrit-review.googlesource.com/c/gerrit/+/293442",
      "parentUuid": "b5d66a3c_28baad4a",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be577feb_d9951753",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-01-14T12:58:42Z",
      "side": 1,
      "message": "Thanks, I\u0027ll look at that change instead then. Do you still want to work on this change then?\n\n\u003e  It is generally bad practice in most software engineering environments to duplicate code.\n\nThat\u0027s not what I suggested. If you pack your code in a library, that\u0027s not duplicating it. I see your point for caches.",
      "parentUuid": "28de8959_64c224dd",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d47b3c31_9a3534de",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-01-14T21:09:43Z",
      "side": 1,
      "message": "\u003e Thanks, I\u0027ll look at that change instead then. Do you still want to work on this change then?\n\nNo, probably not. I will abandon it.\n \n\u003e \u003e  It is generally bad practice in most software engineering environments to duplicate code.\n\u003e \n\u003e That\u0027s not what I suggested. If you pack your code in a library, that\u0027s not duplicating it. I see your point for caches.\n\nI\u0027m sorry if I miss-understood. I agree if by library you specifically mean using the gerrit.config library mechanism and not a bundled library that gets duplicated in side each plugin\u0027s jar.",
      "parentUuid": "be577feb_d9951753",
      "range": {
        "startLine": 12,
        "startChar": 15,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f54ed35b_6121eb76",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096442
      },
      "writtenOn": "2020-12-22T08:45:37Z",
      "side": 1,
      "message": "Hi Patrick, can you kindly review this change.., Martin and Nasser are out of office till 3rd Jan.",
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bd45184_e7ae6752",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-12-22T08:54:46Z",
      "side": 1,
      "message": "\u003e This feature is helpful in exposing an API from one\nplugin and consuming that API from other plugin.\n\nWe ",
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "877e3974_474273a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-12-23T08:46:12Z",
      "side": 1,
      "message": "Adding Han-Wen for a second opinion",
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "485f43c3_36b086f4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096442
      },
      "writtenOn": "2021-01-04T03:29:27Z",
      "side": 1,
      "message": "Hi Patrick, can you kindly reply to Martin\u0027s comment whenever you have sometime..",
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b65a6b29_bfddc64b",
        "filename": "java/com/google/gerrit/acceptance/AbstractDynamicOptionsTest.java",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-12-23T18:18:08Z",
      "side": 1,
      "message": "With reflection you can do anything. \n\nWhat does \u0027formally supported\u0027 mean in this context?",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 32
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00067f97_98310ad2",
        "filename": "java/com/google/gerrit/acceptance/AbstractDynamicOptionsTest.java",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1096442
      },
      "writtenOn": "2020-12-24T04:33:24Z",
      "side": 1,
      "message": "BeanReceiver and BeanProvider interfaces were providing a functionality to set and get a dynamic bean based on plugin name. But this feature was allowed to get its own dynamic bean for a plugin. In this change we are formally allowing to fetch other plugin\u0027s dynamic bean.",
      "parentUuid": "b65a6b29_bfddc64b",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 32
      },
      "revId": "7082976096e3d6abf6356d110d9c0b08b2b72385",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}