{
  "comments": [
    {
      "key": {
        "uuid": "76019955_21e9b7ae",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-18T11:28:49Z",
      "side": 1,
      "message": "I think this will give raw type warnings, try Class\u003c?\u003e",
      "revId": "752ac496f67e1f092e9bf2158ada1d4a12900e3e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "659d15b6_68b81e38",
        "filename": "java/com/google/gerrit/server/cache/PerThreadCache.java",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-18T11:28:49Z",
      "side": 1,
      "message": "Given our conversation yesterday about logging, part of me wonders if we should add at least one overload that doesn\u0027t require instantiating an array. I mean, we will still have to create an ImmutableList, but the array is just garbage. OTOH, it\u0027s premature optimization. OTOOH, the whole point of this class is avoiding excessive allocation, right?\n\n(We could change the implementation of Key to also avoid an array instantiation, but at that point I\u0027m sure it\u0027s premature optimization.)",
      "revId": "752ac496f67e1f092e9bf2158ada1d4a12900e3e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7caa6b3_ffbb4df1",
        "filename": "javatests/com/google/gerrit/server/cache/PerThreadCacheTest.java",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-18T11:28:49Z",
      "side": 1,
      "message": "Copyright header",
      "revId": "752ac496f67e1f092e9bf2158ada1d4a12900e3e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "83c0aa11_a5ff96b7",
        "filename": "javatests/com/google/gerrit/server/cache/PerThreadCacheTest.java",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-18T11:28:49Z",
      "side": 1,
      "message": "Use Truth",
      "revId": "752ac496f67e1f092e9bf2158ada1d4a12900e3e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c23da89_1efabada",
        "filename": "javatests/com/google/gerrit/server/cache/PerThreadCacheTest.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-04-18T11:28:49Z",
      "side": 1,
      "message": "Maybe create another cache and show it doesn\u0027t have value1, to prove that close() actually cleans it up.",
      "revId": "752ac496f67e1f092e9bf2158ada1d4a12900e3e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}