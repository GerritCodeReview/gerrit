{
  "comments": [
    {
      "key": {
        "uuid": "AAAB6H////s\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 198,
      "author": {
        "id": 1010022
      },
      "writtenOn": "2012-01-10T04:12:16Z",
      "side": 1,
      "message": "This exception will always be thrown if one of the repos has a series of changes that are chain-dependent. Suppose we had two repos R1 and R2 with some changes all part of a group. R1 has changes A and B, while R2 has change C. The problem seems to be that B will be marked unmergeable because A is not present during the test.\n\nThe fix would require some additional capabilities in MergeOp to let us check the mergeability of an entire group of changes, but there is change https://gerrit-review.googlesource.com/23582 waiting out there that needs to be merged first to make this easier and avoid duplication.",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////I\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "See 354, I think this can be simpler.",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////g\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 283,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "This is not thread safe, two threads could be attempting to add a new queue to the active map at the same time.",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////c\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 285,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "Also, I don\u0027t believe that you are using thread safe lists as queues.",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////Y\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 293,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "Could you explain these conditions, it appears that this will only return true if the request is not at the front of the queue?",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////M\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 340,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "If I understand your intent properly, I believe that this approach is still deadlock prone.  It appears that you are adding each request to its target queues unordered (targets is a hashset).  This means that in the simple two request case of X \u0026 Y for refs a and b, since the queues may get populated in any order, they could end up populated as a:X,Y and b:Y,X.  Would that not cause a deadlock?\n\nI suspect that even if you ordered the queuing, since it is a race, you could still end up with the same queuing outcome.\n\nMy suggestion is to ignore trying to be clever about contention ordering, use a set order such as alpha, and only add each request to a single queue until it reaches 0 in the queue (locked), at which point I believe it may be safely added to the queue for its next target.",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB6H////k\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 340,
      "author": {
        "id": 1010022
      },
      "writtenOn": "2012-01-10T18:02:04Z",
      "side": 1,
      "message": "I added \"synchronized\" to each of the interface methods intentionally, but now realize that it doesn\u0027t do exactly what I intended. Instead, I believe that if I synchronize around active inside the MergeRequest class, I will be ok (since I moved all interactions with active inside there). Assuming this is eventually implemented correctly, I don\u0027t think the deadlock can occur, since only one MergeRequest would be able to interact with the active map at any given time, thus preserving relative ordering between requests in any given ref\u0027s list of waiting requests.\n\nThe mutex\u0027ed type of behavior around active is what I originally intended, and I will upload a new patchset that is less bad in that respect. I think as long as only one thread can interact with active at any given time, there shouldn\u0027t be any issues. In fact, with the \"unblocking cascade\" of finishing requests, wouldn\u0027t it be the most responsive implementation possible?",
      "parentUuid": "AAAB5n////M\u003d",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB7X////8\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 340,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-11T05:13:38Z",
      "side": 1,
      "message": "Ok, I think I understand your intent now.  It probably won\u0027t deadlock since by sychronizing everything you will effectively be acquiring a global lock before acquiring the other locks.  This might work, but remember that you will also have to lock branches this way when users push to refs (bypassing review) also.  For this last reason, you may want to reconsider making your requests tied to the mergequeue or to any sort of scheduling.  Instead, you may be better of designing an independent lock structure which threads make blocking lock requests to.  On blocks, threads would be put to sleep and they would be woken up on lock releases with notify() if they can unblock.   I suspect that this might be easier and allow you to leave the mergequeue scheduling alone and it should allow Gerrit pushes to use this reflocker also.\n\nWith this approach you could wake up all the threads which would be unblocked by a release in a single pass.  Since you have a global lock for the locker, I suspect that there are actually some further optimizations which you could use to reduce contention by allowing certain requests to be prioritized differently than what the queues reflect.  If you distinguished between locked and the front of the queue, it would be possible to safely move entire requests from anywhere in the queues to the locked state on the fly. \n\nOne case where this might be important is to give pushers priority over mergers since pushers are always going to be a single fast ref update without a merge.  The next, but likely way less valuable case, would be to give the first request in the contention queue the first shot at attempting to acquire all its locks.  To make this more likely, you could also prevent any locks which would contend with that request from being acquired, even if that request cannot yet be satisfied.  This could really help prevent hot spots from getting too hot.  But this is risky, you\u0027d have to ensure that what you consider the contention queue is considered to be the same until this request is satisfied, and to be honest I am having a hard time picturing a hot spot which would actually benefit from priority treatment.",
      "parentUuid": "AAAB6H////k\u003d",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////U\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 354,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "You should be able to replace this loop with simply refs.addAll(targets).",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////Q\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 398,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "group is a set, other is a MergeRequest?",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAB5n////E\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2012-01-10T07:22:25Z",
      "side": 1,
      "message": "Why not reschedule failed groups also since the failure could be due to a currently unmerged depedency which is not in the group?",
      "revId": "7d62464bc22c40fae95e49df1dab4176bea5e3fa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}