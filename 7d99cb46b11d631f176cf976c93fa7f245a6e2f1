{
  "comments": [
    {
      "key": {
        "uuid": "e214de0a_0a25d71a",
        "filename": "java/com/google/gerrit/index/FieldDef.java",
        "patchSetId": 1
      },
      "lineNbr": 121,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-02-02T22:37:49Z",
      "side": 1,
      "message": "This check can never fail.",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 121,
        "endChar": 90
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d59443b_839f536d",
        "filename": "java/com/google/gerrit/index/FieldDef.java",
        "patchSetId": 1
      },
      "lineNbr": 121,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-04T17:37:45Z",
      "side": 1,
      "message": "A potential alternate implementation could be to replace these 2 booleans with an enum of NOT_SORTED, SORTED, SORTED_REVERSE -or similar. Since these two fields need to be manually checked and set together, which could become error prone.\n\nSuch an enum could provide boolean method helpers with guaranteed coherent behavior. Unless an enum cannot be a FieldDef field type? (If so, could keep the booleans yet set them based on enum logic.) -Or, unless introducing an enum would make the code more complex (thus as error prone) for the limited benefits.\n\nWondering also if this is covered enough by tests, either directly or indirectly.",
      "parentUuid": "e214de0a_0a25d71a",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 121,
        "endChar": 90
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "76aa26e0_be22b89e",
        "filename": "java/com/google/gerrit/index/FieldDef.java",
        "patchSetId": 1
      },
      "lineNbr": 121,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-02-05T21:44:19Z",
      "side": 1,
      "message": "Good idea, switched to using enum type. Done.",
      "parentUuid": "4d59443b_839f536d",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 121,
        "endChar": 90
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bb659d7_ffefce4f",
        "filename": "java/com/google/gerrit/index/FieldDef.java",
        "patchSetId": 1
      },
      "lineNbr": 121,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-06T17:44:29Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "76aa26e0_be22b89e",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 121,
        "endChar": 90
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba78a22f_343c11b2",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 360,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-04T17:37:45Z",
      "side": 1,
      "message": "SortedNumericDocValuesField, consistently with below SortedDocValuesField use?",
      "range": {
        "startLine": 360,
        "startChar": 20,
        "endLine": 360,
        "endChar": 41
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58f9033d_5f0c322a",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 360,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-02-05T21:44:19Z",
      "side": 1,
      "message": "Timestamp is stored as long and that why NumericDocValuesField is used.",
      "parentUuid": "ba78a22f_343c11b2",
      "range": {
        "startLine": 360,
        "startChar": 20,
        "endLine": 360,
        "endChar": 41
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4bbf685d_e86b11d5",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 360,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-06T17:44:29Z",
      "side": 1,
      "message": "My comment was more about, why not using SortedNumericDocValuesField instead of NumericDocValuesField, also knowing that SortedDocValuesField is used below (L368) for the string case. In other words, there is a Sorted-prefixed /named class also for NumericDocValuesField, i.e., SortedNumericDocValuesField, which could be considered here instead.",
      "parentUuid": "58f9033d_5f0c322a",
      "range": {
        "startLine": 360,
        "startChar": 20,
        "endLine": 360,
        "endChar": 41
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cf22738_5fa5fc76",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 360,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-04-18T14:58:07Z",
      "side": 1,
      "message": "My latest reply/comment above might have went unnoticed. -Reviving it now, just in case it did.",
      "parentUuid": "4bbf685d_e86b11d5",
      "range": {
        "startLine": 360,
        "startChar": 20,
        "endLine": 360,
        "endChar": 41
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8746bac_12180f21",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 438,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-04T17:37:45Z",
      "side": 1,
      "message": "FieldType.EXACT || type \u003d\u003d FieldType.PREFIX (?)\n\nIf this comment is applicable, is there a corresponding test missing to catch this prior?",
      "range": {
        "startLine": 438,
        "startChar": 16,
        "endLine": 438,
        "endChar": 31
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b75bb7d_0975ea98",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 438,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-02-05T21:44:19Z",
      "side": 1,
      "message": "You mean why we don\u0027t check here for both types, like we did for it on line: 362 above? FieldType.PREFIX is not used right now for sorted fields. I could assert in if (sorted) branch that  type !\u003d FieldType.PREFIXm but I decided not to do it, to not distract attention to too much asserts. But for consistency, I could check here to:\n\n  if (type \u003d\u003d FieldType.PREFIX || type \u003d\u003d FieldType.PREFIX) {...",
      "parentUuid": "b8746bac_12180f21",
      "range": {
        "startLine": 438,
        "startChar": 16,
        "endLine": 438,
        "endChar": 31
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28c99b15_bdde06f1",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 438,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-02-06T17:44:29Z",
      "side": 1,
      "message": "Yes, that\u0027s what I meant. I think you have a typo right above, though. The first \"PREFIX\" occurrence should read \"EXACT\" instead.\n\nHowever, I checked the callers of this very method here, and I found none that are clearly passing non-EXACT or PREFIX as field type, AFAIK. You can double-check that assumption though, before deciding on applying my original comment or not.",
      "parentUuid": "6b75bb7d_0975ea98",
      "range": {
        "startLine": 438,
        "startChar": 16,
        "endLine": 438,
        "endChar": 31
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90cd130d_8636a514",
        "filename": "java/com/google/gerrit/lucene/AbstractLuceneIndex.java",
        "patchSetId": 1
      },
      "lineNbr": 438,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2019-04-18T14:58:07Z",
      "side": 1,
      "message": "(Same for this other one.)",
      "parentUuid": "28c99b15_bdde06f1",
      "range": {
        "startLine": 438,
        "startChar": 16,
        "endLine": 438,
        "endChar": 31
      },
      "revId": "7d99cb46b11d631f176cf976c93fa7f245a6e2f1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}