{
  "comments": [
    {
      "key": {
        "uuid": "AAABEX///ZA\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Branch.java",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "I suspect that stringkey already has a good enough equals.",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+yY\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Branch.java",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "Martin, do you agree equals should be implemented? I agree with your comment considering I should implement 79th and 80th lines as:\n\nreturn this.getParentKey().equals(br.getParentKey()) \u0026\u0026 br.branchName.equals(this.branchName());",
      "parentUuid": "AAABEX///ZA\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+wg\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Branch.java",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-04T17:13:43Z",
      "side": 1,
      "message": "Please look into the StringKey implementation, it likely already compares get() and getParentKey().  If so, then no,you do not need to override it here.",
      "parentUuid": "AAABEX//+yY\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX///Y0\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Change.java",
        "patchSetId": 2
      },
      "lineNbr": 523,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "Comparing other to other?\n\nI don\u0027t think you want to assume that changes are equal just because the keys are equal.  An equals for a change should likely  compare all the fields.  Those who want to compare just the keys can do so by comparing the keys directly.",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+yU\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Change.java",
        "patchSetId": 2
      },
      "lineNbr": 523,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "523th line is completely wrong :-( You are right.\n\nI believe a Change instance should have a unique identifier (changeKey field). Shouldn\u0027t it be enough to use in equals so I could have Change as a key object in a Map?",
      "parentUuid": "AAABEX///Y0\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+wc\u003d",
        "filename": "gerrit-reviewdb/src/main/java/com/google/gerrit/reviewdb/Change.java",
        "patchSetId": 2
      },
      "lineNbr": 523,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-04T17:13:43Z",
      "side": 1,
      "message": "While it would be convenient in some cases, how then could someone compare two changes, say an old one and a new one which may have been edited, both referring to the same change, to see if the new one has had any fields altered, in order to figure out if the change should be updated in the db?  No, the same key means that you are referring to the same change, but it does not mean that they are equal.",
      "parentUuid": "AAABEX//+yU\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX///XU\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 129,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "Should remove() be wrapped with synchronized?",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+yQ\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 129,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "Yes. It should be fixed. Thanks.",
      "parentUuid": "AAABEX///XU\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX///eE\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 142,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "Why is this needed now that you have a HashMap, won\u0027t that prevent duplicate schedulings?",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+x4\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 142,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "Yes, HashMap is enough to prevent it.",
      "parentUuid": "AAABEX///eE\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+8g\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "Why are the mergeable ones not retested?",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+x0\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "My mistake :-( I should re-test all not closed and having destBranch as target.",
      "parentUuid": "AAABEX//+8g\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+wY\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-04T17:13:43Z",
      "side": 1,
      "message": "OK, but also, how will you know when a change is displayed wether it is in the queue (and potentially wrong)?  And what if the server goes down here, the changes will not get retested.  I do not think that waiting for antother change to be merged is acceptable, after all, this feature may prevent that from ever happening (since all changes could erroneously be marked unmergeable).",
      "parentUuid": "AAABEX//+x0\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+tE\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1004010
      },
      "writtenOn": "2011-07-05T17:33:23Z",
      "side": 1,
      "message": "Ok. \nAFAIU, we just need to atomically reset (set as test_pending) all changes for a branch at the time any is merged.\n\nWhat about reseting all those changes inside block atomicUpdate at line 1278?\n\nIf the server goes down just after a change merge, all changes are re-tested at the startup.\n\nWould it be enough?\n(I have it done, just push pending...)",
      "parentUuid": "AAABEX//+wY\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+s8\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-05T17:53:43Z",
      "side": 1,
      "message": "\u003e What about reseting all those changes inside block atomicUpdate at line 1278?\n\nThat might work, I am not sure how the atomicUpdate works, does that get run after the repo is updated to the new head though?  Do we already have a bit of a race here?  Can a change be merged to the head and potentially not get recorded in the DB?  that might not be a big deal if the state of the change is off, but if it prevents future merges (with this feature), it could maybe still be a problem?\n\nWould this still be able to deal with changes which are pushed to a repo using cgit (we still have to do that in some cases)?\n\nWhat will happen to the UI when changes are pending?  Anyway to force pending changes to be tested onload (displayed in the UI)?",
      "parentUuid": "AAABEX//+tE\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+rs\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 2
      },
      "lineNbr": 979,
      "author": {
        "id": 1004010
      },
      "writtenOn": "2011-07-05T20:10:41Z",
      "side": 1,
      "message": "\u003eThat might work, I am not sure how the atomicUpdate works, does that get run after the repo is updated to the new head though?\n\nI\u0027m not sure either. I assume by the name that all operations whithin the block are atomic. But yes, it runs after the repo is updated.\n\n\u003eDo we already have a bit of a race here?\n\nMaybe we could put the reset in another atomicUpdate call in a new line between 276th and 277th line (just after merge and before db change status update)\n\n\u003eCan a change be merged to the head and potentially not get recorded in the DB?\n\nYes, eventually if server goes down meanwhile. \nThe only way to avoid this is to run atomically the git merge operation and all changes reset.\n\nAnother possibility could be:\nCreate a new status for Change.TestMergeStatus (reset_dest) and assign it to the change being merged (or just before the merge process start); if the server goes down, we will reset all changes for the \"dest\" of the change with TestMergeStatus \u003d RESET_DEST.\n\nA side effect could be if the merge fails, we would have to re-test all changes unnecessarily. However I think this is the best so far, isn\u0027t it?\n\n\u003eWould this still be able to deal with changes which are pushed to a repo using cgit (we still have to do that in some cases)? \n\nI don\u0027t know what cgit is about... but as long as it enters through Receive.java should work.\n\n\u003eWhat will happen to the UI when changes are pending? \n\nNothing. Submit button is normally enabled, but maybe we should change it.\n\n\u003eAnyway to force pending changes to be tested onload (displayed in the UI)?\n\nI have considered it in the beggining, but I\u0027ve given up because it would impact performance. Humm, however, if we test during page rendering only when change is pending_test might be reasonable.",
      "parentUuid": "AAABEX//+s8\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX///eY\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReloadChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-07-02T04:08:44Z",
      "side": 1,
      "message": "Logger needs to go first (before interfaces).",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABEX//+xw\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReloadChangeTestMergeQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-07-04T11:44:20Z",
      "side": 1,
      "message": "Ok.",
      "parentUuid": "AAABEX///eY\u003d",
      "revId": "810f4bcaf0a82ea63f6453364b3c0c168cfbbd6d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}