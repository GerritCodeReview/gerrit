{
  "comments": [
    {
      "key": {
        "uuid": "e20fd976_0337ce39",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1023465
      },
      "writtenOn": "2016-02-19T19:36:36Z",
      "side": 1,
      "message": "Sorry again, but I believe I just accidentally found a hole in the tests. This always gives true since I\u0027m passing the change id instead of the commit id. When I pass in the commit id it works correctly but either way the tests pass. I\u0027ll write or modify a test before submitting a new patch set.",
      "range": {
        "startLine": 409,
        "startChar": 53,
        "endLine": 409,
        "endChar": 67
      },
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e26b592f_43a0c6bc",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1023465
      },
      "writtenOn": "2016-02-19T20:19:36Z",
      "side": 1,
      "message": "A \u003c- B \u003c- C\n^    ^\n|    |\nE \u003c- F* \u003c- G\n\nA is submitted, then B\nE and B has a conflict and merge F resolves any conflict\nC is then submitted, which creates a conflict with F\nF is not mergeable therefore G isn\u0027t either\n\nI can\u0027t think of any case where F would be mergeable but not G. If we make F mergeable by making it a child of C instead of B, G becomes mergeable since it\u0027s the last in the chain.\n\nI need help finding a case which would fail the test if \"isLastInChain\" is simply ignored (always true), I wish I could do this alone sorry for invoking so much help :p.",
      "parentUuid": "e20fd976_0337ce39",
      "range": {
        "startLine": 409,
        "startChar": 53,
        "endLine": 409,
        "endChar": 67
      },
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e26b592f_83a9dea7",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2016-02-19T20:42:59Z",
      "side": 1,
      "message": "\u003e I can\u0027t think of any case where F would be mergeable but not G. If we make F mergeable by making it a child of C instead of B, G becomes mergeable since it\u0027s the last in the chain.\n\nIf {C,G} are unrelated to {B, E, F }, then you would be able to merge F either before C was authored or after C was authored. G however would conflict with C if F was based on {B,E}, such that it is not built on top of C indirectly.\n\n\u003e I need help finding a case which would fail the test if \"isLastInChain\" is simply ignored (always true), I wish I could do this alone sorry for invoking so much help :p.\n\nNo worries :)\n\nI think you can ignore the lastInChain thing, so it would become:\n\n  If commit X is a merge commit, assume all parents of X to be mergeable.\n\nThis would solve graphs like you outlined above as things on top of the merge would be treated independently. However leaning back a bit and thinking about it, what about this:\n\n  for all commits with integration strategy is {merge-always, merge-if-necessary}:\n    find all commits without children (i.e. all \"last-in-chain\" commits)\n    and check their mergeability, ignoring all previous commits merge status\u0027\n  for all commits with integration strategy {rebase-if-necessary, cherry-pick}, check each commit too if they are mergeable.",
      "parentUuid": "e26b592f_43a0c6bc",
      "range": {
        "startLine": 409,
        "startChar": 53,
        "endLine": 409,
        "endChar": 67
      },
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e26b592f_c3b3d615",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2016-02-19T20:45:36Z",
      "side": 1,
      "message": "One of the tests is \n\n  A \u003c- B \n   \\\n    C  \u003c- D\n     \\   /\n       E\n\nand we try to merge D to B. There we could ignore {C,E}, not because D is a merge, but because D is last in chain and is mergeable. (For merging strategies only)\n\nIf we were to cherry-pick C,E,D then we would need to check them all as C or E may fail during cherry-pick.\n\nDoes that make sense?",
      "parentUuid": "e26b592f_83a9dea7",
      "range": {
        "startLine": 409,
        "startChar": 53,
        "endLine": 409,
        "endChar": 67
      },
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62f3e9ea_ef7fc1b6",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1023465
      },
      "writtenOn": "2016-02-22T15:15:25Z",
      "side": 1,
      "message": "I tried implementing your idea and it passed the tests. Although, I am using \"rebase-if-necessary\" on my test-site and the original (manual) test case does not pass. Is it normal for it not to be mergeable in test-case \"resolvingMergeCommitAtEndOfChain\" (the first one) when the strategy being used is not a merging one?",
      "parentUuid": "e26b592f_c3b3d615",
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4248a5fd_de314546",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/Submit.java",
        "patchSetId": 10
      },
      "lineNbr": 409,
      "author": {
        "id": 1017837
      },
      "writtenOn": "2016-02-23T01:25:05Z",
      "side": 1,
      "message": "yes, IIUC.\n\nSo the rebase-if-necessary strategy should produce linear history, no merges allowed. \n\nFrom the documentation on rebase-if-necessary:\n\u003e If the change being submitted is a strict superset of the destination branch, then the branch is fast-forwarded to the change. If not, then the change is automatically rebased and then the branch is fast-forwarded to the change.\n\nThis would mean in the first test case, we\u0027d always try rebasing as the commits E-H are not a \"strict superset\" of the target branch, i.e. there are commits on the target branch which are not parents of the changes E-H.\n\nAnd rebase fails as it doesn\u0027t \"backport\" the merge resolution from M to the offending commit M.\n\nSorry for the long discussion\u0026review, maybe we should have discussed the fundamentals first.",
      "parentUuid": "62f3e9ea_ef7fc1b6",
      "revId": "860598f12fa17c856017d8978d17ad14b2aec76d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}