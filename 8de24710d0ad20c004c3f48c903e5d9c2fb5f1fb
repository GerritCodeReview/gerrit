{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6cee976f_910a5832",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 28
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-20T14:25:10Z",
      "side": 1,
      "message": "Let me address the Repository caching issue raised by Dmitrii",
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f8f886b_e6e36f87",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-20T12:19:53Z",
      "side": 1,
      "message": "How can we ensure that refdb is still open when checkStaleness is called?\n\nGerrit actively reuses cached Repositories, so in the following code repo, repo2 and repo3 are the same instance:\n  try(Repository repo \u003d repoManager.openRepository(\"repoName\")) {\n    try(window \u003d PerThreadCache.openReadonlyWindow()) {\n      ...\n      try(Repository repo2 \u003d repoManager.openRepository(\"repoName\")) {      \n         RepoRefCache.getOptional(repo2) // returns cache for repo\n         ...\n      }      \n      try(Repository repo3 \u003d repoManager.openRepository(\"repoName\")) {      \n        RepoRefCache.getOptional(repo2) // returns cache for repo\n        ...\n      }\n    } // repo is still open\n  }\n  \nBut after removing outer repo, the repo2 and repo3 are 2 different instenaces:\n  try(window \u003d PerThreadCache.openReadonlyWindow()) {\n    ...\n    try(Repository repo2 \u003d repoManager.openRepository(\"repoName\")) {\n      RepoRefCache.getOptional(repo2) // returns cache for repo2\n      ...\n    }      \n    try(Repository repo3 \u003d repoManager.openRepository(\"repoName\")) {\n      RepoRefCache.getOptional(repo3) // returns cache for repo3\n      ...\n    }\n  } // repo2 and repo3 are closed, checkStaleness result is unclear\n  \nThe jgit code for repository.close() is:\n  ...\n  if (RepositoryCache.isCached(this)) {\n    closedAt.set(System.currentTimeMillis());\n  } else {\n    doClose();\n  }\n  \nI.e. if RepositoryCache.isCached is true, than Repository just set closedAt. So, checkStaleness can work with already closed repositories - and I can\u0027t predict what errors can we have.\n\nUnfortunately, I don\u0027t have any idea what to do with it and how to avoid use of a closed repository.\nDo you have any suggestions about it? (i.e. ensure that closed repository are not used in checkStaleness)\n\nOne idea - checkStaleness must be called only from tests. I.e. it shouldn\u0027t based on System.getProperty. But even in this case - it would be good to have some protection against use after close. Without such protection we can get a flaky tests.",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23832f59_f6e45551",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-20T12:56:55Z",
      "side": 1,
      "message": "\u003e How can we ensure that refdb is still open when checkStaleness is called?\n\u003e \n\u003e Gerrit actively reuses cached Repositories, so in the following code repo, repo2 and repo3 are the same instance:\n\u003e   try(Repository repo \u003d repoManager.openRepository(\"repoName\")) {\n\u003e     try(window \u003d PerThreadCache.openReadonlyWindow()) {\n\u003e       ...\n\u003e       try(Repository repo2 \u003d repoManager.openRepository(\"repoName\")) {      \n\u003e          RepoRefCache.getOptional(repo2) // returns cache for repo\n\u003e          ...\n\u003e       }      \n\u003e       try(Repository repo3 \u003d repoManager.openRepository(\"repoName\")) {      \n\u003e         RepoRefCache.getOptional(repo2) // returns cache for repo\n\u003e         ...\n\u003e       }\n\u003e     } // repo is still open\n\u003e   }\n\u003e   \n\u003e But after removing outer repo, the repo2 and repo3 are 2 different instenaces:\n\u003e   try(window \u003d PerThreadCache.openReadonlyWindow()) {\n\u003e     ...\n\u003e     try(Repository repo2 \u003d repoManager.openRepository(\"repoName\")) {\n\u003e       RepoRefCache.getOptional(repo2) // returns cache for repo2\n\u003e       ...\n\u003e     }      \n\u003e     try(Repository repo3 \u003d repoManager.openRepository(\"repoName\")) {\n\u003e       RepoRefCache.getOptional(repo3) // returns cache for repo3\n\u003e       ...\n\u003e     }\n\u003e   } // repo2 and repo3 are closed, checkStaleness result is unclear\n\u003e   \n\u003e The jgit code for repository.close() is:\n\u003e   ...\n\u003e   if (RepositoryCache.isCached(this)) {\n\u003e     closedAt.set(System.currentTimeMillis());\n\u003e   } else {\n\u003e     doClose();\n\u003e   }\n\u003e   \n\u003e I.e. if RepositoryCache.isCached is true, than Repository just set closedAt. So, checkStaleness can work with already closed repositories - and I can\u0027t predict what errors can we have.\n\nRepositories are kept at JGit level and are always kept open.\n\n\u003e Unfortunately, I don\u0027t have any idea what to do with it and how to avoid use of a closed repository.\n\u003e Do you have any suggestions about it? (i.e. ensure that closed repository are not used in checkStaleness)\n\nThis would be indeed a concern if we were NOT using cached repositories, but that isn\u0027t the case.\n\n\u003e One idea - checkStaleness must be called only from tests. I.e. it shouldn\u0027t based on System.getProperty. But even in this case - it would be good to have some protection against use after close. Without such protection we can get a flaky tests.\n\nWe do need to keep that check also for the running code, so that we can make E2E tests (using Gatling or other GUI testing) with the staleness check enabled.",
      "parentUuid": "4f8f886b_e6e36f87",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba334bd6_8657b397",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-20T14:25:10Z",
      "side": 1,
      "message": "I had an idea: we can register the Repository object with the JGit\u0027s repository cache, so we make sure that their reference count won\u0027t go to zero until we close the window or the cache.",
      "parentUuid": "23832f59_f6e45551",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8df4c3ea_14508adc",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-20T15:07:20Z",
      "side": 1,
      "message": "Sorted out: look at L56 and L96: the registration and unregistration with the JGit\u0027s RepositoryCache would assure that the Repository objects aren\u0027t closed, even logically.",
      "parentUuid": "ba334bd6_8657b397",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35f42fe8_5e4dabcb",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-20T16:03:16Z",
      "side": 1,
      "message": "\u003e Repositories are kept at JGit level and are always kept open.\nWe discussed this within the team and the logic is more complicated. Repositories are kept open for some time, but this is just an optimisation - they can be closed during the request after repository.close() at any time.\n\nAlso, this a bad practice to use a resource after it is closed, because it breaks the contract for AutoClosable (a resource must not be used after close()).\n\n\u003e Sorted out: look at L56 and L96: the registration and unregistration with the JGit\u0027s RepositoryCache would assure that the Repository objects aren\u0027t closed, even logically.\n\nI checked jgit code - IIUC RepositoryCache.register(repository) doesn\u0027t change anything if repository is already in the cache. Also this doesn\u0027t solve problem \"use after close\".\n\n--\n\nI also have and idea, but it requires slightly more work - we can pass a repo name when open cache window. The cacheWindow opens a repository and closes it.\n\nPros:\n1) cacheWindow is the owner of opened repository.\n2) The repository is explicitly opened/closed together with window. \nCons: 1) We must now repoName when open window (seems not a problem)\n2) Unclear what to do with GET/HEAD requests. Your implementation doesn\u0027t check stale references for such requests - and we can\u0027t check them safely, because all repositories are already closed. At the same time, we don\u0027t know in advance which projects should be cached in GET/HEAD request.\n\nMy prototype:\n  class SomeClass {\n    @Inject\n    SomeClass(..., RequestRepoRefCache refCache) {\n      this.refCache \u003d refCache;\n    }  \n    void someMethod() {\n     try(RequestCacheWindow window \u003d refCache.openCacheWindow(repoName)) {\n        ...// access to repoName refs are cached        \n     }\n    }\n  }\n  class RepoRefCache {\n    public static Optional\u003cRefCache\u003e getOptional(Repository repo) {\n        return RequestRepoRefCache.cacheForRepo(repo);\n    }\n    ...\n  }\n  class PerThreadCache {\n    ...\n    static class RequestRepoRefCache {\n     @Inject\n     RequestRepoRefCache(RepositoryManager repoManager) {..}\n     RequestCacheWindow openCacheWindow(NameKey repoKey) {\n        PerThreadCache cache \u003d PerThreadCache.get();\n        if(cache \u003d\u003d null) {\n         return emptyWindow;\n        }\n        // A little trick to create a key in advance:\n        Repository repo \u003d repoManager.open(repoKey);\n        Key key \u003d Key.create(RequestCacheWindowImpl.class, repo);\n        RequestCacheWindowImpl window \u003d cache.cache.get(key);\n        if (window !\u003d null) {\n          repo.close();\n        } else {\n          window \u003d new RequestCacheWindowImpl(repo);\n          cache.cache.put(key, window) ;// TODO: check cache size\n        }\n        window.open();\n     }\n     RequestRepoRefCache cacheForRepo(Repository repo) {\n       // Add check for null PerThreadCache;\n       return PerThreadCache.get(RequestCacheWindowImpl.class, repo).refCache;\n     }      \n    }\n    static class RequestCacheWindowImpl implements RequestCacheWindow {\n      Repository repo;\n      RepoRefCache refCache; //(lazy init)\n      void open() {\n        count++;\n      }\n      void close() {\n        count--;\n        if(count \u003d\u003d 0) {\n          // Any staleness check\n          repo.close();          \n          perThreadCache.remove(Key.create(RequestCacheWindowImpl.class, repo))\n          refCache \u003d null\n          repo \u003d null;\n        }\n      }\n    }\n  }",
      "parentUuid": "23832f59_f6e45551",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72284372_a9278aa0",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2022-04-20T16:26:18Z",
      "side": 1,
      "message": "\u003e \u003e Repositories are kept at JGit level and are always kept open.\n\u003e We discussed this within the team and the logic is more complicated. Repositories are kept open for some time, but this is just an optimisation - they can be closed during the request after repository.close() at any time.\n\nIn PS29 the Repository object is registered in the JGit\u0027s repository cache and unregistered when it isn\u0027t used anymore. By looking at what Repository.close() does, as long as it is cached, the close() isn\u0027t doing anything other than recording a timestamp.\n\n```\n\tpublic void close() {\n\t\tint newCount \u003d useCnt.decrementAndGet();\n\t\tif (newCount \u003d\u003d 0) {\n\t\t\tif (RepositoryCache.isCached(this)) {\n\t\t\t\tclosedAt.set(System.currentTimeMillis());\n\t\t\t} else {\n\t\t\t\tdoClose();\n\t\t\t}\n\t\t} else if (newCount \u003d\u003d -1) {\n\t\t\t// should not happen, only log when useCnt became negative to\n\t\t\t// minimize number of log entries\n\t\t\tString message \u003d MessageFormat.format(JGitText.get().corruptUseCnt,\n\t\t\t\t\ttoString());\n\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(message, new IllegalStateException());\n\t\t\t} else {\n\t\t\t\tLOG.warn(message);\n\t\t\t}\n\t\t\tif (RepositoryCache.isCached(this)) {\n\t\t\t\tclosedAt.set(System.currentTimeMillis());\n\t\t\t}\n\t\t}\n\t}\n```\n\nI\u0027ll also add the call do incrementOpen() and close() so that we make sure that the Repository object is always kept open and with the reference counting until the thread-local cache make references to it.\n \n\u003e Also, this a bad practice to use a resource after it is closed, because it breaks the contract for AutoClosable (a resource must not be used after close()).\n\nAgreed: the addition of incrementOpen() and close() would fix this issue.\n\n\u003e \u003e Sorted out: look at L56 and L96: the registration and unregistration with the JGit\u0027s RepositoryCache would assure that the Repository objects aren\u0027t closed, even logically.\n\u003e \n\u003e I checked jgit code - IIUC RepositoryCache.register(repository) doesn\u0027t change anything if repository is already in the cache. Also this doesn\u0027t solve problem \"use after close\".\n\nTrue, but the addition of incrementOpen() and close() would fix it.\n\n\u003e I also have and idea, but it requires slightly more work - we can pass a repo name when open cache window. The cacheWindow opens a repository and closes it.\n\nThe reference to the repository is taken when the RepoRefCache is created and needs to be removed when the RepoRefCache is closed/removed. That *may* or *may not* correspond with the cacheWindow. The right object to apply this logic is the RepoRefCache which is the one holding the reference to the Repository object. WDYT?\n\n\u003e Pros:\n\u003e 1) cacheWindow is the owner of opened repository.\n\nSee above: cacheWindow isn\u0027t the owner of the reference to the repository.\n\n\u003e 2) The repository is explicitly opened/closed together with window. \n\nUsing incrementOpen() and close() would achieve the same result.\n\n\u003e Cons: 1) We must now repoName when open window (seems not a problem)\n\nGerrit won\u0027t create a new Repository object anyway but just add a reference to it, which is exactly my proposed solution.\n\n\u003e 2) Unclear what to do with GET/HEAD requests. Your implementation doesn\u0027t check stale references for such requests - and we can\u0027t check them safely, because all repositories are already closed. At the same time, we don\u0027t know in advance which projects should be cached in GET/HEAD request.\n\nIn my solution, the close of the RepoRefCache would do the job, regardless of the read-only window. It will then work also for GET/HEAD requests.",
      "parentUuid": "35f42fe8_5e4dabcb",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43e3a6e1_331c57a7",
        "filename": "java/com/google/gerrit/server/git/RepoRefCache.java",
        "patchSetId": 28
      },
      "lineNbr": 106,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2022-04-22T06:55:04Z",
      "side": 1,
      "message": "Solution with incrementOpen/close LGTM, it doesn\u0027t break the contract. Also I found that internally (in google) we use similar solution with incrementOpen/close.",
      "parentUuid": "72284372_a9278aa0",
      "range": {
        "startLine": 106,
        "startChar": 24,
        "endLine": 106,
        "endChar": 29
      },
      "revId": "8de24710d0ad20c004c3f48c903e5d9c2fb5f1fb",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}