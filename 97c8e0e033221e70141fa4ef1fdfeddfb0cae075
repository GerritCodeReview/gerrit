{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cd5aface_bbf97574",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1013267
      },
      "writtenOn": "2021-11-18T09:40:16Z",
      "side": 1,
      "message": "ugh ... that won\u0027t work for many/most orgs, as they usually jump several versions at a time.\n\ni think you\u0027ll need to make a schema migration as considered in the original change, after all.",
      "range": {
        "startLine": 19,
        "startChar": 11,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19ecbaeb_bed505f4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-11-18T09:45:46Z",
      "side": 1,
      "message": "The difference between versions is just to give users *optional* ability to wait a bit, as it\u0027s not mandatory. Votes that are copied across patchsets on open changes that will be lost are not that big of a deal, and some orgs can choose either 1. not to care (since it\u0027s very minor), or 2. wait a bit between versions.\n\nI\u0027m resolving this since your comment is not respectful. If you like further answers, please phrase them in a respectful manner.",
      "parentUuid": "cd5aface_bbf97574",
      "range": {
        "startLine": 19,
        "startChar": 11,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c4c31919_b7a10cc0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1013267
      },
      "writtenOn": "2021-11-18T13:38:43Z",
      "side": 1,
      "message": "upon second thought i agree that the issue is too trivial to bother. still, make sure to mention it prominently in the release notes to avoid pointless bug reports.\n\ni\u0027m curious what *exactly* you found not respectful in my comment. that mild expression of astonishment?",
      "parentUuid": "19ecbaeb_bed505f4",
      "range": {
        "startLine": 19,
        "startChar": 11,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9aee8af3_0bd4bf6d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2021-12-01T16:39:39Z",
      "side": 1,
      "message": "\u003e Votes that are copied across patchsets on open changes that will be lost are not that big of a deal\n\nI don\u0027t think that\u0027s a reasonable assumption. If we have 20k+ open changes, there\u0027s a decent % of those that will have copied votes.\n\n\u003e some orgs can choose either 1. not to care (since it\u0027s very minor), or 2. wait a bit between versions.\n\nAddressed #1 above. #2 isn\u0027t always a viable option depending on an org\u0027s deployment schedule. I believe the only version that will have the \"persisting, but not reading\" behavior is 3.5. Forcing all orgs that don\u0027t want copied approvals lost to run 3.5 for X amount of time (this also seems indeterminate) isn\u0027t a reasonable approach.\n\n\u003e i\u0027m curious what *exactly* you found not respectful in my comment. that mild expression of astonishment?\n\nAs a CM, I also would like to know more about this. Gal, feel free to raise this concern with the CMs.",
      "parentUuid": "c4c31919_b7a10cc0",
      "range": {
        "startLine": 19,
        "startChar": 11,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "728fd5a8_02df8b12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-11-23T09:19:15Z",
      "side": 1,
      "message": "1) ApprovalInference: forPatchSet(ChangeNotes notes, PatchSet.Id psId, @Nullable RevWalk rw, @Nullable Config repoConfig) seems unused\n\n2) ApprovalInference: forPatchSet(\n      ChangeNotes notes, PatchSet ps, @Nullable RevWalk rw, @Nullable Config repoConfig) the RW and Config seem unused because the only caller passes in null?\n\nThis confuses me a bit, though. The code in PatchSetInserter calls dynamicallyComputeCopiedApprovals without passing a RevWalk. Usually, you can only read contents of the current transaction (i.e. the new patch set) when you pass a RevWalk. How can ApprovalInference determine e.g. the change type of the patch set we are currently creating when it doesn\u0027t get that RevWalk?\n\n3) I think this change is missing an important part: Reworking ApprovalInference to only ever attempt to copy from patch set latest-1 to latest when computing dynamic approvals.",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8616a2de_0a82c9cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-11-23T09:54:00Z",
      "side": 1,
      "message": "Note from in-person discussion: We will also need a solution for votes that are put on older patch sets using the UI (e.g. CI votes on older patch set).",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48776f28_15b8fef4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-11-23T12:31:39Z",
      "side": 1,
      "message": "ack, taking no action in this change, though.",
      "parentUuid": "8616a2de_0a82c9cb",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e96eb4b_0af8c095",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-11-23T12:31:39Z",
      "side": 1,
      "message": "1) good catch, but it\u0027s only unused in the next change. Done there.\n2) ha, black magic! The reason is that ChangeKindCache is getting invoked during this transaction, somewhere, earlier, so it\u0027s already in the cache and we don\u0027t need those RevWalks (I have some tests in StickyApprovalsIT#stickyVotesStoredOnUpload and the follow-up test for the rebase case. I was planning to refactor it by directly giving ChangeKind to this method, but forgot it. Doing in the follow-up.\n3) yep, doing that in a follow-up.",
      "parentUuid": "728fd5a8_02df8b12",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b617126_d574ff14",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-11-24T09:41:57Z",
      "side": 1,
      "message": "2) We can\u0027t rely on caches, because the are configurable and it is generally not guaranteed that they already contain a key/value pair.\n\nI suggest we pass down RevWalk and Config for the dynamic evaluation. It seems simple to do.\n\nAlso, passing ChangeKind seems like a one-off: ListOfFilesPredicate relies on the diff cache, so has the exact same problem. Hence, I\u0027d pass down RevWalks.\n\nNow, that brings me to the next question: How does the diff cache actually work when the Git transaction hasn\u0027t gone through yet? It doesn\u0027t accept RevWalk etc as parameters.\n\nThere is a problem with the ListOfFilesPredicate and the ChangeKindPredicate: These rely solely on caches as well. We don\u0027t have to fix that in this change, but need to look at it in the future.",
      "parentUuid": "2e96eb4b_0af8c095",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76d46642_f047ed7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-11-24T12:06:16Z",
      "side": 1,
      "message": "\u003e Now, that brings me to the next question: How does the diff cache actually work when the Git transaction hasn\u0027t gone through yet? It doesn\u0027t accept RevWalk etc as parameters.\n\n@ghareeb for the diff cache question :-)\n\nWDYT about just using ChangeKind and passing it further to ListOfFilesPredicate as well? It\u0027s basically the same as passing RevWalk, but imo it\u0027s a bit cleaner.",
      "parentUuid": "9b617126_d574ff14",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90888091_6090fb5f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1091982
      },
      "writtenOn": "2021-11-24T14:17:41Z",
      "side": 1,
      "message": "DiffOperations accepts two SHA1s (old/new commit IDs) as parameters. The cache loader creates new object readers each time and assumes that both commits are available in the repo.\n\nI discussed this today with Patrick. AFAIU you create a new patchset (in ReplaceOp) and want to get the diffs immediately of current vs. the newly created patchset. If you just do that, the new commit SHA1 will not be available for the diff caches\u0027 loaders. (We should add a test for it? I believe it\u0027d fail currently)\n\nTo solve this, you need to pass the RevWalk as Patrick mentioned (from ReplaceOp and other callers down the call path). In ApprovalInference, instead of doing\n        baseVsCurrent \u003d listModifiedFiles(project, patchSet);\n        ....\n\nWe could introduce another method in DiffOperations that accepts the SHA1-s and the Revwalk, and does the diff computation (only for file paths) without looking them up from the diff cache. This should not be expensive to compute.",
      "parentUuid": "76d46642_f047ed7e",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6555fd32_d8a240ae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1085183
      },
      "writtenOn": "2021-11-24T16:26:34Z",
      "side": 1,
      "message": "Ack, will do in a follow-up.",
      "parentUuid": "90888091_6090fb5f",
      "revId": "97c8e0e033221e70141fa4ef1fdfeddfb0cae075",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}