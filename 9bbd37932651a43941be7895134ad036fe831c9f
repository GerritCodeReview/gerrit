{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0bc7c5e7_8dd7d73c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-02-01T15:22:41Z",
      "side": 1,
      "message": "I toyed a bit with your proposal. \n\nI think this is better, but nevertheless it would be good to first document the entire scope of what you want to achieve. ",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca7336b2_bf376fa6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-02-16T10:23:14Z",
      "side": 1,
      "message": "I like this approach way better than the one based on reflection over in I62e3b346.\n\nFrom our conversation yesterday, I understood that the test is different from what a Gerrit server would do in that it uses the same class loader for both plugins.\n\nI double checked that JarPluginProvider will use a new class loader for each plugin.\n\nFrom my understanding and some reading [1] if PluginA defines FooEntity and PluginB wants to get that through your interface (and it\u0027s own compiled in definition) that would give a ClassCastException because each class is a triplet of (package, class name, class loader).\n\nSo you can basically only use core data types provided by Gerrit\u0027s class loader or the JVM\u0027s system class loader. Is that what you mean with \"susceptible to runtime type mismatches\" or did I look at it the wrong way?\n\n[1] https://medium.com/@swayamraina/class-loading-in-java-8167fe43d54f",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4547e821_11f3931f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-02-16T12:25:42Z",
      "side": 1,
      "message": "Your analysis is mostly correct (classloaders form a hierarchy, and you can cross class loaders if the cast destination is a parent clasloader), but the basic observation is that you either need a Gerrit core data type to connect both plugins, or you have to do a lot of complicated acrobatics with class loaders.\n\n\u003e Is that what you mean with \"susceptible to runtime type mismatches\" or did I look at it the wrong way?\n\nWhat I mean here: the interface uses \n```\nObject call(Object)\n```\n\nIt\u0027s up to the plugins to make sure they really mean the same types. You could have a plugin provider that wants to receive Change.Id argument. If you supply a boxed integer instead, the call at runtime will fail because somewhere a cast of Integer to Change.Id will be attempted, and it will fail.\n\nIf you specify to use Protocol Buffers, and cast, it will fail for the same reasons.\n\nIf you specify to use Protocol Buffers, but pass through serialization, mistakes won\u0027t fail with an exception, but instead all incoming requests will appear to be zeroed out, which is also not desirable. \n\nAn option that I didn\u0027t explore is to encode types in GUICE name annotations (analogous to C++ symbol mangling), eg. have the registration look like\n\n  class MyPluginImpl extends MyPluginApiProvider\u003cChange.Id, String\u003e \n...\n  bind(@Exports.named(\"my-plugin\")).to(MyPluginImpl.class)\n\nwhich uses some translation layer to translate this to\n\n  bind(@Exports.named(\"my-plugin-Change.Id-String\")).to(MyPluginImpl.class)\n\nand the same on the client side. Then, if there is a mismatch with in the types \nthe consuming plugin will fail to load, because it can\u0027t find the right provider. \n\nI don\u0027t enough about Java generics if this is possible, technically.",
      "parentUuid": "ca7336b2_bf376fa6",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96267ec1_4c48b4a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-02-16T16:34:31Z",
      "side": 1,
      "message": "\u003e the basic observation is that you either need a Gerrit core data type to connect both plugins, or you have to do a lot of complicated acrobatics with class loaders.\n\nRight, this I believe why the Qualcomm folks used reflection in their proposal. It prevents any class loader issues, because, well, it doesn\u0027t load the class :-)\n\n\u003e An option that I didn\u0027t explore is to encode types in GUICE name annotations\n\nThis could be a good way to add some syntactic sugar to the implementation. \n\nConcept wise, I think it won\u0027t solve the class cast problem because you can still have a mismatch between what that string says the API consumes and what MyPluginImpl actually consumes. That\u0027s because the actual type used in a place where at compile time a generic was used is not available from the class definition at runtime (i.e. if you have a MyApiImpl.class or an object, Java can\u0027t tell you if call returns a Change.Id or an Integer at runtime without actually looking at a return value).\n\nBut it\u0027s not the end of the world in any case IMO.",
      "parentUuid": "4547e821_11f3931f",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31b34bb3_816e3195",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1118861
      },
      "writtenOn": "2021-02-16T16:36:17Z",
      "side": 1,
      "message": "iam owner trying to fix but blocked",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b760665_24c22767",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-02-16T16:57:40Z",
      "side": 1,
      "message": "\u003e That\u0027s because the actual type used in a place where at compile time a generic was used is not available from the class definition at runtime (i.e. if you have a MyApiImpl.class or an object, Java \n\nyeah, so it needs some compile time construct to translate the declared types into a string. Maybe it\u0027s possible with an annotation processor?",
      "parentUuid": "96267ec1_4c48b4a7",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a733074_c1640641",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-02-17T08:50:43Z",
      "side": 1,
      "message": "good idea, an annotation processor would work AFAICS (at the cost of some extra complexity in the build).\n\nI was thinking about how we can get static typing and no classcastexceptions cheaper and think we can with TypeLiterals:\n\nDynamicMap (Function is a generalization of your MyApi):\n\n  public \u003cX, Y\u003e Function\u003cX, Y\u003e apiFromOtherPlugin(TypeLiteral\u003cX\u003e arg, TypeLiteral\u003cY\u003e ret) {\n    arg.toString() // This gives \"java.lang.String\" so the generic was preserved because of the subclassing.\n    ... load a plugin from the map that was bound to \"my-api.\" + arg.toString() + arg.toString() ...\n  }\n\n\nUsage:\n\n    Function\u003cString, Integer\u003e apiFromOtherPlugin \u003d dynamicMap.getOtherPluginsApi(new TypeLiteral\u003cString\u003e(){}, new TypeLiteral\u003cInteger\u003e(){});\n// Could be a list or an optional or whatever.\n\nIf we further tweak the binder, we we could even spare the intermediary string representation of types and just use type literals in the first place.",
      "parentUuid": "7b760665_24c22767",
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54ef5ee7_bcb6e004",
        "filename": "java/com/google/gerrit/extensions/registration/PluginProvidedApi.java",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-02-16T10:23:14Z",
      "side": 1,
      "message": "If this was: \"? extends MessageLite\" then you\u0027d force implementors to use protocol buffers",
      "range": {
        "startLine": 32,
        "startChar": 22,
        "endLine": 32,
        "endChar": 23
      },
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8ebda89_126a0f99",
        "filename": "java/com/google/gerrit/extensions/registration/PluginProvidedApi.java",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2021-02-16T12:25:42Z",
      "side": 1,
      "message": "Not everyone is as enthousiastic about PBs as we are :-)\n\nI think it\u0027s OK for plugins to talk in terms of native Gerrit types, eg. I \u003d Change.Id, O \u003d String",
      "parentUuid": "54ef5ee7_bcb6e004",
      "range": {
        "startLine": 32,
        "startChar": 22,
        "endLine": 32,
        "endChar": 23
      },
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a619abd1_aa3914f6",
        "filename": "java/com/google/gerrit/extensions/registration/PluginProvidedApi.java",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2021-02-16T16:34:31Z",
      "side": 1,
      "message": "\u003e Not everyone is as enthousiastic about PBs as we are :-)\n\nHa :-)",
      "parentUuid": "c8ebda89_126a0f99",
      "range": {
        "startLine": 32,
        "startChar": 22,
        "endLine": 32,
        "endChar": 23
      },
      "revId": "9bbd37932651a43941be7895134ad036fe831c9f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}