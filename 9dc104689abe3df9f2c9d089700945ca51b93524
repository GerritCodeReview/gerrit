{
  "pushCert": "certificate version 0.1\npusher Dave Borowitz \u003cdborowitz@google.com\u003e 1546624475 -0800\nnonce AJbGYzlsoic71DFE1D+o+xfjKU3Kxj9uB3HyFYc135QmeLYYWvwI/MjSNq2uhbOszQXngtY+Qj27\n\n0000000000000000000000000000000000000000 3ee5f606a76fd648de6139c0ab560450d700dbe0 refs/for/master%r\u003daliceks\n-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCgAzFiEEpPm/sOxWgSqG5grhX9fFmpoSiIwFAlwvndsVHGRib3Jvd2l0\nekBnb29nbGUuY29tAAoJEF/XxZqaEoiMgm8P/3Fsf9fNdBPfiJxTIpTI4/PngpWY\n0K0J1xNIBxHgmM1UTwrnwwAW8LN4Jq01GeolNv7otiBBHxZ1HAxmzZ9AVaqAl4oB\nQ4ilIpG/mmuOXLTGQLg1mdfhJEIzZDeYuwYm50/NgHZ+eJLmg1VbxojxNYjAT7VL\nKmirHdcxQRhjoGnbZ0oe2Nc5hrhZlz0MF40IH14dCGnI1HGiKDrR7QZPsVtKMrLr\nUSGO557gNDyBCBUCzvzpWU7QdJ9swVCHZMKYTRUWehMFwm2T2XSEfGlae73w/QuZ\nfxBhimcL20RnjtZvChDxj2GlsQhDJC8r6Mzo0GCoWCnAh2nUUTajtEz4Xi11Pxdb\nS6RurTIOySEsFTxx828OXHIDI/hfHDJfwy0XPrWeFmgASJXDwVch86p+Ei+HnWoD\nmquB1Q/X3+pcGbQf6x2O/2wj3zEAqdm37oYEvszH8lKmht9mWB2zeGpHy33Dihyf\nfgYRJ+7mXMnU3qQCKJoB50nszLTy3m0TKcy+PFgp3yoMLhoG1pVrV60fpsh3R6Eg\ngstQHVTul7anT2K/QlrH55XC1bwvJmsLKjjK4YsgbsyGE3oP0QdVz1rrUkUgqCWc\nr+/fk0ERVMfpeTBU6Qw/VMRqTG8YNxWohpG1BcJ6RmSFZ/zl2c9c7hRUoKVITRwQ\nH0KE1aZJzjRp7Js7\n\u003dDDGx\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "b2f5e0a1_eae074c5",
        "filename": "java/com/google/gerrit/index/query/InternalQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-07T16:43:00Z",
      "side": 1,
      "message": "Would it make sense to implement this as a (simple) Spliterator?",
      "range": {
        "startLine": 124,
        "startChar": 4,
        "endLine": 139,
        "endChar": 5
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e69f365f_d1b17cea",
        "filename": "java/com/google/gerrit/index/query/InternalQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-01-07T17:21:22Z",
      "side": 1,
      "message": "I\u0027m not sure what implementing a Spliterator would look like, but I came up with this recipe based on Guava\u0027s AbstractIterator:\n\n    return Streams.stream(\n            new AbstractIterator\u003cT\u003e() {\n              private QueryResult\u003cT\u003e curr \u003d qr;\n              private Iterator\u003cT\u003e it \u003d qr.entities().iterator();\n              private int start \u003d 0;\n\n              @Override\n              protected T computeNext() {\n                if (it.hasNext()) {\n                  return it.next();\n                }\n                if (curr.more()) {\n                  start +\u003d qr.entities().size();\n                  try {\n                    curr \u003d querySupplier.get().setStart(start).queryResults(predicate);\n                  } catch (OrmException e) {\n                    throw new OrmRuntimeException(e);\n                  }\n                  it \u003d curr.entities().iterator();\n                } else {\n                  return endOfData();\n                }\n                return computeNext();\n              }\n            })\n        .collect(toImmutableList());\n\n\nI don\u0027t think it\u0027s much of a win. If QueryResult were streaming and we didn\u0027t want to materialize it, the runtime savings might be worth it. But given that we have .size() and .more(), the iterative approach has equivalent performance.",
      "parentUuid": "b2f5e0a1_eae074c5",
      "range": {
        "startLine": 124,
        "startChar": 4,
        "endLine": 139,
        "endChar": 5
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05e8ab4b_36c7bd05",
        "filename": "java/com/google/gerrit/index/query/InternalQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-01-07T17:47:21Z",
      "side": 1,
      "message": "Purely for my edification, I wanted to learn how to implement a Spliterator. So here\u0027s another way of writing it:\n\n    return StreamSupport.stream(\n            new AbstractSpliterator\u003cT\u003e(Long.MAX_VALUE, IMMUTABLE | NONNULL | ORDERED) {\n              private QueryResult\u003cT\u003e curr \u003d qr;\n              private Iterator\u003cT\u003e it \u003d curr.entities().iterator();\n              private int start \u003d 0;\n\n              @Override\n              public boolean tryAdvance(Consumer\u003c? super T\u003e action) {\n                if (it.hasNext()) {\n                  action.accept(it.next());\n                  return true;\n                }\n                if (!curr.more()) {\n                  return false;\n                }\n                start +\u003d curr.entities().size();\n                try {\n                  curr \u003d querySupplier.get().setStart(start).queryResults(predicate);\n                } catch (OrmException e) {\n                  throw new OrmRuntimeException(e);\n                }\n                it \u003d curr.entities().iterator();\n                return tryAdvance(action);\n              }\n            },\n            false)\n        .collect(toImmutableList());\n\n\nProbably not coincidentally, it turns out AbstractSpliterator is quite similar to AbstractIterator, so my previous comments about readability/performance still apply.",
      "parentUuid": "e69f365f_d1b17cea",
      "range": {
        "startLine": 124,
        "startChar": 4,
        "endLine": 139,
        "endChar": 5
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3303cbe1_f04671de",
        "filename": "java/com/google/gerrit/index/query/InternalQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-08T14:51:33Z",
      "side": 1,
      "message": "What triggered me to write the comment:\n- I\u0027m not a fan of while loops, especially those with breaking conditions which are not easy to spot for all code paths. It\u0027s so easy to build an infinite loop for a special case and hence I typically try to avoid them. Most of the time, modern Java provides other constructs to do without such loops.\n- The code deliberately includes some optimizations (e.g. avoiding to copy the list if there is just the first bunch of results). It would be handy if we didn\u0027t even have to think about something like that.\n- The current code assembles all of the results into one list. Another construct like a Spliterator would allow us to switch to a Stream instead (e.g. as return type). Hence, we could benefit from some advantages/optimizations of Streams in the future if we switch more parts of the code to them.\n\nMy variant of a Spliterator would have been:\n\n  new AbstractSpliterator\u003cT\u003e(Long.MAX_VALUE, IMMUTABLE | NONNULL | ORDERED) {\n              private Spliterator\u003cT\u003e spliterator \u003d Spliterators.emptySpliterator();\n              private int nextStart \u003d 0;\n              private boolean more \u003d true;\n\n              @Override\n              public boolean tryAdvance(Consumer\u003c? super T\u003e action) {\n                boolean success \u003d spliterator.tryAdvance(action);\n                if (!success \u0026\u0026 more) {\n                  QueryResult\u003cT\u003e queryResult;\n                  try {\n                    queryResult \u003d querySupplier.get().setStart(nextStart).queryResults(predicate);\n                  } catch (OrmException e) {\n                    throw new OrmRuntimeException(e);\n                  }\n                  spliterator \u003d queryResult.entities().spliterator();\n                  more \u003d queryResult.more();\n                  nextStart +\u003d queryResult.entities().size();\n                  return spliterator.tryAdvance(action);\n                }\n                return success;\n              }\n            }\n\nI agree that overall, it\u0027s not much of a win. Since streams are evaluated lazily, it might even introduce other issues.",
      "parentUuid": "05e8ab4b_36c7bd05",
      "range": {
        "startLine": 124,
        "startChar": 4,
        "endLine": 139,
        "endChar": 5
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee0ea13f_779df764",
        "filename": "java/com/google/gerrit/server/query/change/InternalChangeQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-07T16:43:00Z",
      "side": 1,
      "message": "Please use the one from java.util.",
      "range": {
        "startLine": 25,
        "startChar": 7,
        "endLine": 25,
        "endChar": 38
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "480b6865_3ecaf963",
        "filename": "java/com/google/gerrit/server/query/change/InternalChangeQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-01-07T16:53:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ee0ea13f_779df764",
      "range": {
        "startLine": 25,
        "startChar": 7,
        "endLine": 25,
        "endChar": 38
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86b6eb6b_a3856304",
        "filename": "java/com/google/gerrit/server/query/change/InternalChangeQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-07T16:43:00Z",
      "side": 1,
      "message": "Should we also override this method in InternalAccountQuery? Up to now, InternalAccountQuery overrides all \u0027builder\u0027 methods. Interestingly, InternalGroupQuery does none of that. If possibly, I would at least like to keep classes itself consistent (e.g. InternalAccountQuery overrides all \u0027builder\u0027 methods or none).",
      "range": {
        "startLine": 95,
        "startChar": 2,
        "endLine": 96,
        "endChar": 49
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d50b702_dfcd19c9",
        "filename": "java/com/google/gerrit/server/query/change/InternalChangeQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-01-07T16:53:36Z",
      "side": 1,
      "message": "Yeah, I see the argument for consistency. I think the strategy until now has been to just override methods as necessary.\n\nIt would be nice if we had a better way so these don\u0027t need to be overridden manually. Perhaps something like:\n\n abstract class InternalQuery\u003cT, Q extends InternalQuery\u003cT\u003e\u003e {\n   protected Q self() {\n     return (Q) this; // Or make this method abstract if you don\u0027t like the cast.\n   }\n\n   public Q setStart(int n) {\n     queryProcessor.setStart(n);\n     return self();\n   }\n}\n\nI don\u0027t even know if this will compile, and the extra type parameter is ugly, but it might serve. Thoughts?",
      "parentUuid": "86b6eb6b_a3856304",
      "range": {
        "startLine": 95,
        "startChar": 2,
        "endLine": 96,
        "endChar": 49
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c1519d4_e7672fcc",
        "filename": "java/com/google/gerrit/server/query/change/InternalChangeQuery.java",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-08T14:51:33Z",
      "side": 1,
      "message": "Yes, recursive generics would be the typical way to solve this. Both the cast or the abstract self() method would be fine by me.",
      "parentUuid": "5d50b702_dfcd19c9",
      "range": {
        "startLine": 95,
        "startChar": 2,
        "endLine": 96,
        "endChar": 49
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2526d800_34718c34",
        "filename": "javatests/com/google/gerrit/acceptance/server/change/GetRelatedIT.java",
        "patchSetId": 2
      },
      "lineNbr": 606,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-01-07T16:43:00Z",
      "side": 1,
      "message": "How the value for this variable is obtained looks a bit complicated. Is there any way to assign its value in a clearer way (e.g. without reassigning its value in between)?",
      "range": {
        "startLine": 606,
        "startChar": 18,
        "endLine": 606,
        "endChar": 26
      },
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48dbf36e_c8a158bd",
        "filename": "javatests/com/google/gerrit/acceptance/server/change/GetRelatedIT.java",
        "patchSetId": 2
      },
      "lineNbr": 606,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-01-07T16:53:36Z",
      "side": 1,
      "message": "Changed to getPatchsetId(getLast(commitIds)). It\u0027s strictly slower, since it has to look up the SHA-1 in the index again, but the readability savings is probably worth it.",
      "parentUuid": "2526d800_34718c34",
      "range": {
        "startLine": 606,
        "startChar": 18,
        "endLine": 606,
        "endChar": 26
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "9dc104689abe3df9f2c9d089700945ca51b93524",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}