{
  "comments": [
    {
      "key": {
        "uuid": "df9d10d5_4d33397c",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 4
      },
      "lineNbr": 153,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-06-13T07:58:53Z",
      "side": 1,
      "message": "See the comment history on\n  https://gerrit-review.googlesource.com/#/c/57770/4/gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java\n\nI understand it like this. If a merge is triggered (no matter if by start(branch) or schedule(branch) we do (or should do) this:\n\n1. if there is no MergeEntry in the active map, create a new MergeEntry and add it (there is currently no merge for this branch running, but we are starting one now).\n\n2. if there is a MergeEntry in the active map, set e.needsMerge \u003d true on it (a merge is currently running for this branch but we can\u0027t be sure that our changes are already included in it, hence we set e.needsMerge to true to reschedule the merge from the finish method, if it is not needed it\u0027s not doing anything).\n\nThis is why I think the code here should be like this:\n\n  if (e \u003d\u003d null) {\n    e \u003d new MergeEntry(branch);\n    active.put(branch, e);\n    scheduleJob(e);\n  } else {\n    e.needMerge \u003d true;\n  }",
      "range": {
        "startLine": 148,
        "startChar": 4,
        "endLine": 153,
        "endChar": 5
      },
      "revId": "9ef8c09cd15dd09ced8d0a4fbf670e107589f3d3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df9d10d5_6d22750c",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 4
      },
      "lineNbr": 153,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-13T21:48:15Z",
      "side": 1,
      "message": "As for my previous comment in abandoned change you linked to:  i disagree.\n\nWe have two cases: interactive merge() is called and background jpbs are scheduled every 300 second per default. Currently they interfer with each other and both are failing. \n\nI think they shouldn\u0027t interfer. So if 300 second period was hit during interactive merge is underway: it sould wait for the next period to run.",
      "parentUuid": "df9d10d5_4d33397c",
      "range": {
        "startLine": 148,
        "startChar": 4,
        "endLine": 153,
        "endChar": 5
      },
      "revId": "9ef8c09cd15dd09ced8d0a4fbf670e107589f3d3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bfaa1cea_ace58371",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 4
      },
      "lineNbr": 153,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2014-06-14T07:43:13Z",
      "side": 1,
      "message": "I agree about doing the scheduling only if there is no merge scheduled or running yet, but not setting e.needMerge means we risk to loose a merge as I explained before. Can you point out what is wrong with my argumentation?\n\nWhat if 2 merges for the same branch are triggered concurrently by merge(branch) and schedule(branch), can the following happen?\n\n1. merge(branch)\n   -\u003e calls start(branch) which creates a MergeEntry\n      in the active map (e.needMerge is false)\n   -\u003e calls mergeImpl(branch) which does merge the branch\n\n   SECOND THREAD executes schedule(branch), see 2.\n\n   -\u003e calls finish(branch) which removes the MergeEntry\n      from the active map because e.needMerge is false,\n      but the merge scheduled by the second thread was\n      not done yet, and new also will not be done anymore,\n      only if e.needMerge would have been set in\n      schedule(branch), the job would be rescheduled\n\n2. schedule(branch)\n   -\u003e MergeEntry exists already in the active map and\n      nothing is done",
      "parentUuid": "df9d10d5_6d22750c",
      "range": {
        "startLine": 148,
        "startChar": 4,
        "endLine": 153,
        "endChar": 5
      },
      "revId": "9ef8c09cd15dd09ced8d0a4fbf670e107589f3d3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df9d10d5_4d1fb9bc",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 4
      },
      "lineNbr": 153,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-14T08:53:06Z",
      "side": 1,
      "message": "I don\u0027t understand the problem you are describing in:\n\n \"SECOND THREAD executes schedule(branch), see 2.\n   -\u003e calls finish(branch) which removes the MergeEntry\n      from the active map because e.needMerge is false,\n      but the merge scheduled by the second thread was\n      not done yet\"\n\nCan you explain what do you mean by that?\n\nWhy was the schedule(branch) triggered in the first place? Because one or multiple changes were submitted:\n\n  public void run() {\n    final HashSet\u003cBranch.NameKey\u003e pending \u003d new HashSet\u003c\u003e();\n    try {\n      final ReviewDb c \u003d schema.open();\n      try {\n        for (final Change change : c.changes().allSubmitted()) {\n          pending.add(change.getDest());\n        }\n      } finally {\n        c.close();\n      }\n    } catch (OrmException e) {\n      log.error(\"Cannot reload MergeQueue\", e);\n    }\n\n    for (final Branch.NameKey branch : pending) {\n      mergeQueue.schedule(branch);\n    }\n  }\n\nSo the events are:\n\n* FIRST THREAD is triggered: one or multiple changes were submitted\n* merge(branch) is called (e.needMerge is false)\n* SECOND (beackground) THREAD is triggered: executes schedule(branch), (e.needMerge is false), active contains MergEntry for the given branch.\n* background thread doesn\u0027t interfere with interactive submit processing: this time the background cycle is a nop-op. \n* FIRST THREAD merge the change, as when it would do it if there wouldn\u0027t be any collision with background thread: finish() is always a no op.\n* 300 second later (if default is not changed), new background job cycle is scheduled and this time (if no interactive scheduling is underway) it block active with e.needMerge \u003d True, and merge in two phases: in mergeImpl() + finish().\n\nSo if you think that interactive merging must be a two phase merge process: mergeImpl() + finish() then you may want to fix that in own change in the first place, and not claiming a probability of 1% that it hapens: interactive + background job coincidently are running at the same time.",
      "parentUuid": "bfaa1cea_ace58371",
      "range": {
        "startLine": 148,
        "startChar": 4,
        "endLine": 153,
        "endChar": 5
      },
      "revId": "9ef8c09cd15dd09ced8d0a4fbf670e107589f3d3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}