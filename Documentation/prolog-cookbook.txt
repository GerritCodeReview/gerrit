Gerrit Code Review - Prolog Submit Rules Cookbook
=================================================

By definition, a change in Gerrit is submittable when it gets at least one
highest vote in each voting category and has no lowest vote (aka veto vote) in
any category.  Typically, this means that a change needs 'Code-Review+2',
'Verified+1' and has neither 'Code-Review-2' nor 'Verified-1' to become
submittable.

While this rule is a good default, there are projects which need more
flexibility for defining when a change is submittable.  In Gerrit, it is
possible to use prolog based rules to provide project specific submit rules and
replace the default submit rules. Using prolog based rules, project owners can
define both a policy when a change becomes submittable and a set of criteria
that needs to be fulfilled for a change to become submittable.  The set of
'need' criteria is displayed on Gerrit UI for each change.

link:https://groups.google.com/d/topic/repo-discuss/wJxTGhlHZMM/discussion[This
discussion thread] explains why Prolog was chosen for the purpose of writing
project specific submit rules.
link:http://gerrit-documentation.googlecode.com/svn/ReleaseNotes/ReleaseNotes-2.2.2.html[Gerrit
2.2.2 ReleaseNotes] introduces Prolog support in Gerrit.

Prolog Language
---------------
This document is not a complete Prolog tutorial.
link:http://en.wikipedia.org/wiki/Prolog[This Wikipedia article] is a good
starting point for learning Prolog language. Here we will only explain some
elements of Prolog that are necessary to understand the provided examples.

Prolog in Gerrit
----------------
Gerrit uses own link:https://code.google.com/p/prolog-cafe/[fork] of the original
link:http://kaminari.istc.kobe-u.ac.jp/PrologCafe/[prolog-cafe] project. Gerrit
embeds prolog-cafe library and can interpret Prolog programs at runtime.

Interactive Prolog Cafe Shell
-----------------------------
For interactive testing and playing with Prolog, Gerrit provides the
link:pgm-prolog-shell.html[prolog-shell] program which opens an interactive
Prolog interpreter shell.  To use it one needs only to provide the (path to
the) 'gerrit.war' file:

----
java -jar gerrit.war prolog-shell
Gerrit Code Review 2.4.2-589-g8853117 - Interactive Prolog Shell
based on Prolog Cafe 1.2.5 (mantis)
         Copyright(C) 1997-2009 M.Banbara and N.Tamura
(type Ctrl-D or "halt." to exit, "['path/to/file.pl']." to load a file)
| ?-
----

There are two at least ways to consult (load) a prolog program. From the prolog
shell we can execute:

----
| ?- ['path/to/myfile.pl'].
----

If the 'myfile.pl' is in the current working directory then we can use an
easier syntax:

----
| ?- [myfile].
----

Using the `-s` option of the `prolog-shell` command will consult the given
prolog file immediately after shell startup:

----
$ java -jar gerrit.war prolog-shell -s path/to/myfile.pl
----

To demo an interactive Prolog session, assume we created following prolog
program in a file called 'mobile_phones.pl':

.mobile_phones.pl
----
smart(android).                           <1>
smart(iphone).                            <1>
provides_widgets(android).                <1>

cool(X) :- smart(X), provides_widgets(X). <2>
----

<1> are called 'facts' in prolog
<2> is called 'rule'

The `:-` represents an IF and the `,` is like a boolean AND. Therefore, this
rule can be read as 'X is cool IF X is smart AND X provides_widgets'.

Now, let's start the prolog shell and then consult the 'mobile_phones.pl' file
(assuming the file is in the current working directory):

----
$ java -jar gerrit.war prolog-shell

| ?- [mobile_phones].
{consulting .../mobile_phones.pl ...}
{.../mobile_phones.pl consulted 48 msec}
| ?- 
----

Let's list the known facts and rules to verify that it matches the facts and
rules from the 'mobile_phones.pl' file:

----
| ?- listing.
cool(A) :-
        smart(A),
        provides_widgets(A).
smart(android).
smart(iphone).
provides_widgets(android).

yes
| ?-
----

Now, let's make some queries and let prolog interpreter find solutions:

----
| ?- smart(iphone).   <1>

yes
| ?- smart(android).  <2>

yes
| ?- smart(X).        <3>

X = android ? ;       <4>

X = iphone ? ;        <5>

no
| -? cool(X).         <6>

X = android ? ;       <7>

no
| ?- cool(android).   <8>

yes
| ?- cool(iphone).    <9>

no
| -?
----

<1> this query asks prolog interpreter whether `smart(iphone)` is true. Prolog
will look at its database of facts and find that, indeed, it is true and print
`yes`.
<2> similarly like in the previous query the answer is `yes`
<3> with this query we ask prolog interpreter to find all values for the
variable `X` such that the `smart(X)` is true.
<4> this is the first solution of the currently evaluated query. We then type
`;` to tell the prolog interpreter to search for another solution.
<5> this is another solution of the currently evaluated query. Typing `;` again
we tell the prolog to search for another solution. This time prolog find no
other solution and prints `no`
<6> find all `cool` phones
<7> the first solution and the only solution
<8> instead of finding all `cool` phones we can also ask prolog if `android` is cool.
<9> according to our facts and rules the answer is `no` ;-)


The rules.pl file
-----------------
This section explains how to create and edit project specific submit rules. How
to actually write the submit rules is explained in the next section.

Project specific submit rules are stored in the `rules.pl` file in the
`refs/meta/config` branch of that project.  Therefore, we need to fetch and
checkout the `refs/meta/config` branch in order to create or edit the `rules.pl`
file:

----
$ git fetch origin refs/meta/config:config
$ git checkout config
... edit or create the rules.pl file
$ git add rules.pl
$ git commit -m "My submit rules"
$ git push origin HEAD:refs/meta/config
----

How to write submit rules
-------------------------
Whenever Gerrit needs to evaluate submit rules for a change `C` from project `P` it
will first initialize the embedded prolog interpreter by:

* consulting a set of facts about the change `C`
* consulting the `rules.pl` from the project `P`

Conceptually we can imagine that Gerrit adds a set of facts about the change
`C` on top of the `rules.pl` file and then consults it. The set of facts about
the change `C` will look like:

----
:- package gerrit.                                                  <1>

commit_author(user(1000000), 'Shawn Pearce', 'sop@gmail.com').      <2>
commit_committer(user(1000000), 'Shawn Pearce', 'sop@gmail.com').   <3>
commit_message('Add plugin support to Gerrit').                     <4>
...
----

<1> Gerrit will provide its facts in a package named `gerrit`. This means we
have to use qualified names when writing our code and referencing these facts.
For example: `gerrit:commit_author(ID, N, M)`
<2> user ID, full name and email address of the commit author
<3> user ID, full name and email address of the commit committer
<4> commit message

A complete set of facts which Gerrit provides about the is listed link:...[TODO].

By default, gerrit will search for `submit_rule/1` predicate in the `rules.pl`
files evaluate it `submit_rule(X)` and then inspect the value of `X` in order
to decide whether the change is submittable or not and also to find the set of
needed criteria for change to become submittable. This means that Gerrit has an
expectation on the format and value of the result of the `submit_rule` predicate
which is expected to be a `submit` term of the following format:

----
submit(label(label-name, status) [, label(label-name, status)]*)
----

where `label-name` is usually `'Code-Review'` or `'Verified'` but could also
be any other string (see examples below). The `status` is one of:

* `ok(user(ID))` or just `ok(_)` if user info is not important. This status is
   used to tell that this label/category has been met.
* `need(_)` is used to tell that this label/category is needed for change to
   become submittable
* `reject(user(ID))` or just `reject(_)`. This status is used to tell that label/category
   is blocking change submission
* `impossible` is used when the logic knows that the change cannot be submitted as-is.
   Administrative intervention is probably required. This is meant for cases
   where the logic requires members of "FooEng" to score "Code-Review +2" on a
   change, but nobody is in group "FooEng". It is to hint at permissions
   misconfigurations.

NOTE: For a change to be submittable all `label` terms contained in the returned
`submit` term must have `ok` status.

Here some examples of possible return values from the `submit_rule` predicate:

----
submit(label('Code-Review', ok(_)))                               <1>
submit(label('Code-Review', ok(_)), label('Verified', reject(_))) <2>
submit(label('Author-is-Shawn', need(_))                          <3>
----

The meaning of these return results is:
<1> label `'Code-Review'` is met. As there are no other labels in the
    return result, the change is submittable.
<2> label `'Verified'` is rejected. Change is not submittable.
<3> label `'Author-is-Shawn'` is needed for the change to become submittable.
    Note that this tell nothing about how this criteria will be met. It is up
    to the implementor of the `submit_rule` to return `label('Author-is-Shawn',
    ok(_))` when this criteria is met.  Most likely, it will have to match
    against `gerrit:commit_author` in order to check if this criteria is met.
    This will become clear through the examples below.

Of course, when implementing the `submit_rule` we will use the facts about the
change that are already provided by Gerrit. This will become clear when we at
the examples further below.

NOTE: the `submit_rule/1` means the `submit_rule` predicate with 1 parameter.
In general in prolog the syntax `name/N` is used to refer the the predicate
named `name` with `N` parameters.

Another aspect of the return result from the `submit_rule` predicate is that
Gerrit uses it to decide which set of labels to display on the change review
screen for voting. If the return result contains label `'ABC'` and if the label
`'ABC'` is one of the (global) voting categories then voting for the label
`'ABC'` will be displayed. Otherwise, it is not displayed. Note that we don't
need a (global) voting category for each label contained in the result of
`submit_rule` predicate.  For example, the decision whether `'Author-is-Shawn'`
label is met will probably not be made by explicit voting but, instead, by
inspecting the facts about the change.

Prolog vs Gerrit plugin for project specific submit rules
---------------------------------------------------------
Since version 2.5 Gerrit supports plugins and extension points. A plugin or an
extension point could also be used as another mean to provide custom submit
rules. One could ask for a guideline when to use Prolog based submit rules and
when to go for writing a new plugin. Writing a Prolog program is usually much
faster than writing a Gerrit plugin. Prolog based submit rules can be pushed
to a project by project owners while Gerrit plugins could only be installed by
Gerrit adminsitrators. In addition, Prolog based submit rules can be pushed
for review by pusing to `refs/for/refs/meta/config` branch.

On the other hand, prolog based submit rules get a limited ammount of facts about
the change exposed to them. Gerrit plugins get full access to Gerrit internals
and can potentially check more things than prolog based rules.

Examples
--------
The following examples should serve as a cookbook for developing own submit rules.
Some of them are too trivial to be used in production and their only purpose is
to proide step by step introduction and understanding.

Example 1: Make every change submittable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let's start with a most trivial example where we would make every change submittable
regardless of the votes it has:

.rules.pl
----
submit_rule(submit(label('Any-Label-Name', ok(_)))).
----

In this case we make no use of facts about the change. We don't need it as we are simply
making every change submittable. Note that, in this case, the Gerrit UI will not show
the UI for voting for the standard `'Code-Review'` and `'Verified'` categories as labels
with these names are not part of the return result. The `'Any-Label-Name'` could really
be any string.

Example 2: Every change submittalbe and voting in the standard labels possible
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is continuation of the previous example where, in addition, to making every change
submittable we want to enable voting in the standard `'Code-Review'` and
`'Verified'` categories.

.rules.pl
----
submit_rule(submit(label('Code-Review', ok(_)), label('Verified', ok(_)))).
----

Since for every change all label statuses are `'ok'` every change will be submittable.
Voting in the standard labels will be shown in the UI as the standard label names are
included in the return result.

Example 3: Nothing is submittable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how to make all changes non-submittable regardless of the
votes they have.

.rules.pl
----
submit_rule(submit(label('Any-Label-Name', reject(_)))).
----

Since for any change we return only one label with status `reject`, no change
will be submittable. The UI will, however, not indicate what is needed for a
change to become submittable as we return no labels with status `need`.

Example 4: Nothing is submittable but UI shows several 'Need ...' criteria
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this example no change is submittable but here we show how to present 'Need
<label>' information to the user in the UI.

.rules.pl
----
% In the UI this will show: Need Any-Label-Name
submit_rule(submit(label('Any-Label-Name', need(_)))).

% We could define more "need" labels by adding more rules
submit_rule(submit(label('Another-Label-Name', need(_)))).

% or by providing more than one need label in the same rule
submit_rule(submit(label('X-Label-Name', need(_)), label('Y-Label-Name', need(_)))).
----

In the UI this will show:
****
* Need Any-Label-Name
* Need Another-Label-Name
* Need X-Label-Name
* Need Y-Label-Name
****

From the example above we can see a few more things:

* comment in prolog starts with the `%` character
* there could be multiple `submit_rule` predicates. Since prolog, by default, tries to find
  all solutions for a query, the result will be union of all solutions.
  Therefore, we see all 4 `need` labels in the UI.

Example 5: Make change submittable if commit author is Shawn Pearce
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is the first example where we will use the prolog facts about change that are
automatically exposed by Gerrit. Our goal is to make any change submittable when the
commit author is named `'Shawn Pearce'`. In the very first step let's make sure Gerrit UI
shows 'Need Author-is-Shawn-Pearce' in the UI to clearly indicate to the user what is
needed for a change to become submittable:

.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
----

This will show:
****
* Need Author-is-Shawn-Pearce
****

in the UI but no change will be submittable yet. Let's add another rule:

.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
submit_rule(submit(label('Author-is-Shawn-Pearce', ok(_))))
   :- gerrit:commit_author(_, 'Shawn Pearce', _).
----

In the second rule we return `ok` status for the `'Author-is-Shawn-Pearce'` label if
there is a `commit_author` fact where the full name is `'Shawn Pearce'`. However, even if commit
author is `'Shawn Pearce'` Gerrit will still no make this change submittable. The reason
is that both `'submit_rule'` predicates are evaluated (as Prolog tries to find all solutions)
and since not all label statuses are `ok` the change is not submittable.

To fix the example we need to change the order of the rules and use the cut `!` operator.

.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', ok(_))))
   :- gerrit:commit_author(_, 'Shawn Pearce', _), !.
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
----

This will now work as expected. If the commti author is `'Shawn Pearce'` then
the first rule will return `submit(label('Author-is-Shawn-Pearce', ok(_)))`.
The cut operator in the first rule, if reached, will cause Prolog to stop
searching for further solutions.  If, however, commit author is not `'Shawn
Pearce'` then first `submit_rule` will not bring a solution and Prolog will
continue with the second `submit_rule` which will return the
`submit(label('Author-is-Shawn-Pearce', need(_)))` and Gerrit will properly
show this information in the UI.

Instead of checking by full name we could also check by the email address:

.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', ok(_))))
   :- gerrit:commit_author(_, _, 'sop@google.com'), !.
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
----

or by user id (assuming it is 1000000):
.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', ok(_))))
   :- gerrit:commit_author(user(1000000), _, _), !.
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
----

or by a combination of these 3 attributes:
.rules.pl
----
submit_rule(submit(label('Author-is-Shawn-Pearce', ok(_))))
   :- gerrit:commit_author(_, 'Shawn Pearce', 'sop@google.com'), !.
submit_rule(submit(label('Author-is-Shawn-Pearce', need(_)))).
----

Example 6: Make change submittable if commit message starts with "Trivial fix"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Besides show how to make use of the commit message text the purpose of this example
is also to show how to match only a part of a string symbol. Similarly like
commit author the commit message is provided as a string symbol which is an atom
in Prolog terms. When working with an atom we could only match against the whole
value. To match only beginning of a string symbol we need to first convert it
to a list of characters and then perform matching.

.rules.pl
----
submit_rule(submit(label('Commit-Message-starts-with-Trivial-Fix', ok(_))))
  :- gerrit:commit_message(M), name(M, L), starts_with(L, "Trivial Fix"), !.
submit_rule(submit(label('Commit-Message-starts-with-Trivial-Fix', need(_)))).

starts_with(L, []).
starts_with([H|T1], [H|T2]) :- starts_with(T1, T2).
----

The `name/2` embedded predicate is used to convert a string symbol into a list
of characters.  Using of double quotes for `"Trivial Fix"` is a shortcut for
creating a list of these characters. If we would have used single quotes then
we would actually create a string symbol atom (which is not what we want in
this case).

The `starts_with` predicate is self explaining. In the first rule we tell
prolog that any list starts with an empty list. When the second list is
non-empty then the first list starts with second list if they have the same
first element and if the tail of the first list starts with the tail of the
second list.

The necessity to use the cut operator was already explained in the previous
example.

Example 7: Make change submittable only if `Code-Review+2` is not given by commit author
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Testing rules.pl in a local environment
---------------------------------------

abc

List of all facts Gerrit exposes about a change
-----------------------------------------------


abc
