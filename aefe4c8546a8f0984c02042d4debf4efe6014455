{
  "comments": [
    {
      "key": {
        "uuid": "3f08ecaa_6810636e",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/GitHubLogin.java",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "Are you forced to do that redirect passing the OAuth access_token in the URL? One of the strengths of OAuth is that specifically the token can be kept \"private\".",
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f876029_a9179d5c",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/GitHubOAuthConfig.java",
        "patchSetId": 1
      },
      "lineNbr": 59,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2014-05-29T01:57:44Z",
      "side": 1,
      "message": "is it possible to put these in the secure config?",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 59,
        "endChar": 78
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f876029_c924d1d0",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/HttpGitHubOAuthModule.java",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2014-05-29T01:57:44Z",
      "side": 1,
      "message": "This and the other added files have older dates in the copyright header.  Is this intentional since the files are copied from the github plugin?",
      "range": {
        "startLine": 1,
        "startChar": 17,
        "endLine": 1,
        "endChar": 21
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f82641a_ea2187bd",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2014-05-29T01:57:44Z",
      "side": 1,
      "message": "Missing copyright/license header.",
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_c7005e25",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "Use Guava\u0027s Objects.hashCode? (or Java7\u0027s Objects.hash)",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 75,
        "endChar": 20
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_e7fb62e2",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "Use Guava\u0027s Objects.equal? (or Java 7\u0027s Objects.equals)",
      "range": {
        "startLine": 84,
        "startChar": 0,
        "endLine": 90,
        "endChar": 18
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f08ecaa_a8f53bed",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 98,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "Couldn\u0027t you inject an HttpClint instance directly then?",
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f08ecaa_88fa77db",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "That second (empty string) argument (and the corresponding %s in the format string) is useless.",
      "range": {
        "startLine": 108,
        "startChar": 8,
        "endLine": 108,
        "endChar": 33
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_a7f56aed",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "If this is what\u0027s used on gerrithub.io, that doesn\u0027t look secure: the me() is the same for me between different browsers.\n\nYou\u0027ll want to generate a cryptographically-secure random and store it in a cookie.\n\nSee http://tools.ietf.org/html/rfc6819#section-3.6 for the related threat.\n\nIt\u0027s not a serious threat in the context of Gerrit I believe (allows an attacker to log you in with his own account; the main risk is when the victim will later enter credit card number or link account to Paypal, etc.), which is why I disclose it here publicly.",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_6710926e",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2014-05-29T14:04:36Z",
      "side": 1,
      "message": "Thanks Thomas for this security feedback.\nCan you explain exactly the scenario and how a potential attacker could use it to steal personal information or impersonate yourself on Gerrit  ?\n\nThe pattern for OAuth implementation is taken directly from GitHub documentation, so if that pattern is flowed potentially many other applications integrated with GitHub would have the same problem :-(\n\nIt is important then to clarify what is the problem / risk and find an effective workaround.",
      "parentUuid": "1f0de8bb_a7f56aed",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_270a9a40",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T16:01:44Z",
      "side": 1,
      "message": "As an attacker, I intercept the URL GitHub redirects to (the one at gerrithub containing the code) without dereferencing it (something like https://review.gerrithub.io/oauth?code\u003df500ac0f787d222fc7ad\u0026state\u003d626120578%2C%2Flogin) and lead you to follow it; and bam, you\u0027re logged in to gerrithub as \"Thomas Broyer\".\n\nAs I said, this is no big deal for Gerrit. All I could do (unless I missed something important) is trick you to give me your email address or your SSH public key.\n\nI could possibly badly interact with other plugins that ask you for more information though (e.g. enter your payment info to get *me* a \"premium account\", and possibly give *me* your payment info to retrive later from *my* account where you entered them)",
      "parentUuid": "1f0de8bb_6710926e",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_07079636",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2014-05-29T16:11:22Z",
      "side": 1,
      "message": "mmm ... intercepting a URL redirect over HTTPS ? and modifying it ?\n\nIt would be possibly ONLY if you\u0027ve stolen the SSL Server private key ... and if you did it ... you definitely have MUCH BIGGER PROBLEMS right ?\n\nWith security, the overall security of a system is as strong as the weakest link: if you someone has stolen the SSL Server private key, the weakest link is not really the URL redirect :-)\n\nDoes it make sense ?",
      "parentUuid": "1f0de8bb_270a9a40",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_c72bbea3",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T18:01:24Z",
      "side": 1,
      "message": "\u003e mmm ... intercepting a URL redirect over HTTPS ? and modifying it ?\n\u003e It would be possibly ONLY if you\u0027ve stolen the SSL Server private key ... and if you did it ... you definitely have MUCH BIGGER PROBLEMS right ?\n\nNo, I just meant that I start the login process (loginPhase1, login to GitHub, authorize Gerrit) but don\u0027t let the browser load the loginPhase2 at Gerrit (that\u0027s what I meant by \"intercept the URL\"). Instead of loading that URL in *my* browser, I trick you into loading it in *your* browser. Because Gerrit doesn\u0027t check that it generated the \"state\" parameter for *my* browser, then *you* are authenticated with *my* account (session fixation attack). If you\u0027re not careful, you could then enter your personal information on my Gerrit profile, and I can then retrieve it.\n\nIt\u0027s not about the attacker being logged-in with the victim\u0027s account, but the reverse: the victim being logged in with the attacker\u0027s account.\n\nIf there\u0027s another vulnerability in Gerrit in which an attacker could inject some code, then there\u0027s a possibility that the injected code could intercept the redirect from GitHub and send it to the attacker. In that case, the attacker could then login with the victim\u0027s account, and that\u0027s much worse, but it supposes another vulnerability in Gerrit.",
      "parentUuid": "1f0de8bb_07079636",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_e74da285",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2014-05-29T20:56:48Z",
      "side": 1,
      "message": "I see, so you want to prevent an attacker to get a SSO URL and send it through phishing to induce other users to login to Gerrit using someone else identity.\n\nThe SSO URL however would need to be valid for multiple requests as you may want to spread your phishing e-mails to a very large number of people to have the probability of someone clicking on it. However the GitHub SSO is valid for only one shot, so only one can be potentially attacked.\n\nLet\u0027s see then what you could do with this \"attack\": you have someone else wondering why is logged in to Gerrit with someone else account (the username is displayed on the top-right together with the Gravatar) and then, regardless of the strange situation, push some sensitive information to a Gerrit repo (personal account data ? Credit Card ? other ?)\n\nThe other possibility you envision is that another vulnerability (which one ? are you aware of any ?) would allow someone else to inject code into Gerrit that could then land into someone else Web-Browser ... but this is a different story :-) Nothing to do with this problem.\n\nLet\u0027s go to the solution you proposed: an encrypted NONCE to use as state parameter and as browser cookie. If I am the attacker I definitely know how to read that cookie and inject into someone else browser. The fact of the cookie being encrypted does not mean it cannot be copied. If I can inject my own cookie (i.e. GerritAccount) into someone else browser I can already today transfer my Gerrit account identity to somebody else. The vulnerability that you envision then already exist today and has nothing to do with this change :-)\n\nI recognise the problem you presented, but I am unsure of its real risk and opportunity of anyone to exploit it successfully and provide any profit or benefit. What do you think ?\n\nAny proposal on really solving the issue (including the GerritAccount cookie transfer to another browser) would be appreciated.",
      "parentUuid": "1f0de8bb_c72bbea3",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f08ecaa_283cabdb",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T22:28:41Z",
      "side": 1,
      "message": "\u003e The SSO URL however would need to be valid for multiple requests as you may want to spread your phishing e-mails to a very large number of people to have the probability of someone clicking on it. However the GitHub SSO is valid for only one shot, so only one can be potentially attacked.\n\nSuffice it to be the \"right one\" (i.e. targetted attack; remember this is how the Syrian Electronic Army hacked the RSA Conference website late last month –http://krebsonsecurity.com/2014/05/complexity-as-the-enemy-of-security/–, as in many other cases).\n\n\u003e Let\u0027s see then what you could do with this \"attack\": you have someone else wondering why is logged in to Gerrit with someone else account (the username is displayed on the top-right together with the Gravatar)\n\nIt\u0027s easy to set the same name and avatar in your fake/attacker GitHub account as the victim you\u0027re targetting.\n\n\u003e and then, regardless of the strange situation, push some sensitive information to a Gerrit repo (personal account data ? Credit Card ? other ?)\n\nAbsolutely, this is why it\u0027s OK I believe to discuss this publicly: there\u0027s not much info you can get from a victim.\n\nHowever, the day you add \"premium\" accounts in GerritHub with, say, private repositories, and you allow paying or link a PayPal account with the same auth as you use for GerritHub (assuming the implementation in this patchset), then it will become a real, big issue.\n\n\u003e The other possibility you envision is that another vulnerability (which one ? are you aware of any ?)\n\nNo (I haven\u0027t search for one, I suspect –and hope– Google did it).\n\n\u003e would allow someone else to inject code into Gerrit that could then land into someone else Web-Browser ... but this is a different story :-) Nothing to do with this problem.\n\nIf that allows an attacker to log with the victim\u0027s account by taking advantage of the current issue we\u0027re discussing, then yes, it has to do with it ;-)\n\n\u003e Let\u0027s go to the solution you proposed: an encrypted NONCE to use as state parameter and as browser cookie. If I am the attacker I definitely know how to read that cookie and inject into someone else browser. The fact of the cookie being encrypted does not mean it cannot be copied. If I can inject my own cookie (i.e. GerritAccount) into someone else browser I can already today transfer my Gerrit account identity to somebody else. The vulnerability that you envision then already exist today and has nothing to do with this change :-)\n\nExcept AFAIK you can\u0027t \"inject\" a cookie into someone else\u0027s browser unless the targeted domain is vulnerable to XSS (in which case, yes, injecting the state cookie is the least of your concern ;-) )\nCookies are bound to domains, and can only be manipulated by those domains.\n\nBTW, it\u0027s not about an \"encrypted cookie\", just a random value (truly random though, so it cannot be guessed, aka crypto-secure; in other words, java.security.SecureRandom, not just java.util.Random).\n\nSo, really, just generating such a random value and setting it in a cookie that you later compare with the received state value has real benefits. See https://developers.google.com/accounts/docs/OAuth2Login#createxsrftoken for an OAuth guide by people who are really knowledgeable about security ;-)\n\nThe use of cookie is what the \"OAuth 2.0 Threat Model\" RFC linked in my first comment above suggests:\n\n   This parameter should bind to the authenticated state in a user agent\n   and, as per the core OAuth spec, the user agent must be capable of\n   keeping it in a location accessible only by the client and user\n   agent, i.e., protected by same-origin policy.\n\nSee also http://tools.ietf.org/html/rfc6819#section-5.3.5\n\nIdeally, you\u0027d save the random value on the server (in the \"web_sessions\" cache?) and only set the cache key in the cookie (so forging the cookie would be really hard!)\n\nI don\u0027t know how secure it would be (I\u0027m not an expert), but you could also possibly compute a hash of the random + a fingerprint of the browser (just using the User-Agent and Accept-* headers is enough to uniquely identify a browser! [1]) and put that hash in the cookie; then in loginPhase2 recompute the hash and compare it with the cookie value. The browser fingerprinting would make it useless to inject the cookie into someone else\u0027s browser; and that approach would be stateless.\n\n[1] Disable JavaScript and then visit https://panopticlick.eff.org/",
      "parentUuid": "1f0de8bb_e74da285",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_273cdadb",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2014-05-29T23:01:44Z",
      "side": 1,
      "message": "Under the hypothesis (not verified as we don\u0027t know if Gerrit is vulnerable to XSS) that an attacker can inject its JS into a Gerrit page, he can then definitely return a cookie in an HTTP response and bind it to the Gerrit domain. In this case it could potentially impersonate another user via setting the GerritAccount.\n\nWith regards to the state parameter and the RFC-6819#section-5.3.5, I am with you that it is definitely better to use it to protect against malicious use. However we should look at something that ties to the specific client that made the request and, unfortunately, as the client is not yet authenticated there is not yet any user agent session active or defined. As there is no session active there is nothing to save on the Gerrit web_sessions cache either.\n\nComputing the User Agent + Accept-* header is definitely not enough, as they are not specific to an individual browser but rather a \"class\" of browsers. Potentially using the client IP address would help, assuming that you\u0027re not under a reverse-proxy masking them.\n\nEven setting up a Browser cookie tied to the domain and JavaScript-safe, wouldn\u0027t help us out because of the potential threat mentioned at the beginning (under the hypothesis that Gerrit is or could be vulnerable to XSS).\n\nI see your point but it is unclear to me how to really make it more secure in a truly reliable way. Possibly the only option is really the hashing of Client IP + User-Agent + Headers altogether, with the disclaimer in the Gerrit doc that if reverse proxy is not properly configured to propagate the client IP, it could then be vulnerable when used in conjunction with OAuth / GitHub.\n\nWhat do you think ?\n\nP.S. Again unless you\u0027re talking about PayPal payment of GerritHub accounts (which do not exist and would require anyway to re-authenticate again for security reasons), it is unclear to me the real benefit of anyone trying to exploit that type of potential XSS vulnerability. I would avoid to put up-front complexity for a non-real threat, unless there is a simple solution to it.",
      "parentUuid": "3f08ecaa_283cabdb",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_0739d6eb",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T23:38:06Z",
      "side": 1,
      "message": "\u003e With regards to the state parameter and the RFC-6819#section-5.3.5, I am with you that it is definitely better to use it to protect against malicious use. However we should look at something that ties to the specific client that made the request and, unfortunately, as the client is not yet authenticated there is not yet any user agent session active or defined. As there is no session active there is nothing to save on the Gerrit web_sessions cache either.\n\nYes, I was thinking about maybe creating such a session (I see WebSession has an isSignedIn, I thought maybe there could be a WebSession for a \"no yet authenticated\" user; it doesn\u0027t seem possible though with the current implementation). Still, something similar with another cache could be used.\n\n\u003e Computing the User Agent + Accept-* header is definitely not enough, as they are not specific to an individual browser but rather a \"class\" of browsers.\n\nHave you tried https://panopticlick.eff.org with JS disabled?\n\nIn my Chrome browser I get “Your browser fingerprint appears to be unique among the 4,160,410 tested so far.”, in Firefox “Within our dataset of several million visitors, only one in 1,386,804 browsers have the same fingerprint as yours.” And a few months ago I tried it with a coworker using the same browsers as me and they didn\u0027t tell us we had the same fingerprint.\n\nSo it\u0027s not enough (and browser vendors try to make it harder to fingerprint a browser that way in each version, so it\u0027s not future-proof) but is better than nothing.\n\n\u003e Even setting up a Browser cookie tied to the domain and JavaScript-safe, wouldn\u0027t help us out because of the potential threat mentioned at the beginning (under the hypothesis that Gerrit is or could be vulnerable to XSS).\n\nAgain, a limited security is still better than none at all.\n\n\u003e I see your point but it is unclear to me how to really make it more secure in a truly reliable way. Possibly the only option is really the hashing of Client IP + User-Agent + Headers altogether, with the disclaimer in the Gerrit doc that if reverse proxy is not properly configured to propagate the client IP, it could then be vulnerable when used in conjunction with OAuth / GitHub.\n\u003e What do you think ?\n\nIMO, we should try the simplest thing that would make it \"more secure\" (i.e. store the random as-is in a cookie, or possibly the hash(User-Agent+Accept+random)). It can always be improved later, but that would still be better than nothing.\n\nXSS is hard to defend against, and Gerrit is not known to be vulnerable to it, so if we can at least defend against CSRF, that\u0027s still better than doing nothing, even if the risk is low (see below).\n\n\u003e P.S. Again unless you\u0027re talking about PayPal payment of GerritHub accounts (which do not exist and would require anyway to re-authenticate again for security reasons), it is unclear to me the real benefit of anyone trying to exploit that type of potential XSS vulnerability. I would avoid to put up-front complexity for a non-real threat, unless there is a simple solution to it.\n\nI 100% agree (except I think you meant CSRF rather than XSS here), this is why I advocate for just using a simple cookie (not even the \"hash with fingerprint\" one!): it\u0027s really simple *and* is useful.",
      "parentUuid": "1f0de8bb_273cdadb",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 109,
        "endChar": 66
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f0de8bb_87fa66db",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/auth/github/OAuthProtocol.java",
        "patchSetId": 1
      },
      "lineNbr": 130,
      "author": {
        "id": 1010404
      },
      "writtenOn": "2014-05-29T12:57:11Z",
      "side": 1,
      "message": "This is where you\u0027re supposed to validate the random part of the \"state\" to mitigate CSRF, before you make the request to GitHub to exchange the code for a token.",
      "range": {
        "startLine": 129,
        "startChar": 0,
        "endLine": 130,
        "endChar": 56
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f82641a_0a4edb81",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/config/AuthConfig.java",
        "patchSetId": 1
      },
      "lineNbr": 201,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2014-05-29T01:57:44Z",
      "side": 1,
      "message": "nit: It\u0027s",
      "range": {
        "startLine": 201,
        "startChar": 11,
        "endLine": 201,
        "endChar": 14
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f82641a_2a539f26",
        "filename": "lib/BUCK",
        "patchSetId": 1
      },
      "lineNbr": 351,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2014-05-29T01:57:44Z",
      "side": 1,
      "message": "nit: trailing whitespace",
      "range": {
        "startLine": 351,
        "startChar": 9,
        "endLine": 351,
        "endChar": 10
      },
      "revId": "aefe4c8546a8f0984c02042d4debf4efe6014455",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}