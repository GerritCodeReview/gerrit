{
  "comments": [
    {
      "key": {
        "uuid": "SukgzP-8",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/changedetail/ChangeDetailFactory.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Which leads me to think these should be called changeDependencies instead of crossProjectDependencies since these should work for changes in the same project?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuEooE5U",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/changedetail/ChangeDetailFactory.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Well, they don\u0027t actually.  There is a distinct difference.  All same-project dependencies point directly to commits.  All cross-project dependencies point to changes.  The reason for this is two-fold.\n\n* I can\u0027t point directly to a commit in a different project because that makes circular dependencies impossible which is really important and I probably wouldn\u0027t be doing the change otherwise (this change supports circular dependencies, btw)\n* I determine whether or not the dependency should point to the most recent commit based on whether or not it is in the same project (that\u0027s the code here).  There\u0027s no way I can store metadata about whether this should point to a commit or a change in the PatchSetAncestor\u0027s table without changing the schema.",
      "parentUuid": "SukgzP-8",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuQkiKbM",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "This might be a lot easier to read (for me at least) if you just did branches \u003d newBranches;",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuGol17k",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done.  I\u0027m a sucker for `final`, haha.",
      "parentUuid": "SuQkiKbM",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Suig6i9E",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Could you abstract dependency parsing and determination details to a separate class so that it could be easily altered/enhanced.  In other words, it would be nice to allow users to specify dependencies in other ways then via the commit message at some point.",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvEYoEpU",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done (I think...)",
      "parentUuid": "Suig6i9E",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Sushl7-g",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "So what does this logic do in case of reverse dependencies?  How does it handle failures?  If a depends on b and b depends on a, what happens when a merges, but b fails?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuOpDB1Y",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "\u003cfacepalm\u003e...ugh...I had only considered a merge failing for dependency reasons (which this handles nicely).  I hadn\u0027t considered other issues?  Can I just call the verifyMergeability method above before continuing to attempt an actual merge (and thus triggering the merge in the other project)?  Is there any way to do that with locking so that nothing can nullify the result of that method call?",
      "parentUuid": "Sushl7-g",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuEozM-8",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T18:50:17Z",
      "side": 1,
      "message": "There are ways, but none are easy. :(  I will point you to some resources to help you better understand the problems involved.\n\nHere is the long thread started by Mohan over a year ago about solving a similar problem, it should help outline some of the problems anticipated back then:  https://groups.google.com/forum/?fromgroups\u003d#!searchin/repo-discuss/mohan/repo-discuss/dZg-Tie8__A/deK7EIxTaDQJ\n\nHere are Mohan\u0027s abandoned attempts at in memory Gerrit locking: https://gerrit-review.googlesource.com/#/q/status:open+project:gerrit+branch:master+topic:cross-repo-dependencies,n,z I think there were still unsolved issues with this proposal.  Of course, such a solution would not likely be useful in a clustered Gerrit environment such as what gerrit-review runs as currently.\n\n\nHere is Shawn\u0027s idea last fall to support multi-repo transactions in jgit that unfortunately has either still had stale locking issues, or races:\nhttps://groups.google.com/forum/?fromgroups\u003d#!searchin/repo-discuss/mohan/repo-discuss/mI1l5-fesI8/z-Ez0lYBoUgJ\n\nHowever, if you still want to solve this, I proposed solutions to the git mailing list about creating \"recoverable\" locks/transactions that seemed to only have issues on some (likely non posix) filesystems.  The discussion started around here: http://marc.info/?l\u003dgit\u0026m\u003d135664993801178\u0026w\u003d2 but by first proposal was flawed, I think the valuable proposal which might work (no known flaws with posix FS) starts around here: http://marc.info/?l\u003dgit\u0026m\u003d135698411219549\u0026w\u003d2\n\nThese could be used to build up a solutions similar to Shawn\u0027s proposal for a clustered shared backend.  But that is not what you guys have at google anyway (and you can likely do locking more easily with your system).  So, I think you would need to abstract the locking piece in jgit anyway and then it is just a matter of implementing different backend systems and perhaps having a way to disable the feature if the backend does not support a safe locking mechanism?\n\nSo, currently there are only 2 real backends in the wild that you need to care about your clustered google system (ask Shawns how to solve this, the system already \"locks\" refs anyway using the DB for multi-master), and a single master system.   Since shared backend with multi master is not in that list, you can ignore both Shawn\u0027s (except for how he would integrate with jgit) and my locking proposals.   If you have a pluggable locking mechanism, the single master one could start by using in memory locking with the risk of colliding with direct git updates behind Gerrit\u0027s back (which is likely OK until someone cares to solve the problem better). You could even force it to overwrite any updates behind Gerrit\u0027s back if you wanted so that Gerrit will still be consistent.",
      "parentUuid": "SuOpDB1Y",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvAYiGrM",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T20:56:15Z",
      "side": 1,
      "message": "Arg...when we first discussed this, the idea was to create something that didn\u0027t need locking as a first step...so now it looks like that\u0027s changed.\n\nIs there any way around this without abandoning circular dependencies?  Perhaps we could not enforce dependencies (not sure how confusing that would be) and only use this metadata to update a superproject atomically.",
      "parentUuid": "SuEozM-8",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvMY.Qss",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T21:14:42Z",
      "side": 1,
      "message": "I think I always thought circular required locking, I suggested starting without circular, but it didn\u0027t do you much good because you needed it. :(\n\n\u003e Is there any way around this without abandoning circular dependencies? Perhaps we could not enforce dependencies (not sure how confusing that would be) and only use this metadata to update a superproject atomically.\n\nYou could enhance the submodule support to update only when it sees a header in the commit of a subproject?  It wouldn\u0027t be truly atomic, but you could likely prevent merge failures from a submodule update (except for when the submodule gets removed).",
      "parentUuid": "SvAYiGrM",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuCo6f9E",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T21:33:25Z",
      "side": 1,
      "message": "\u003e I think I always thought circular required locking, I suggested starting without circular, but it didn\u0027t do you much good because you needed it. :(\n\nYea...I screwed up...\n\n\u003e You could enhance the submodule support to update only when it sees a header in the commit of a subproject\n\nSo how do you feel about this?  It would mean leaving dependencies that are unenforced when merging and expecting users to understand that.",
      "parentUuid": "SvMY.Qss",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvOZDPlY",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T21:55:32Z",
      "side": 1,
      "message": "\u003e \u003e You could enhance the submodule support to update only when it sees a header in the commit of a subproject\n\n\u003e So how do you feel about this? It would mean leaving dependencies that are unenforced when merging and expecting users to understand that.\n\nI don\u0027t quite follow.  This approach would not really be a dependency system anymore, it would effectively just be a system to cause a parent project to update the super project on child merges, which we already have.  Except that now you need a project flag to tell a project to not update unless it sees your new header in the child.",
      "parentUuid": "SuCo6f9E",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvIZISnQ",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-29T21:35:35Z",
      "side": 1,
      "message": "I was thinking this would still display things as Dependencies when viewing a change and you would still have commit footers to specifiy the dependencies.\n\nWhat do you mean by \"project flag\" and \"header\"?",
      "parentUuid": "SvOZDPlY",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SzPb2QBc",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-29T22:21:28Z",
      "side": 1,
      "message": "\u003e I was thinking this would still display things as Dependencies when viewing a change and you would still have commit footers to specifiy the dependencies.\n\nBut that wouldn\u0027t really work because what if someone specifies a dependency to a change which isn\u0027t in a project with the current change as a submodule?\n\n\u003e What do you mean by \"project flag\" and \"header\"?\n\nMy suggestion was to use this framework:\nhttps://gerrit-review.googlesource.com/Documentation/user-submodules.html\n\nBut that framework always updates the parent when the child updates.  So I figured that you could have a project setting for the parent that would tell it not to do that.  Then you would have a footer (sorry I said header) that would tell it to the subscription to temporarily work again (just for this one change).\n\n\nBut to be honest, I don\u0027t think I understand how you would even intend to use the submodules to define circular dependencies?",
      "parentUuid": "SvIZISnQ",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "S04-xlSM",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-04-02T18:15:40Z",
      "side": 1,
      "message": "\u003e But that wouldn\u0027t really work because what if someone specifies a dependency to a change which isn\u0027t in a project with the current change as a submodule?\n\nRight, so the superproject would only update respecting dependencies in projects it references.\n\n\u003e My suggestion was to use this framework\n\nOK, I got that you were suggesting using the submodules feature, I just wasn\u0027t familiar with the vocabulary.  My original plan was that after writing this change, I would modify that feature to respect the dependencies...that is, it would hold off on updating entries in .gitmodules until the necessary dependencies were merged.\n\n\u003e But to be honest, I don\u0027t think I understand how you would even intend to use the submodules to define circular dependencies?\n\nWhat would be wrong with what I described?  Gerrit would watch the commits that come in and holds off on updating superprojects until the necessary dependencies are merged.",
      "parentUuid": "SzPb2QBc",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "S57sYR4M",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-04-02T23:07:55Z",
      "side": 1,
      "message": "This feels weird to me, you aren\u0027t really defining a dependency system, just a shorthand way to hold off in updating parent projects when they are subscribed.  The reason I say that is because a change could get merged into a submodule and someone could manually update the parent superproject before the dependeny change is merged into the other submodule.  But also what if one change merges, but the other dependeny change fails its merge?  The fact that the superproject didn\u0027t update doesn\u0027t really help, you still have a broken state which may now require a rewind to fix.  Lastly, in the case when one change is merged but not the dependency, it could endup freezing the superproject in weird ways preventing further updates to it until the dependency is fixed.\n\nOverall, this sounds pretty hard to get right and have a decent user experience.  It would seem that simply updating superprojects manually would be easier for the user to understand.",
      "parentUuid": "S04-xlSM",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "S8DJXEAc",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-04-03T19:28:03Z",
      "side": 1,
      "message": "\u003e just a shorthand way to hold off in updating parent projects when they are subscribed.\n\nThis is an accurate diagnosis.\n\n\u003e  The fact that the superproject didn\u0027t update doesn\u0027t really help\n\nWell...it help the clients...\n\n\u003e It would seem that simply updating superprojects manually would be easier for the user to understand.\n\nHrm...that may be.  Perhaps a button someone with permission could click to say HEAD green for all project/branches the superproject aggregates....I\u0027m not sure if that\u0027s really the best idea...just talking at this point.",
      "parentUuid": "S57sYR4M",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "S6JoTjWY",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-04-04T04:17:20Z",
      "side": 1,
      "message": "Maybe an \u0027update submodules\u0027 button on the branch screen of any superproject?  Also maybe an \u0027update submodules for review\u0027 button?",
      "parentUuid": "S8DJXEAc",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Suck.Ucs",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1409,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Could you document the format for these new dependency footers?  Maybe add a page about dependencies and how gerrit handles them now (aimed at users)?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvKYSJl4",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1409,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "Suck.Ucs",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuYlIWXQ",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1415,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "This looks like the dependent change has to exist already, does this make it really complicated to create reverse dependencies (pushing a second PS at least)?  Hmm, is it even possible to create a non broken reverse dependency (one that doesn\u0027t rely on a previous PS)?  Maybe I don\u0027t understand what you are calling a reverse dependency, could you outline it?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuMo.Q8s",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1415,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Reverse dependencies are simply implicit.\n\n* Upload ps1 to cA with no dependency\n* Upload ps2 to cB with a dependency on cA\n\nAt this point, cA is said to be a dependency of cB and cB is said to be a reverse-dependency of cA.\n\n* Upload ps3 to cA with a dependency on cB\n\nNow cA and cB are both dependencies and reverse-dependencies of each other.  They are circular dependencies.  (Yea, you need a second upload to pull this off.)",
      "parentUuid": "SuYlIWXQ",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuelDFVY",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Using this table is a little disconcerting.  In the past, these were git ancestors, now you are mixing in non git dependencies (which aren\u0027t actually ancestors)?  How does   this affect other pieces in gerrit?  How does this affect the parents display in the PS sections?  Does this confuse merge commit detection (which likely counts the ancestors)?\n\nIs it possible to tell the difference between a git dependency and this new kind of dependency now?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvIYNqkQ",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "\"a little disconcerting\" -- ha, tell me about it.  I\u0027m open to suggestions.  I have no idea how I\u0027d pull it off otherwise though (unless it\u0027s OK to change the schema, but I was under the impression that\u0027s heavily frowned upon these days).\n\n\"Is it possible\" - Look up the two changes and see if they are in different projects.  Yea, I know it\u0027s a hack.",
      "parentUuid": "SuelDFVY",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuKpND4M",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T18:50:17Z",
      "side": 1,
      "message": "\u003e Look up the two changes and see if they are in different projects. Yea, I know it\u0027s a hack.\n\nUgh, that prevents dependencies in the same project across branches.  Another hack might be to use a special ancestor # (0, -1)... but I don\u0027t like either much.  The ancestor code is complex enough, I suspect you realize that since you added tons of nice new comments to some of it, :) we just spend ~1-3 weeks x 4 people creating nasty corner case dependency test cases (probably about 60 of them) and status reporting for gerrit (which I do hope to upstream at some point), so I know how bad it is.  But this just raises things to a new level of complexity.   \n\nI personally would support making first class DB objects to represent these properly, I don\u0027t know if others will?  But I suspect you will still need to solve harder problems if you want to actually support circular dependencies (locking).",
      "parentUuid": "SvIYNqkQ",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}