{
  "comments": [
    {
      "key": {
        "uuid": "SukgzP-8",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/changedetail/ChangeDetailFactory.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Which leads me to think these should be called changeDependencies instead of crossProjectDependencies since these should work for changes in the same project?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuEooE5U",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/changedetail/ChangeDetailFactory.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Well, they don\u0027t actually.  There is a distinct difference.  All same-project dependencies point directly to commits.  All cross-project dependencies point to changes.  The reason for this is two-fold.\n\n* I can\u0027t point directly to a commit in a different project because that makes circular dependencies impossible which is really important and I probably wouldn\u0027t be doing the change otherwise (this change supports circular dependencies, btw)\n* I determine whether or not the dependency should point to the most recent commit based on whether or not it is in the same project (that\u0027s the code here).  There\u0027s no way I can store metadata about whether this should point to a commit or a change in the PatchSetAncestor\u0027s table without changing the schema.",
      "parentUuid": "SukgzP-8",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuQkiKbM",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "This might be a lot easier to read (for me at least) if you just did branches \u003d newBranches;",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuGol17k",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done.  I\u0027m a sucker for `final`, haha.",
      "parentUuid": "SuQkiKbM",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Suig6i9E",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Could you abstract dependency parsing and determination details to a separate class so that it could be easily altered/enhanced.  In other words, it would be nice to allow users to specify dependencies in other ways then via the commit message at some point.",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvEYoEpU",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done (I think...)",
      "parentUuid": "Suig6i9E",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Sushl7-g",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "So what does this logic do in case of reverse dependencies?  How does it handle failures?  If a depends on b and b depends on a, what happens when a merges, but b fails?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuOpDB1Y",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "\u003cfacepalm\u003e...ugh...I had only considered a merge failing for dependency reasons (which this handles nicely).  I hadn\u0027t considered other issues?  Can I just call the verifyMergeability method above before continuing to attempt an actual merge (and thus triggering the merge in the other project)?  Is there any way to do that with locking so that nothing can nullify the result of that method call?",
      "parentUuid": "Sushl7-g",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuEozM-8",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T18:50:17Z",
      "side": 1,
      "message": "There are ways, but none are easy. :(  I will point you to some resources to help you better understand the problems involved.\n\nHere is the long thread started by Mohan over a year ago about solving a similar problem, it should help outline some of the problems anticipated back then:  https://groups.google.com/forum/?fromgroups\u003d#!searchin/repo-discuss/mohan/repo-discuss/dZg-Tie8__A/deK7EIxTaDQJ\n\nHere are Mohan\u0027s abandoned attempts at in memory Gerrit locking: https://gerrit-review.googlesource.com/#/q/status:open+project:gerrit+branch:master+topic:cross-repo-dependencies,n,z I think there were still unsolved issues with this proposal.  Of course, such a solution would not likely be useful in a clustered Gerrit environment such as what gerrit-review runs as currently.\n\n\nHere is Shawn\u0027s idea last fall to support multi-repo transactions in jgit that unfortunately has either still had stale locking issues, or races:\nhttps://groups.google.com/forum/?fromgroups\u003d#!searchin/repo-discuss/mohan/repo-discuss/mI1l5-fesI8/z-Ez0lYBoUgJ\n\nHowever, if you still want to solve this, I proposed solutions to the git mailing list about creating \"recoverable\" locks/transactions that seemed to only have issues on some (likely non posix) filesystems.  The discussion started around here: http://marc.info/?l\u003dgit\u0026m\u003d135664993801178\u0026w\u003d2 but by first proposal was flawed, I think the valuable proposal which might work (no known flaws with posix FS) starts around here: http://marc.info/?l\u003dgit\u0026m\u003d135698411219549\u0026w\u003d2\n\nThese could be used to build up a solutions similar to Shawn\u0027s proposal for a clustered shared backend.  But that is not what you guys have at google anyway (and you can likely do locking more easily with your system).  So, I think you would need to abstract the locking piece in jgit anyway and then it is just a matter of implementing different backend systems and perhaps having a way to disable the feature if the backend does not support a safe locking mechanism?\n\nSo, currently there are only 2 real backends in the wild that you need to care about your clustered google system (ask Shawns how to solve this, the system already \"locks\" refs anyway using the DB for multi-master), and a single master system.   Since shared backend with multi master is not in that list, you can ignore both Shawn\u0027s (except for how he would integrate with jgit) and my locking proposals.   If you have a pluggable locking mechanism, the single master one could start by using in memory locking with the risk of colliding with direct git updates behind Gerrit\u0027s back (which is likely OK until someone cares to solve the problem better). You could even force it to overwrite any updates behind Gerrit\u0027s back if you wanted so that Gerrit will still be consistent.",
      "parentUuid": "SuOpDB1Y",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvAYiGrM",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T20:56:15Z",
      "side": 1,
      "message": "Arg...when we first discussed this, the idea was to create something that didn\u0027t need locking as a first step...so now it looks like that\u0027s changed.\n\nIs there any way around this without abandoning circular dependencies?  Perhaps we could not enforce dependencies (not sure how confusing that would be) and only use this metadata to update a superproject atomically.",
      "parentUuid": "SuEozM-8",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvMY.Qss",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T21:14:42Z",
      "side": 1,
      "message": "I think I always thought circular required locking, I suggested starting without circular, but it didn\u0027t do you much good because you needed it. :(\n\n\u003e Is there any way around this without abandoning circular dependencies? Perhaps we could not enforce dependencies (not sure how confusing that would be) and only use this metadata to update a superproject atomically.\n\nYou could enhance the submodule support to update only when it sees a header in the commit of a subproject?  It wouldn\u0027t be truly atomic, but you could likely prevent merge failures from a submodule update (except for when the submodule gets removed).",
      "parentUuid": "SvAYiGrM",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuCo6f9E",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 312,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T21:33:25Z",
      "side": 1,
      "message": "\u003e I think I always thought circular required locking, I suggested starting without circular, but it didn\u0027t do you much good because you needed it. :(\n\nYea...I screwed up...\n\n\u003e You could enhance the submodule support to update only when it sees a header in the commit of a subproject\n\nSo how do you feel about this?  It would mean leaving dependencies that are unenforced when merging and expecting users to understand that.",
      "parentUuid": "SvMY.Qss",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "Suck.Ucs",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1409,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Could you document the format for these new dependency footers?  Maybe add a page about dependencies and how gerrit handles them now (aimed at users)?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvKYSJl4",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1409,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "Suck.Ucs",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuYlIWXQ",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1415,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "This looks like the dependent change has to exist already, does this make it really complicated to create reverse dependencies (pushing a second PS at least)?  Hmm, is it even possible to create a non broken reverse dependency (one that doesn\u0027t rely on a previous PS)?  Maybe I don\u0027t understand what you are calling a reverse dependency, could you outline it?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuMo.Q8s",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1415,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "Reverse dependencies are simply implicit.\n\n* Upload ps1 to cA with no dependency\n* Upload ps2 to cB with a dependency on cA\n\nAt this point, cA is said to be a dependency of cB and cB is said to be a reverse-dependency of cA.\n\n* Upload ps3 to cA with a dependency on cB\n\nNow cA and cB are both dependencies and reverse-dependencies of each other.  They are circular dependencies.  (Yea, you need a second upload to pull this off.)",
      "parentUuid": "SuYlIWXQ",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuelDFVY",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T15:12:14Z",
      "side": 1,
      "message": "Using this table is a little disconcerting.  In the past, these were git ancestors, now you are mixing in non git dependencies (which aren\u0027t actually ancestors)?  How does   this affect other pieces in gerrit?  How does this affect the parents display in the PS sections?  Does this confuse merge commit detection (which likely counts the ancestors)?\n\nIs it possible to tell the difference between a git dependency and this new kind of dependency now?",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SvIYNqkQ",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1006257
      },
      "writtenOn": "2013-03-28T17:36:34Z",
      "side": 1,
      "message": "\"a little disconcerting\" -- ha, tell me about it.  I\u0027m open to suggestions.  I have no idea how I\u0027d pull it off otherwise though (unless it\u0027s OK to change the schema, but I was under the impression that\u0027s heavily frowned upon these days).\n\n\"Is it possible\" - Look up the two changes and see if they are in different projects.  Yea, I know it\u0027s a hack.",
      "parentUuid": "SuelDFVY",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "SuKpND4M",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ReceiveCommits.java",
        "patchSetId": 1
      },
      "lineNbr": 1420,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2013-03-28T18:50:17Z",
      "side": 1,
      "message": "\u003e Look up the two changes and see if they are in different projects. Yea, I know it\u0027s a hack.\n\nUgh, that prevents dependencies in the same project across branches.  Another hack might be to use a special ancestor # (0, -1)... but I don\u0027t like either much.  The ancestor code is complex enough, I suspect you realize that since you added tons of nice new comments to some of it, :) we just spend ~1-3 weeks x 4 people creating nasty corner case dependency test cases (probably about 60 of them) and status reporting for gerrit (which I do hope to upstream at some point), so I know how bad it is.  But this just raises things to a new level of complexity.   \n\nI personally would support making first class DB objects to represent these properly, I don\u0027t know if others will?  But I suspect you will still need to solve harder problems if you want to actually support circular dependencies (locking).",
      "parentUuid": "SvIYNqkQ",
      "revId": "b9568666d5fa52c3f12feaf3d969268e3692d8db",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}