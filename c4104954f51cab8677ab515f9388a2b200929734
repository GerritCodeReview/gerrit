{
  "pushCert": "certificate version 0.1\npusher Dave Borowitz \u003cdborowitz@google.com\u003e 1556566552 -0700\nnonce AC6AUtN36EUruv8mcvyJCAfP4FomxDCmvZlTh5B7i7tbAUnw0DTRCzX6WuSshIJ9dxol+YKj5D5s\n\n0000000000000000000000000000000000000000 40b93023eaff9bce9567612bda7dbc30178a43f6 refs/for/master%t\u003devent-json-tests,r\u003ddavid.ostrovsky,r\u003dluca.milanesio\n-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCgAzFiEEpPm/sOxWgSqG5grhX9fFmpoSiIwFAlzHUhgVHGRib3Jvd2l0\nekBnb29nbGUuY29tAAoJEF/XxZqaEoiMZLQP/1yOnP7Uk0SSAQNPaRVGcEP9AlKm\nwSNXxxuH9mSXEPiCvQeHWt6+nWWnHo/7xaPriB87XJ8UdSpUHaZs+FVdOHsU5KEx\nvDy1WopoEw3Spa5rgk8XnhL1NrD1Tyju2zqU+9J39cAvxg5/CtAPjbdPwI2Jo22H\nimQRihiwEumuJvBqN2MQINw9zm5enxaKTBGESMEifoVr1iu9LMLFBSDArqRQSPpY\nzJecWf1uNJwCtCGeiQl1R/gc8rsavqAH/bXa2QLki8N6aPd7pUwOP+uneLA6skMA\n/vsYSWhAcfUqPK8zKgpmNT91LiDK0BksVZatXGzIh1s+2a1/iQ6iV73eHaC53wmo\nSH/RDp38BjiDzIvSIMHA9hcEm4giSptKErTJCGnc4fQYFP4RqQPlItu+XZBC80p7\ncG4SBIdGvWK8+Z07iTyXknTUYWvDdT45shFw/p731tI1AFd0iH/l/56oPwy9Z9Mc\ns2h308zA5/3MQZuhXLVlo8aDMtUxkh67vsRH775cPayu84xDXm7iFhLazfpDA5Cx\nx6c8x/s8JhqrO+R+ezB6PnjTsVztnlgj/jYf+izfycNIdSkfsEEpDTf11Ubntml+\nFrnBFwnwFPggNthb36/Ny3c3z0g5pWQnwvWczbuQ0QHCistOjzIwh3BkRdBVPI7o\nHZkn3wQNpl/L0Q1o\n\u003dvlwv\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "06b124cc_e9fe8783",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-04-29T19:52:02Z",
      "side": 1,
      "message": "This sounds like a hack to me. I am not aware of any other code path, where catching of CNFE considered to be a regular code path. At very least this could benefit from a TODO: Find a better/right way to do it.",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e271b4c_3e12f1e3",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-04-30T19:56:38Z",
      "side": 1,
      "message": "I added the e.printStackTrace() statement in the catch block, and it turns out, that only for:\n\n  HashtagsChangedEvent event \u003d new HashtagsChangedEvent(change);\n\nwe are getting 40 CNFEs, and this is only for this single event type: [1], and long version: [2]. Most of the \"try and error\" class loading attempts are JDK primitive or collection  classes. The rest are our own classes. We could check for known classes and avoid the \"probe\" approach. If it is String.class we don\u0027t need to construct java.lang.AutoValue_String and try to load it to know that this will not work, etc. The same applies for JDK collections and our own classes.\n\nI\u0027m also curious for performance implication of that change (with all CNFEs), especially given that the follow-up change in this series added the same EventGson class also for serialization, even though, it is not strictly needed for AutoValue migrated Entity-Key types to work properly, because unlike in the deserialization use case the instances are already created, and given that we are not using any annotations of type @SerializedName(\"foo\") String bar; this AutoValueAdapterFactory is not needed at all. Note, that for heavy loaded Gerrit servers, there can be number of active master CIs, that consume stream events, and we tried hard to optimize the serialization of stream events, by introducing lazy evaluation of the content of the stream events and use Suppliers.memoize() constructs to optimize the performance. I have concerns, that this AutoValueAdapterFactory \"try end error\" class loading approach would jeopardize those efforts.\n\nOn the other side, if I understand the work on AutoValue migration correctly, the only reason for AutoValueAdapterFactory is only migrated Change.Key, right? Because Project.NameKey was not migrated to AutoValue and for other types, that were migrated we use primitive JDK types anyway. So what is the point? Can\u0027t we consider to revert Change.Key migration to AutoValue until we find a cleaner approach for JSON serialization/deserialization of AutoValue types?\n\n* [1] http://paste.openstack.org/show/750121\n* [2] http://paste.openstack.org/show/750122\n* [3] https://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html",
      "parentUuid": "06b124cc_e9fe8783",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85f86247_d067b568",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-04-30T20:04:48Z",
      "side": 1,
      "message": "Sigh. You\u0027re absolutely right that this approach has downsides.\n\n\u003e Most of the \"try and error\" class loading attempts are JDK primitive or collection  classes.\n\nThis is why this solution is a hacky solution and a good solution is auto-value-gson :(\n\n\u003e I\u0027m also curious for performance implication of that change (with all CNFEs)\n\nI agree this seems bad.\n\n\u003e  Can\u0027t we consider to revert Change.Key migration to AutoValue until we find a cleaner approach for JSON serialization/deserialization of AutoValue types?\n\nI strongly oppose reintroducing gwtorm.Key just to make this work. I would rather write an explicit TypeAdapter for Change.Key until we are able to use auto-value-gson.\n\nIf we find (via EventJsonTest) that JSON serialization regresses for many more newly-AutoValue classes, then we can rethink our approach. But as you say, it\u0027s really just this one class for now.",
      "parentUuid": "4e271b4c_3e12f1e3",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60f914a5_543b16f7",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-04-30T20:13:01Z",
      "side": 1,
      "message": "For the record, another way to do this is to add an explicit runtime annotation like:\n\n public class Change {\n   @AutoValue\n   @AutoGson(AutoValue_Change_Key.class)\n   public abstract class Key {...}\n }\n\nBut I don\u0027t think that\u0027s necessarily better than having a single one-off TypeAdapter\u003cChange.Key\u003e implementation.",
      "parentUuid": "85f86247_d067b568",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3dafe62_2965b556",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-04-30T20:13:18Z",
      "side": 1,
      "message": "\u003e Sigh. You\u0027re absolutely right that this approach has downsides.\n\u003e \n\u003e \u003e Most of the \"try and error\" class loading attempts are JDK primitive or collection  classes.\n\u003e \n\u003e This is why this solution is a hacky solution and a good solution is auto-value-gson :(\n\u003e \n\u003e \u003e I\u0027m also curious for performance implication of that change (with all CNFEs)\n\u003e \n\u003e I agree this seems bad.\n\u003e \n\u003e \u003e  Can\u0027t we consider to revert Change.Key migration to AutoValue until we find a cleaner approach for JSON serialization/deserialization of AutoValue types?\n\u003e \n\u003e I strongly oppose reintroducing gwtorm.Key just to make this work.\n\nI have not suggested to re-introduce gwtorm.Key. Can\u0027t the Change.Key be implemented manually, without using AutoValue altogether for now? Why it works for Project.NameKey? It neither uses gwtorm.Key nor AutoValue.\n\n\u003e I would rather write an explicit TypeAdapter for Change.Key until we are able to use auto-value-gson.\n\nThis is exactly what I have done in this change: [1]. If you check the earlier patch sets of this change, I added dedicated ChangeKeyDeserializer and in later patch sets I switched to auto-value-gson approach. \n\n\u003e If we find (via EventJsonTest) that JSON serialization regresses for many more newly-AutoValue classes, then we can rethink our approach. But as you say, it\u0027s really just this one class for now.\n\nJupp.\n\n* [1] https://gerrit-review.googlesource.com/c/gerrit/+/222597",
      "parentUuid": "85f86247_d067b568",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fbe5150b_99e2a974",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-04-30T20:14:25Z",
      "side": 1,
      "message": "\u003e I have not suggested to re-introduce gwtorm.Key.\n\nSorry, that\u0027s what I thought you meant by \"revert Change.Key migration to AutoValue\".\n\n\u003e Can\u0027t the Change.Key be implemented manually, without using AutoValue altogether for now? \n\nYes, I think we\u0027re on the same page now.",
      "parentUuid": "d3dafe62_2965b556",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f46b552e_d1d1a3da",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-04-30T20:51:57Z",
      "side": 1,
      "message": "I\u0027ll resurrect one of your earlier patch sets.",
      "parentUuid": "fbe5150b_99e2a974",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "794a2599_a53c4a9d",
        "filename": "java/com/google/gerrit/server/events/AutoValueAdapterFactory.java",
        "patchSetId": 19
      },
      "lineNbr": 45,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-04-30T21:10:22Z",
      "side": 1,
      "message": "Feel free to take over this change.",
      "parentUuid": "f46b552e_d1d1a3da",
      "range": {
        "startLine": 43,
        "startChar": 4,
        "endLine": 45,
        "endChar": 5
      },
      "revId": "c4104954f51cab8677ab515f9388a2b200929734",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}