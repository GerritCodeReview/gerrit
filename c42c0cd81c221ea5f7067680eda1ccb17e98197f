{
  "comments": [
    {
      "key": {
        "uuid": "d92002e1_6840231e",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2015-10-19T19:00:41Z",
      "side": 0,
      "message": "Would it also solve the problem, by fixing this overload:\n\n  public static void loadJARs(Path jars) {\n    loadJARs(Arrays.asList(jars));\n  }\n\nand letting all other places unchanged?",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b90a6e5b_cf915d4c",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1012612
      },
      "writtenOn": "2015-10-19T19:17:49Z",
      "side": 0,
      "message": "Well, then you\u0027d lose the flexibility of the varargs overload here.  I did test, and we can do an overload of a single Path argument, and does appear to work.  But, when given the choice of the varargs version and the Iterable\u003cPath\u003e version, it seems like Java gets confused and guesses wrong sometimes?  Anyone more familiar with how Java is designed care to explain this behavior?",
      "parentUuid": "d92002e1_6840231e",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9e9e22c_40880eed",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2015-10-20T16:07:49Z",
      "side": 0,
      "message": "| Well, then you\u0027d lose the flexibility of the varargs overload here. \n\nHow is your approach is better, when the varargs method was removed entirely? We don\u0027t use vagary in any place, but we do use calls with single Path and List of paths.",
      "parentUuid": "b90a6e5b_cf915d4c",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f90b06d5_79f187bf",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1012612
      },
      "writtenOn": "2015-10-20T17:45:02Z",
      "side": 0,
      "message": "I never said my approach was better; I didn\u0027t know if there was a reason for the varargs, and I was unclear about why this overload was lost in preference to the Iterable\u003cPath\u003e -- and the last thing I want to do is introduce the same issue again somewhere down the line. :)\n\nIf we\u0027re confident that overloading with a single Path argument will continue to work reliably, I agree -- that is much simpler than sprinkling the code with Arrays.asList().",
      "parentUuid": "d9e9e22c_40880eed",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19ae1afa_b2a040cd",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2015-10-20T18:21:34Z",
      "side": 0,
      "message": "Overloading method resolution is covered by JLS section 15.12.2.5: [1]. What it\u0027s basically saying that varargs methods are considered less specific. That\u0027s why they are the last chosen. So, in our case, given these two methods, and given that Path is derived from Iterable\u003cPath\u003e,  \n\n* a) loadJARs(Iterable\u003cPath\u003e)\n* b) loadJARs(Path...)\n\nThen obviously method a) is choosen, because it receives exact one parameter and thus is more specific. The bug is, that in this case, method a) iterates over the single path, and tries to call addUrl() with parts of the same path.\n\nHowever, when we change the signature of b) to be:\n\n* c) loadJARs(Iterable\u003cPath\u003e)\n* d) loadJARs(Path)\n\nthen in this case the situation is completely different: d) is more specifc, because both methods have the same arity, but d) receives exact type match, when Path is passed, and thus considered to be more specific.\n\nSo the solution to all our problems is to change the method  above to be:\n\n  public static void loadJARs(Path jar) {\n    loadJARs(Arrays.asList(jar));\n  }\n\n* [1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5",
      "parentUuid": "f90b06d5_79f187bf",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b90a6e5b_0feec5b8",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/IoUtil.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1012612
      },
      "writtenOn": "2015-10-20T19:08:17Z",
      "side": 0,
      "message": "Thanks! You rock -- I never would\u0027ve known where to look in the language spec.  I\u0027ll be happy to rewrite this to use a specific single Path overload. :)",
      "parentUuid": "19ae1afa_b2a040cd",
      "revId": "c42c0cd81c221ea5f7067680eda1ccb17e98197f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}