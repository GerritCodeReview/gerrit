{
  "pushCert": "certificate version 0.1\npusher A0D0EF51 1515577298 +0100\nnonce AGjzz38bxO7fU16Z7lWfzk6O2VRCdijNxUVT6dQj44UjgczLaZ1PCdE4v8Nq9p8MWPqakC0667eW\n\n0000000000000000000000000000000000000000 c47e2a26f3c05f9456de9d315a87559575bc7db3 refs/for/master\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJaVd/SAAoJEFG1/Zeg0O9RcX8IAK4xGjsB2hnXErPjbzQsFfJr\nE5RNKmEaxso+oCpb0xsxAAFA4Fl8LqNyMEC5sNJIkJ7FrlHyJrYIvPVqhXmhqspx\nwvIE5jeQPY/OtlKshO1a4jDZkvP7O4wvxMzCLoKVJ1sMhO4yJx9xy+7rPIU2CMCQ\nn3Sxy7TeP6qu76F5dlrpg6DEveEyTVs2mDs8hlHJFn3kSxk+d2KlgfjBTWl4dJz0\ntJgTJiEsCfYEu02R4pKCp7VPYi+DY4qtyfmIQU6NkfnaHXQyA8czFa2GBpaz0BQ1\n/NDnnRGGzxMBllcKaM8IEMZaZMjAUBpFEAH/XQmMB3HR5zXhn1MJvyU29ngZ5vc\u003d\n\u003dV+/3\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "65eb66d1_d3909003",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 393,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I\u0027m confused, I don\u0027t see how this replaces existing IDs with the new one. There is no call to u.addExternalId, only u.deleteExternalIds. It looks like you\u0027re trying to avoid deleting the new ID if it _already_ exists, but that is not the semantics I think of when I hear \"replaced with\".",
      "range": {
        "startLine": 392,
        "startChar": 74,
        "endLine": 393,
        "endChar": 8
      },
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f045d254_719e3c9e",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 393,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-01-10T14:15:20Z",
      "side": 1,
      "message": "The replace is still not a single transaction :(\nThe account update in this method deletes the external IDs and the new one is added by the \u0027link\u0027 method that we call at the end of this method.",
      "parentUuid": "65eb66d1_d3909003",
      "range": {
        "startLine": 392,
        "startChar": 74,
        "endLine": 393,
        "endChar": 8
      },
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80671432_505f9c1e",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 393,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-01-10T14:18:08Z",
      "side": 1,
      "message": "See also commit message of: https://gerrit-review.googlesource.com/c/gerrit/+/150314",
      "parentUuid": "f045d254_719e3c9e",
      "range": {
        "startLine": 392,
        "startChar": 74,
        "endLine": 393,
        "endChar": 8
      },
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b75379f5_81fdd354",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 393,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T14:29:57Z",
      "side": 1,
      "message": "Ah, I missed that the last line of this method calls link, must have gotten lost underneath the bulk of this giant lambda. Maybe a short comment would have made me see it, but not a big deal.",
      "parentUuid": "80671432_505f9c1e",
      "range": {
        "startLine": 392,
        "startChar": 74,
        "endLine": 393,
        "endChar": 8
      },
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3814724_2aee4eba",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 412,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I\u0027m finding this hard to read. At the very least I would prefer an early return in the isEmpty case. I think the following (x || longStreamExpression) could also be improved, but I\u0027ll hold off on more concrete suggestions until my confusion above is cleared up.",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d382f5ba_75536c1f",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 416,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": ".anyMatch",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df9d55d5_bdd3253c",
        "filename": "javatests/com/google/gerrit/gpg/GerritPublicKeyCheckerTest.java",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I realize this is a test, but this reminds me I don\u0027t think we currently have a race-free way to say \"delete all external IDs\".\n\nLooking at AccountsUpdate#update, it calls AccountState#fromAccountConfig which reads the ext ID ref once, exposing a set of IDs. It then reads the ext ID ref again when calling createExternalIdNotes, but there\u0027s no guarantee that the ref hasn\u0027t advanced in between.\n\nIn fact I think this is a general problem if any AccountUpdater wants to do a read-modify-write operation. A simpler example to visualize might be (a, u) -\u003e u.setPreferredEmail(\"noreply+\" + a.getAccount().getPreferredEmail()). If we have the following sequence of operations:\n\n* AccountsUpdate#update reads account ref at A with email \"foo@example.com\"\n* AccountUpdater calls u.setPreferredEmail(\"bar@example.com\")\n* AccountsUpdate#commitAccountConfig creates a new MetaDataUpdate which reads account ref at B with email \"bar@example.com\"\n* AccountConfig#commit overwrites the email with \"noreply+foo@example.com\"\n\nThe observable state of the preferred email is then:\n\n foo@example.com -\u003e bar@example.com -\u003e noreply+foo@example.com\n\nwhich might be surprising to the caller, who might reasonably expect one of:\n\n foo@example.com -\u003e noreply+foo@example.com -\u003e bar@example.com\n foo@example.com -\u003e bar@example.com -\u003e noreply+bar@example.com\n\nI\u0027ve not yet convinced myself that this is something we actually care about--whether we actually need to fully support atomic read-modify-write operations. It might just not be that important. But it does feel a little odd that this AccountUpdater interface *looks* like it ought to support them, when really it doesn\u0027t.\n\nISTM to truly support this we would need to store in AccountState the state of all refs that contributed to this state, then in AccountsUpdate make sure we always read from the old state and use the correct old IDs in the BatchRefUpdate. Not that hard in theory, but again, I\u0027m not yet convinced it\u0027s necessary.",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0683fdec_ad66c88a",
        "filename": "javatests/com/google/gerrit/gpg/GerritPublicKeyCheckerTest.java",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-01-10T14:15:20Z",
      "side": 1,
      "message": "\u003e But it does feel a little odd that this AccountUpdater interface *looks*\n\u003e like it ought to support them, when really it doesn\u0027t.\n\nEh, this interface looks like it supports atomic read-modify-write operations because it was supposed to support them :(\n\n\u003e I don\u0027t think we currently have a race-free way to say \"delete all external IDs\".\n\u003e \n\u003e Looking at AccountsUpdate#update, it calls AccountState#fromAccountConfig\n\u003e which reads the ext ID ref once, exposing a set of IDs. It then reads the\n\u003e ext ID ref again when calling \u003e createExternalIdNotes, but there\u0027s no\n\u003e guarantee that the ref hasn\u0027t advanced in between.\n\nBoth reads of the external IDs branch are supposed to see the same commit :(\nIs it somehow possible to freeze all ref states after opening a repo?\n\n\u003e In fact I think this is a general problem if any AccountUpdater wants to do a\n\u003e read-modify-write operation. A simpler example to visualize might be (a, u) -\u003e \n\u003e u.setPreferredEmail(\"noreply+\" + a.getAccount().getPreferredEmail()). If we\n\u003e have the following sequence of operations:\n\u003e * AccountsUpdate#update reads account ref at A with email \"foo@example.com\"\n\u003e * AccountUpdater calls u.setPreferredEmail(\"bar@example.com\")\n\u003e * AccountsUpdate#commitAccountConfig creates a new MetaDataUpdate which\n\u003e   reads account ref at B with email \"bar@example.com\"\n\u003e * AccountConfig#commit overwrites the email with \"noreply+foo@example.com\"\n\nDoes it really overwrite the email? I thought on commit VersionedMetaData sets the revision from which it read as expected old ObjectId and hence if there was an update in between, committing would fail with LockFailure and then we would retry the whole account update operation, giving the caller a chance to see the new preferred email in update consumer when the retry is done.",
      "parentUuid": "df9d55d5_bdd3253c",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e15b240_4119e68f",
        "filename": "javatests/com/google/gerrit/gpg/GerritPublicKeyCheckerTest.java",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T14:33:46Z",
      "side": 1,
      "message": "\u003e Both reads of the external IDs branch are supposed to see the same commit :(\n\u003e Is it somehow possible to freeze all ref states after opening a repo?\n\nNo. Some JGit implementations do this as an implementation detail, but not all storage formats are capable of supporting it (e.g. loose refs), and the JGit API doesn\u0027t tell you what the underlying semantics are.\n\n\u003e \u003e In fact I think this is a general problem if any AccountUpdater wants to do a\n\u003e \u003e read-modify-write operation. A simpler example to visualize might be (a, u) -\u003e \n\u003e \u003e u.setPreferredEmail(\"noreply+\" + a.getAccount().getPreferredEmail()). If we\n\u003e \u003e have the following sequence of operations:\n\u003e \u003e * AccountsUpdate#update reads account ref at A with email \"foo@example.com\"\n\u003e \u003e * AccountUpdater calls u.setPreferredEmail(\"bar@example.com\")\n\u003e \u003e * AccountsUpdate#commitAccountConfig creates a new MetaDataUpdate which\n\u003e \u003e   reads account ref at B with email \"bar@example.com\"\n\u003e \u003e * AccountConfig#commit overwrites the email with \"noreply+foo@example.com\"\n\u003e \n\u003e Does it really overwrite the email? I thought on commit VersionedMetaData sets the revision from which it read as expected old ObjectId\n\nIn my scenario, the old ObjectId observed in commitAccountConfig is B, even though the data in the AccountState exposed to the AccountUpdater is A.",
      "parentUuid": "0683fdec_ad66c88a",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}