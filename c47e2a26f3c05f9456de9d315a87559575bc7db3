{
  "pushCert": "certificate version 0.1\npusher A0D0EF51 1515577298 +0100\nnonce AGjzz38bxO7fU16Z7lWfzk6O2VRCdijNxUVT6dQj44UjgczLaZ1PCdE4v8Nq9p8MWPqakC0667eW\n\n0000000000000000000000000000000000000000 c47e2a26f3c05f9456de9d315a87559575bc7db3 refs/for/master\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJaVd/SAAoJEFG1/Zeg0O9RcX8IAK4xGjsB2hnXErPjbzQsFfJr\nE5RNKmEaxso+oCpb0xsxAAFA4Fl8LqNyMEC5sNJIkJ7FrlHyJrYIvPVqhXmhqspx\nwvIE5jeQPY/OtlKshO1a4jDZkvP7O4wvxMzCLoKVJ1sMhO4yJx9xy+7rPIU2CMCQ\nn3Sxy7TeP6qu76F5dlrpg6DEveEyTVs2mDs8hlHJFn3kSxk+d2KlgfjBTWl4dJz0\ntJgTJiEsCfYEu02R4pKCp7VPYi+DY4qtyfmIQU6NkfnaHXQyA8czFa2GBpaz0BQ1\n/NDnnRGGzxMBllcKaM8IEMZaZMjAUBpFEAH/XQmMB3HR5zXhn1MJvyU29ngZ5vc\u003d\n\u003dV+/3\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "65eb66d1_d3909003",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 393,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I\u0027m confused, I don\u0027t see how this replaces existing IDs with the new one. There is no call to u.addExternalId, only u.deleteExternalIds. It looks like you\u0027re trying to avoid deleting the new ID if it _already_ exists, but that is not the semantics I think of when I hear \"replaced with\".",
      "range": {
        "startLine": 392,
        "startChar": 74,
        "endLine": 393,
        "endChar": 8
      },
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3814724_2aee4eba",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 412,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I\u0027m finding this hard to read. At the very least I would prefer an early return in the isEmpty case. I think the following (x || longStreamExpression) could also be improved, but I\u0027ll hold off on more concrete suggestions until my confusion above is cleared up.",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d382f5ba_75536c1f",
        "filename": "java/com/google/gerrit/server/account/AccountManager.java",
        "patchSetId": 1
      },
      "lineNbr": 416,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": ".anyMatch",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df9d55d5_bdd3253c",
        "filename": "javatests/com/google/gerrit/gpg/GerritPublicKeyCheckerTest.java",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-01-10T13:45:30Z",
      "side": 1,
      "message": "I realize this is a test, but this reminds me I don\u0027t think we currently have a race-free way to say \"delete all external IDs\".\n\nLooking at AccountsUpdate#update, it calls AccountState#fromAccountConfig which reads the ext ID ref once, exposing a set of IDs. It then reads the ext ID ref again when calling createExternalIdNotes, but there\u0027s no guarantee that the ref hasn\u0027t advanced in between.\n\nIn fact I think this is a general problem if any AccountUpdater wants to do a read-modify-write operation. A simpler example to visualize might be (a, u) -\u003e u.setPreferredEmail(\"noreply+\" + a.getAccount().getPreferredEmail()). If we have the following sequence of operations:\n\n* AccountsUpdate#update reads account ref at A with email \"foo@example.com\"\n* AccountUpdater calls u.setPreferredEmail(\"bar@example.com\")\n* AccountsUpdate#commitAccountConfig creates a new MetaDataUpdate which reads account ref at B with email \"bar@example.com\"\n* AccountConfig#commit overwrites the email with \"noreply+foo@example.com\"\n\nThe observable state of the preferred email is then:\n\n foo@example.com -\u003e bar@example.com -\u003e noreply+foo@example.com\n\nwhich might be surprising to the caller, who might reasonably expect one of:\n\n foo@example.com -\u003e noreply+foo@example.com -\u003e bar@example.com\n foo@example.com -\u003e bar@example.com -\u003e noreply+bar@example.com\n\nI\u0027ve not yet convinced myself that this is something we actually care about--whether we actually need to fully support atomic read-modify-write operations. It might just not be that important. But it does feel a little odd that this AccountUpdater interface *looks* like it ought to support them, when really it doesn\u0027t.\n\nISTM to truly support this we would need to store in AccountState the state of all refs that contributed to this state, then in AccountsUpdate make sure we always read from the old state and use the correct old IDs in the BatchRefUpdate. Not that hard in theory, but again, I\u0027m not yet convinced it\u0027s necessary.",
      "revId": "c47e2a26f3c05f9456de9d315a87559575bc7db3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}