{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fd6199ef_db6cb676",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-09-09T15:54:33Z",
      "side": 1,
      "message": "Thanks for adding the use cases where you think this affects things. Can you quantify before and after the performance effect on these use cases? i.e. before it takes Xs to do a git push to master, after it takes Ys to do a git push to master.",
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c46bd0b5_189779f4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-09-09T17:55:46Z",
      "side": 1,
      "message": "These are not all use cases as I believe that there is more... will try to get some numbers for you ;)",
      "parentUuid": "fd6199ef_db6cb676",
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2951eb02_44670877",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-09-09T15:54:33Z",
      "side": 1,
      "message": "While this seems like a great candidate for caching, I am concerned about the \"correctness\" impact that this may have on operations. I think it would be worth pursuing a per request scope form of caching instead of a time based one. In other words, it would be better to always read this value at least once at the beginning of the request to ensure that it is up-to-date, and then use that value throughout the entire request so that it is not only faster, but consistent throughout the request. We use this technique for many of our plugin predicates. It provides a good balance between data correctness and speed, and I think it might apply well to this problem.",
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c80309cd_f71fe56e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-09-09T17:55:46Z",
      "side": 1,
      "message": "I guess I haven\u0027t expressed myself correct:\nThere were 13 calls to AccountCacheImpl.get (13 x 3 different refs check as explained above) + 1 extra call to `refs/meta/external-ids` - which summed up to overal 40 calls to get refs objects.\n\nNow in terms of `refs/meta/external-ids` correctness - unless you do some behind-the-gerrit thing it should be nicely handled by `onGitReferenceUpdated` in typical cases and extra case is handled in ExternalIdNotes. All the other evictions were added because in IT tests it was expected to do sth behind the scene to end up in stale state... Having said that I\u0027m still open for more suggestions - can you point me to an example of such scope limited cache?\n\nBut IMHO it will still create the bottleneck for the busy servers as scopes will still compete on getting the same ref object ids (`refs/meta/external-ids` and `refs/users/default`) and it is a matter of load then...",
      "parentUuid": "2951eb02_44670877",
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "531e2d64_d3ebaa9c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-09-09T11:01:44Z",
      "side": 1,
      "message": "I forgot to mention that test case was added to AccountIT.java which means that in-memory Git repo is used to back the access to refs... I can imagine that calling it on real git server could result in even higher performance degradation...",
      "range": {
        "startLine": 52,
        "startChar": 0,
        "endLine": 55,
        "endChar": 0
      },
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b980190c_27009195",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdNotes.java",
        "patchSetId": 3
      },
      "lineNbr": 752,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-09-09T10:55:04Z",
      "side": 1,
      "message": "the rationale behind the change:\n1. when account gets created it results in 2 ref updates (see line #498 in com.google.gerrit.server.account.AccountsUpdate.commit(Repository, UpdatedAccount))\n* refs/users/XX/YYYYY (account details update)\n* refs/meta/external-ids (external ids update)\n\n2. update to `refs/users/XX/YYYY` results in the account re-index but it happens before the `refs/meta/external-ids` update hence it uses stale data\n\n3. in order to avoid it (and also speed up the reindex) update refs/meta/external-ids cache with the current value of ObjectId - evict(refs/meta/external-ids) would work too but with this move extra reach to repo for ObjectId is avoided until `refs/meta/external-ids` update gets propagated (after reindex).",
      "range": {
        "startLine": 750,
        "startChar": 4,
        "endLine": 752,
        "endChar": 5
      },
      "revId": "c5f817cff8085a78a6cc88dd23a0f4d13b538fc1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}