{
  "comments": [
    {
      "key": {
        "uuid": "4ee1c104_f9d1cec3",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 359,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-01-18T20:21:03Z",
      "side": 1,
      "message": "Optional: instead of using forEach to populate sorted map, sorted map can be created using extended Collections.toMap collector version, that is accepting 4 parameters: keyMapper, valueMapper, mergeFunction and mapSupplier. Unfortunately, Collectors.throwingMerger() is private and cannot be used directly as mergeFunction. When we copy it into this class or in some other utility class location, then this can be rewritten as:\n\n   TreeMap\u003cProject.NameKey, ProjectNode\u003e treeMap \u003d\n        projects.collect(\n            Collectors.toMap(\n                ProjectState::getNameKey,\n                e -\u003e projectNodeFactory.create(e.controlFor(currentUser).getProject(), true),\n                throwingMerger(),\n                TreeMap::new));",
      "range": {
        "startLine": 354,
        "startChar": 8,
        "endLine": 359,
        "endChar": 15
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4bf269ad_6cf485e5",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 359,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-01-18T23:45:36Z",
      "side": 1,
      "message": "This part of the code cannot be optimized anyway :-(\nIt seems that the use with a treeMap never took into consideration the start/limit parameters.\n\nWhoever is calling the ListProjects returning a treeMap is in danger to break the JVM for large scale installations.\n\nUsing streams or not, doesn\u0027t make any difference here: we\u0027ll always do the full navigation of all projects, regardless :-(",
      "parentUuid": "4ee1c104_f9d1cec3",
      "range": {
        "startLine": 354,
        "startChar": 8,
        "endLine": 359,
        "endChar": 15
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a90f15f_1dd46381",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 361,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-01-18T20:21:03Z",
      "side": 1,
      "message": "It seems that we can just merge the treeMap output lines below into the if branch above:\n\n  if (showTree \u0026\u0026 !format.isJson()) {\n    TreeMap\u003cProject.NameKey, ProjectNode\u003e treeMap \u003d [...]\n    if (treeMap.size() \u003e 0) {\n          printProjectTree(stdout, treeMap);\n    }\n    return null;\n  }\n\nAnd of course the two lines at the end of the method that are invoking printProjectTree could be removed. The big advantage doing it that way, is that with earlier return we can eliminate long else branch and dedent the whole code below this if-statement. Another benefit, we can reduce the scope of treeMap variable to this branch only.",
      "range": {
        "startLine": 361,
        "startChar": 6,
        "endLine": 361,
        "endChar": 14
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e73d55d4_03f68802",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 361,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-01-18T23:45:36Z",
      "side": 1,
      "message": "I am bit reluctant in putting too many optimizations at once: it\u0027s certainly a good idea, however, I would like to do one step at the time.",
      "parentUuid": "4a90f15f_1dd46381",
      "range": {
        "startLine": 361,
        "startChar": 6,
        "endLine": 361,
        "endChar": 14
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8352554b_942b456d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 376,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-01-18T20:21:03Z",
      "side": 1,
      "message": "It seems that in the base version there are similar skip and limit logic on lines 427 and 430, using foundIndex++ \u003c start and ++found \u003e limit conditions. The question is why with streams it it more effective, as per your report it boosted the performance by factor 20? Or, the optimization logic in the base version has some flaw? But then it could be probably fixed without re-writing the whole method with streams?",
      "range": {
        "startLine": 372,
        "startChar": 8,
        "endLine": 376,
        "endChar": 9
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1db14fdf_d858d8b6",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 376,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-01-18T23:45:36Z",
      "side": 1,
      "message": "This is the basis of the stream processing: if you use collections (e.g. ArrayList\u003c\u003e as it was before) you are forced to create and evaluate everything upfront and keep it in memory.\n\nOnly afterward, when you perform the for/loop, you can skip and limit, but it is way too late :-(\n\nBy lazy evaluating everything, you never have anything in memory and make the data and processing flow in a pipeline. The skip/limit on the streams have the wonderful advantage to completely avoid processing and put in memory something that eventually is going to be dropped.\n\nThe results on GerritHub.io (40k projects, 1TB of repos) were amazing:\n- No memory increase (streams) vs. 50GB of memory increase (collections)\n- 3s (streams) vs. 30mins (collections)\n\nEven a simple test with a reduced set (12k projects of 1 commit each) had significant advantage also.",
      "parentUuid": "8352554b_942b456d",
      "range": {
        "startLine": 372,
        "startChar": 8,
        "endLine": 376,
        "endChar": 9
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "818ff43b_a7efe579",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 378,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2019-01-18T20:21:03Z",
      "side": 1,
      "message": "As pointed out in Item 45 of Effective Java (3rd edition): Use streams judiciously. Here, it smells as Stream abuse actually, because all we want is to skip and limit, isn\u0027t it? What if we would just collect to list and iterate over it at this location:\n\n  List\u003cProjectState\u003e states \u003d projects.collect(Collectors.toList());\n  for (ProjectState projectState : states) {\n    Project.NameKey projectName \u003d projectState.getNameKey();\n    [...]\n\nThe code should be equivalent. But the again the question is, what is wrong with skip and limit with the base version?",
      "range": {
        "startLine": 378,
        "startChar": 8,
        "endLine": 378,
        "endChar": 25
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ad8b6c0_2cbff93b",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/project/ListProjects.java",
        "patchSetId": 13
      },
      "lineNbr": 378,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-01-18T23:45:36Z",
      "side": 1,
      "message": "Collector *must be done* as the very last operation because is actual execution of the stream processing.\n\nIf you collect before skipping/limiting, then you will evaluate the entire stream, including the elements you would have skipped or dropped at the end, which isn\u0027t good for your heap and isn\u0027t fast for your users.",
      "parentUuid": "818ff43b_a7efe579",
      "range": {
        "startLine": 378,
        "startChar": 8,
        "endLine": 378,
        "endChar": 25
      },
      "revId": "ca1b9bac9ef091328ac165503f75f57af8eb4b51",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}