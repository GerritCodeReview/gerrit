{
  "comments": [
    {
      "key": {
        "uuid": "AAABCX///34\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-15T21:02:15Z",
      "side": 1,
      "message": "Is this accurate?  From the code, it looks like it should say \"...for every change with the same destination branch as the new patch which came in.\"",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABC3////I\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-16T18:14:45Z",
      "side": 1,
      "message": "Not sure if your suggestion really is more clear, Martin. What about replacing this paragraph to be like below text?\n\nThis feature aims to tag each change according to its mergeability. Whenever a new patch set comes in, a merge test occurs to the patch set incoming. It determines if the current patch set is \"mergeable\" to the target branch.\n\nWhen a patchset is merged to a branch, all changes having same target branch are tested again.",
      "parentUuid": "AAABCX///34\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDH///7U\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-16T22:14:50Z",
      "side": 1,
      "message": "Yes, much better, thanks.  Minor quip:\ns/patch set incoming/incoming patch set/",
      "parentUuid": "AAABC3////I\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDX///8U\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-17T13:52:57Z",
      "side": 1,
      "message": "Thanks for the correction :-)",
      "parentUuid": "AAABDH///7U\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABCX///30\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-15T21:02:15Z",
      "side": 1,
      "message": "Is this queue persistent?  Will it remember unfinished tasks if the server dies?  If not, perhaps it should be run on startup? That could be rather CPU intensive with hundreds of projects with several branches each!  Another idea would be to add a testedAgainst field to the change object which would contain the last ref this change was tested against (the head of the branch).  Then, on startup, only out of date changes could be added to the queue.  This would also allow several other things to be done, for one: it would allow for a changes mergeability status to be verified on display (a follow on optimisation perhaps)",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABC3///+0\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-16T18:14:45Z",
      "side": 1,
      "message": "Good point. We should investigate it and address it.\n\nAbout testedAgainst field suggestion, I think it would not be necessary since when a commit is merged to a branch (in MergeOp), it re-tests all changes having same branch as target.",
      "parentUuid": "AAABCX///30\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDH///7Q\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-16T22:14:50Z",
      "side": 1,
      "message": "Right, the testedAgainst was just one way to prevent every change from having to be retested on startup if the queue is not persistent.",
      "parentUuid": "AAABC3///+0\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABCX///y8\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-15T21:02:15Z",
      "side": 1,
      "message": "I cannot tell, but is there some mechanism to make the queue a singleton so that there aren\u0027t new queues for every change merged even if on the same branch as a currently running queue/  If not, it seems like it could potentially waste many cycles repeating the same comparisons?  This, again might be easily fixed with the addition of a testesAgainst field and a simple check in the queue to discard changes with an uptodate testedAgainst field.",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABC3///+4\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-16T18:14:45Z",
      "side": 1,
      "message": "Martin, please, I would need your help on clarifying it :-(\n\nIt seems for our team it behaves as a singleton. ChangeTestMergeQueue is bound in GerritGlobalModule as one instance per injector. A WorkQueue instance is received (injected) in ChangeTestMergeQueue constructor. Are we right about it or are we missing something on this?",
      "parentUuid": "AAABCX///y8\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDH///6Y\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-16T22:14:50Z",
      "side": 1,
      "message": "I think you answered my question, thanks, it looks good.",
      "parentUuid": "AAABC3///+4\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDH///5s\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 147,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-16T22:14:50Z",
      "side": 1,
      "message": "Could you explain why you have separated adding to the queue from consuming it?  If you were worried about blocking during the adds, it appears that you have just delayed the block until you consume it here (the synchronized above still blocks until all the changes have been scheduled)?\n\n\nI don\u0027t know if scheduleJob() blocks until an entry is tested (I assume not).  However, if it does not block until the entry is tested, then it looks like the entry is not removed from the queue until right before it is tested.  In that case, it seems like any time another user calls consumesQueue (which is likely since this class is a shared Singleton), it will reschedule everything still in the queue?  It seems like that means that an entry could get scheduled multiple times until it is finally tested, causing the entry to be inadvertently tested unnecessarily more than once?",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABDX///8Y\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/ChangeTestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 147,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-17T13:52:57Z",
      "side": 1,
      "message": "About first questions, yes, the reason is to not block during the adds. However, I detected an error on it. There is no implementation of Change.equals, it is needed to avoid same change appear twice or more in queue.\n\nAbout scheduleJobs you are right. We should include a scheduled boolean field in TestMergeEntry to avoid it.",
      "parentUuid": "AAABDH///5s\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABCX///4I\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 957,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-15T21:02:15Z",
      "side": 1,
      "message": "Is there a query involving the branch?  If not, add one to ProjectAccess?  Perhaps even include status?",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABC3////A\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/MergeOp.java",
        "patchSetId": 1
      },
      "lineNbr": 957,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-16T18:14:45Z",
      "side": 1,
      "message": "Agree. We should do it.",
      "parentUuid": "AAABCX///4I\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABCX///4E\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/TestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 23,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2011-06-15T21:02:15Z",
      "side": 1,
      "message": "If this is a command, it should likely be consumeQueue, the extra \u0027s\u0027 makes it sound like a question.  Also, I think that \u0027queue\u0027 is redundant on all these methods since the object is a queue.",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABC3///+8\u003d",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/git/TestMergeQueue.java",
        "patchSetId": 1
      },
      "lineNbr": 23,
      "author": {
        "id": 1003770
      },
      "writtenOn": "2011-06-16T18:14:45Z",
      "side": 1,
      "message": "Ok",
      "parentUuid": "AAABCX///4E\u003d",
      "revId": "caa1f9e989532e4335c79a479d5e64d9590a2612",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}