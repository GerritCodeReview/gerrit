{
  "comments": [
    {
      "key": {
        "uuid": "AAAA/n///iQ\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2011-04-07T14:02:41Z",
      "side": 1,
      "message": "\u0027An\u0027?  maybe it should be \u0027E.g.\u0027?",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///ZM\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "I think I would prefer to use the full name, \"Push Branch\".\n\nBut I\u0027m wondering if we shouldn\u0027t use the format that the git-store topic is using:\n\n  [access \"refs/tags/*\"]\n    push \u003d -2..+2\n\n  [access \"refs/heads/*\"]\n    push \u003d -3..+3\n\n  [access \"refs/heads/*\"]\n    label-Code-Review \u003d -1..+1\n\nBut then I would even say this should be called restrict-access or limit-access.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3//+s4\u003d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2011-05-06T14:24:36Z",
      "side": 1,
      "message": "This format is grouped by refs and makes more sense once we have the project\naccess rights admin UI from the git-store topic.\n\nAdditionally, with this format we should really call the section\nrestrict-access instead of just access to make it explicit that everything\nnot mentioned is allowed and everything specified under the restrict-access is\na restriction.\n\nTo validate a new ref right we would then use the following algorithm:\n\n\tfor (restriction in [r in restrict-access where applies(r, newRefRight)])\n\t\tif (newRefRight.range \u003e restriction)\n\t\t\tthrow NOT-ALLOWED\n\n\tfunction applies(restriction, newRefRight)\n\t\treturn restriction.category \u003d\u003d newRefRight.category\n\t\t\t\u0026\u0026 nonEmptyIntersection(restriction.ref, newRefRight.ref)\n\n\tfunction nonEmptyIntersection(ref1, ref2)\n\t\treturn ! toAutomaton(ref1).intersection(toAutomaton(ref2)).isEmpty()\n\nSome examples. Let\u0027s suppose we have the following access restrictions in\ngerrit.config file:\n\n\t[restrict-access \"refs/tags/*\"]\n\t\tpush \u003d -2..+2\n\nWhen parsed we have a restrict-access list like:\n\n\trestrict-access \u003d [\n\t\tRestrictAccess(\"push\", \"refs/tags/*\", Range(-2,2))\n\t]\n\nIf a user enters a new ref right like:\n\n\tpush, refs/tags/abc, -3..+3\n\nthen the user input matches the RestrictAccess rule from the restrict-access\nlist as:\n- categories are equal\n- intersection(\"refs/tags/abc\", \"refs/tags/*\") is non empty\n\nand the new ref right is not allowed because:\n- Range(-3,3) \u003e Range(-2,2)\n\nWith the same restrict-access list if a user enters:\n\n\tpush, ^refs/[nt]ags/abc, -3..+3\n\nthen the user input matches the RestrictAccess rule from the restrict-acces for\nthe same reasons as in the previous example and the new ref right is also not\nallowed for the same reason as above.\n\n\nBefore I start changing the existing implementation please let me know\nif you agree with the above.",
      "parentUuid": "AAAA/n///ZM\u003d",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///ZE\u003d",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/errors/ForbiddenRefRightException.java",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "This should be an english string, not the full package and class name of the class.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///ZA\u003d",
        "filename": "gerrit-common/src/main/java/com/google/gerrit/common/errors/InvalidRegExpException.java",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "If you change the format like I suggest in the commit message, you need to adjust this documentation string.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///Y8\u003d",
        "filename": "gerrit-gwtui/src/main/java/com/google/gerrit/client/rpc/GerritCallback.java",
        "patchSetId": 2
      },
      "lineNbr": 60,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "This is better positioned in the access editor\u0027s addRight callback. Override the onError method and don\u0027t call super if isForbiddenRefRight is true.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///Yw\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/ProjectModule.java",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "I think this should be in GerritGlobalModule, which requires moving this type to the gerrit-server package. But if we ever support editing permissions over SSH (which git-store enables!) we need to run this logic in a context where the gerrit-http code might not be visible.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///Yc\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/constraints/Allow.java",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "This isn\u0027t how we usually do this sort of matching.\n\nInstead we say something like:\n\n* If ref is regexp, get the shortest example. See if allowedRef matches that. If it does, this rule applies.\n* If ref is a glob (ends with \"/*\"), see if allowedRef startsWith ref minus the trailing *.\n* Otherwise, allowedRef has to equal ref to match.\n\nEquality on a regex is really tricky. That\u0027s why we do it this way.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///PQ\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/constraints/Allow.java",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2011-04-08T15:06:42Z",
      "side": 1,
      "message": "Reading the rules you wrote it looks like what we call allowedRef you call\nref and what we call ref you call allowedRef. Before continuing I would like\nto clarify that:\n- allowedRef is what comes from \"access\" section in the gerrit.config file\n- ref is what user types in the project access screen\n\nBasically, we assumed that both allowedRef and ref could be any of\n{ref, glob, regex} which gives 9 possible combinations:\n{ref, glob, regex} x  {ref, glob, regex}.\n\nTheoretically, we could implement this method with just one line:\n\n return isSuperSet(toAutomaton(toRegExp(allowedref)), toAutomaton(toRegExp(ref)));\n\nwhere isSuperSet(a1, a2) checks if the language of the automaton a1 is a\nsuperset of the language of the automaton a2.\nFor, performance reasons we avoid conversion to regex and automaton wherever\npossible.\n\nDo you think that the implementation of the isSuperSet is not correct?\n\n\n\u003e Instead we say something like:\n\nAssuming, here you think that allowedRef is what user entered and ref is\nwhat comes from gerrit.config.\n\n\u003e If ref is regexp, get the shortest example. See if allowedRef matches that. If it does, this rule applies.\n\n\u003e If ref is a glob (ends with \"/*\"), see if allowedRef startsWith ref minus the trailing *.\n\nWe do that in lines 64-65\n\n\u003e Otherwise, allowedRef has to equal ref to match.\n\nWe do that in line 68\n\nAbout the 1st rule: basically you are saying that for any two regular\nexpressions r1 and r2:\n\n r2.matches(shortestExample(r1)) implies r1 isSuperSetOf r2\n\nIs there a proof for that?\n\n\u003e Equality on a regex is really tricky. That\u0027s why we do it this way.\n\nI am really curios to find out what is incorrect in the isSuperSet implementation.",
      "parentUuid": "AAAA/n///Yc\u003d",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///B4\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/constraints/Allow.java",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-11T15:26:45Z",
      "side": 1,
      "message": "I don\u0027t think there is anything wrong with the isSuperSet implementation. It seems like it should work, assuming the Automaton package implements union correctly. :-)\n\nThere isn\u0027t anything that says this is true:\n\n r2.matches(shortestExample(r1)) implies r1 isSuperSetOf r2\n\nIn fact, its not. Its a bad approximation of isSuperSet(). There are patterns where it is not true. E.g. \"refs/[a]{1,}\" and \"refs/[a-z]{1,}\". The shortest example of the 2nd is \"refs/a\", which matches the 1st. But another example of the 2nd is \"refs/b\", which the 1st does not permit.\n\nSince we also need this logic inside of RefRight, we should pull this all into a utility class somewhere. We should have a uniform behavior of applying regex against regex.",
      "parentUuid": "AAAA/n///PQ\u003d",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///Ys\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/constraints/Allow.java",
        "patchSetId": 2
      },
      "lineNbr": 72,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2011-04-07T23:02:40Z",
      "side": 1,
      "message": "This Javadoc comment isn\u0027t really worthwhile.",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n///iE\u003d",
        "filename": "gerrit-httpd/src/main/java/com/google/gerrit/httpd/rpc/project/constraints/InvalidRangeException.java",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2011-04-07T14:02:41Z",
      "side": 1,
      "message": "missing licence header",
      "revId": "ccdf633054c4f10127c5df7aaaf2651acb8ce60a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}