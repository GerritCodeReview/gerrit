{
  "pushCert": "certificate version 0.1\npusher A0D0EF51 1532500673 +0200\nnonce APISObQ/6N4sjDwkysu9SfXB7KkEeD3dax0DxYr8Uw5rekTljlh9R052s5yKKdrxQF5oPrUavKry\n\n0000000000000000000000000000000000000000 ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEjcOJ9ZBmQPrFqZA3UbX9l6DQ71EFAltYGsEACgkQUbX9l6DQ\n71GXoAf+OBqjATqNFtO6R3fuPHe+GKHHdHseGQE3Jhaw0idO+/V9Rzl2DrA3VRC1\nBD7vO7HeLNVOmRAvc2mK5lW0Xf427kA7N3bP1Kt4QhMnzINdT72TllmfmR4KNa3k\nHOp2wRXFMm+44ZudWwb55wvqOM0rt5fgnSAXCcOLBP88a3/Ze192QnSHj2F+PGWq\nLmsAPepInYtPETBVC4WSgZYJ3XV/znH2aNZAKYeZYd2ZxkJTkVjieAgRE6778ks7\n8b3SgNpHaw3JyWxKTyRuXXXOIFqxHTOL2N/ljFr5J9AbfeeNz1qm8d904WMh7IsS\ncEG8oaLh0sPV4OJjmiZNooVXWmIArQ\u003d\u003d\n\u003dWju4\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "33b8f68a_428d1fd8",
        "filename": "Documentation/rest-api-projects.txt",
        "patchSetId": 11
      },
      "lineNbr": 2903,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-25T14:37:30Z",
      "side": 1,
      "message": "I\u0027m not sure we should allow this to be unspecified at all. If the user accidentally omits it, then I\u0027m worried that the request thread will continue walking history for hours. Even if they notice this and cancel the request, the server is neither reading nor writing to the socket while it\u0027s searching the history, so it won\u0027t notice that the connection is closed.\n\nWould it be reasonable to cap this value (even if specified) at some constant multiple of index.maxTerms to limit the total number of index queries that the operation will perform? If we have maxTerms \u003d 100 (98 usable terms per query) and we limit it to 100 queries, then that gives us 9800 commits; do you think that would be enough for our use cases? What if the multiple is 200?",
      "range": {
        "startLine": 2902,
        "startChar": 46,
        "endLine": 2903,
        "endChar": 66
      },
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d1d7bb69_dc1373b1",
        "filename": "Documentation/rest-api-projects.txt",
        "patchSetId": 11
      },
      "lineNbr": 2903,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-07-26T11:12:43Z",
      "side": 1,
      "message": "Yes, I agree it makes sense to always limit this. But for the sake of documentation I would prefer a fixed limit, rather than a limit that is based on maxTerms (which varies by host, e.g. for Lucene the default is 1024).\n\nWith a fixed limit we can have a skip_commits parameter in addition so that you can still auto-close changes by very old commits (in order to use skip_commits properly you would need to know the exact limit).\n\nFWIW the Gerrit history has ~33500 commits, so that would require ~350 queries with maxTerms \u003d 100. But this is for one branch only. If we have a limit for max_commits we should maybe not allow to specify multiple branches in the input, because the limit would be per branch.\n\nI\u0027m setting a hard-coded limit of 10000 commits now. I think that should be sufficient for almost all use-cases.\n\nDone",
      "parentUuid": "33b8f68a_428d1fd8",
      "range": {
        "startLine": 2902,
        "startChar": 46,
        "endLine": 2903,
        "endChar": 66
      },
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0e33979_4549027c",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 155,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-25T14:37:30Z",
      "side": 1,
      "message": "This strikes me as weird, since normally these kinds of commits are rejected. I guess maybe a commit could have multiple Change-Id lines when it was directly pushed, which bypasses that check. In that case I\u0027m not actually sure what is the right answer for which Change-Id corresponds to this commit, but your choice of all of them seems as good as any.\n\nMaybe leave a comment?",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0967b94d_5ce5b50d",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 155,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-07-26T11:12:43Z",
      "side": 1,
      "message": "I don\u0027t mind much what is done here, but it should be consistent with what ReceiveCommits#autoCloseChanges does and ReceiveCommits#autoCloseChanges currently considers all Change-Id lines. Added a comment.\n\nDone.",
      "parentUuid": "b0e33979_4549027c",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ae34dd7_49483e28",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 157,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-25T14:37:30Z",
      "side": 1,
      "message": "What if there are multiple SHA-1s with the same Change-Id? This could happen if a change was cherry-picked to a stable branch which then got merged back into master.",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "409f7bdc_a2254396",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 157,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-07-26T11:12:43Z",
      "side": 1,
      "message": "Good question. I\u0027ve added my thoughts on this as a comment.\n\nDone.",
      "parentUuid": "4ae34dd7_49483e28",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14c2c9e7_c528bc64",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 169,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-25T14:37:30Z",
      "side": 1,
      "message": "+3, you forgot project.\n\nMore generally, this seems easy to get wrong. For example, if we add another \"open\" status, then open() will have more than one leaf term.\n\nI think this (and some code elsewhere as well :) would be better if we had a Predicate#leafCount method. Then you could have a  method in this class which produces the (is:open project:foo branch:bar) predicate. Call it once here (well, outside the loop) to count the leaves, then call the same method again in autoCloseableChangesByBranch when constructing the actual query, so it\u0027s guaranteed to be the right count.",
      "range": {
        "startLine": 168,
        "startChar": 12,
        "endLine": 169,
        "endChar": 21
      },
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c222a60_930cc540",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 169,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-07-26T11:12:43Z",
      "side": 1,
      "message": "Good idea, this made me realize that this logic is wrong here. We must check the limit before adding the predicates for the current commit, otherwise this can make it go over the top.\n\nDone.",
      "parentUuid": "14c2c9e7_c528bc64",
      "range": {
        "startLine": 168,
        "startChar": 12,
        "endLine": 169,
        "endChar": 21
      },
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c1c276f_f234f5d5",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 254,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2018-07-25T14:37:30Z",
      "side": 1,
      "message": "Putting this inside the retry loop increases the chances of a permanent failure. The way you have it, a single failure in updating any of the changes will cause this block to be retried, so N failures spread across all the changes in this batch will result in permanent failure.\n\nIf you split the logic up so that the first retry is only for executing the query and collecting the changes to auto-close, then you can use a separate RetryHelper for each change. That way you won\u0027t see a permanent failure unless a single change fails multiple times.\n\nI don\u0027t feel too strongly, though. If leaving it this way keeps the logic easier to manage, then that\u0027s fine by me (until proven otherwise in production).",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f4700e6_e7a70299",
        "filename": "java/com/google/gerrit/server/project/ProjectsConsistencyChecker.java",
        "patchSetId": 11
      },
      "lineNbr": 254,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2018-07-26T11:12:43Z",
      "side": 1,
      "message": "I think this even simplifies the code.\n\nDone.",
      "parentUuid": "7c1c276f_f234f5d5",
      "revId": "ccfe1a3f75c0332b51dd43c48abf7d1c6455a11e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}