{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6ac1dd42_85ec1a41",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesParser.java",
        "patchSetId": 8
      },
      "lineNbr": 348,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2021-12-01T10:46:56Z",
      "side": 1,
      "message": "Is this a Java 10 feature? \nIt\u0027s the first time I see this in the Gerrit code base, are we OK with making use of this?",
      "range": {
        "startLine": 348,
        "startChar": 4,
        "endLine": 348,
        "endChar": 7
      },
      "revId": "d2e9ecc5ebe9c038a9f24e18cc724690efb778b6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b55d145_6cdd8e72",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesParser.java",
        "patchSetId": 8
      },
      "lineNbr": 348,
      "author": {
        "id": 1091982
      },
      "writtenOn": "2021-12-01T11:04:22Z",
      "side": 1,
      "message": "Yes. It was not used before in the code base; I was also unsure if it\u0027s OK to introduce it.\n\nWe should not move back to an older java version in the future. It will only not work if we wanted to cherry-pick to older releases that run on Java 8 or earlier.\n\nThe advantage to that is making the code more readable and simplify type declaration, especially for long type definitions so that the declaration fits on a single line.\n\nMaybe we can promote usage of \"var\" in our code base. I can bring this into discussion in our next meeting. For now, I can roll this back.",
      "parentUuid": "6ac1dd42_85ec1a41",
      "range": {
        "startLine": 348,
        "startChar": 4,
        "endLine": 348,
        "endChar": 7
      },
      "revId": "d2e9ecc5ebe9c038a9f24e18cc724690efb778b6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe03c686_288bd358",
        "filename": "java/com/google/gerrit/server/notedb/ChangeNotesParser.java",
        "patchSetId": 8
      },
      "lineNbr": 348,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2021-12-01T11:06:41Z",
      "side": 1,
      "message": "Yes, maybe ask the ESC whether we want to start using Java 10 language features.\nRolling back for now, seems good (e.g. this broke my local build).",
      "parentUuid": "9b55d145_6cdd8e72",
      "range": {
        "startLine": 348,
        "startChar": 4,
        "endLine": 348,
        "endChar": 7
      },
      "revId": "d2e9ecc5ebe9c038a9f24e18cc724690efb778b6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c20b7fcc_7c6154a4",
        "filename": "javatests/com/google/gerrit/acceptance/api/change/StickyApprovalsIT.java",
        "patchSetId": 8
      },
      "lineNbr": 281,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2021-12-01T12:40:50Z",
      "side": 1,
      "message": "I\u0027m proposing this description for the test, so that it\u0027s easier to understand how this test works:\n\nThis test is covering the backfilling logic for changes which have been submitted, based on copied approvals, before Gerrit persisted copied votes as Copied-Label footers in NoteDb. It verifies that for such changes copied approvals are returned from the API even if the copied votes were no persisted as Copied-Label footers.\n\nIn other words, this test verifies that given a change that\n\n* was approved by a copied vote and then submitted\n\n* and for which the copied approval is not persisted as a Copied-Label footer in NoteDb\n\nthe copied approval is backfilled from the corresponding Submitted-With footer that got written to NoteDb on submit.\n\nCreating such a change would be possible by running the old Gerrit code from before Gerrit persisted copied labels as Copied-Label footers. However since this old Gerrit code is no longer available, the test needs to apply a trick to create a change in this state. It configures a fake submit rule, that pretends that an approval for a non-sticky label from an old patch set is still present on the current patch set and allows to submit the change. Since the label is non-sticky no Copied-Label footer is written for it. On submit the fake submit rule results in a Submitted-With footer that records the label as approved (although the label is actually not present on the current patch set). This is exactly the change state that we would have had by running the old code if the submit was based on a copied label. As result of the backfilling logic we expect that this \"copied\" label (the label that is mentioned in the Submitted-With footer) is returned from the API.",
      "revId": "d2e9ecc5ebe9c038a9f24e18cc724690efb778b6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}