{
  "comments": [
    {
      "key": {
        "uuid": "d5a0b336_341d4cfe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-05-29T22:09:09Z",
      "side": 1,
      "message": "I studied the tagSet code for a bit (see https://gerrit-review.googlesource.com/c/gerrit/+/226392 - you\u0027re welcome to fold that in here or submit separately), but I don\u0027t understand why this helps. \n\nTagSet#build does a revwalk starting from all the refs that went through addRef(), creating a bitset for each of commit. This would likely cover most of the commits. \n\nSo, where does the space savings come from? Is it because of incremental updates to the tagset (that somehow avoid creating bitsets?)",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 5
      },
      "revId": "dc6ed65da836eef10f2cad0f54d4559eeb42cb53",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "417a1b73_266938ef",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-05-29T22:50:17Z",
      "side": 1,
      "message": "\u003e I studied the tagSet code for a bit (see https://gerrit-review.googlesource.com/c/gerrit/+/226392 - you\u0027re welcome to fold that in here or submit separately), but I don\u0027t understand why this helps. \n\nI just saw that, thanks!\n\n\u003e \n\u003e TagSet#build does a revwalk starting from all the refs that went through addRef(), creating a bitset for each of commit. This would likely cover most of the commits. \n\nThe current tip version creates a bitset for each commit. This change modifies that approach to only create and keep a bitset for commits directly pointed to by tags. Non-tag commits have their BitSet (if any) copied/ORed with their parent(s).\n\n\u003e \n\u003e So, where does the space savings come from? Is it because of incremental updates to the tagset (that somehow avoid creating bitsets?)\n\nNo, we didn\u0027t modify the incremental update behavior.\n\nIf you have many commits that aren\u0027t directly referenced by a tag and also have many non-tag/non-change refs, then the tip implementation will comparatively use a lot of memory because you have big BitSets (many non-tag/non-change refs) and many of them (many commits walked and each commit has a unique BitSet). Those \"intermediate\" commits are never referenced outside the walk, and having a BitSet on them was just a convenience so that you could always OR with your parents.",
      "parentUuid": "d5a0b336_341d4cfe",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 5
      },
      "revId": "dc6ed65da836eef10f2cad0f54d4559eeb42cb53",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "654c7894_aa1f7dd1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-05-29T22:52:14Z",
      "side": 1,
      "message": "\u003e \u003e TagSet#build does a revwalk starting from all the refs that went through addRef(), creating a bitset for each of commit. This would likely cover most of the commits. \n\u003e \n\u003e The current tip version creates a bitset for each commit. This change modifies that approach to only create and keep a bitset for commits directly pointed to by tags. Non-tag commits have their BitSet (if any) copied/ORed with their parent(s).\n\nOops, didn\u0027t finish that sentence. Trying again:\nNon-tag commits have their BitSet (if any) copied/ORed with their parent(s) and then set to null so that the memory can be reclaimed.",
      "parentUuid": "417a1b73_266938ef",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 5
      },
      "revId": "dc6ed65da836eef10f2cad0f54d4559eeb42cb53",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77537992_b5ef8c5a",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 3
      },
      "lineNbr": 332,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-05-28T21:37:06Z",
      "side": 1,
      "message": "why is this never null?",
      "range": {
        "startLine": 332,
        "startChar": 36,
        "endLine": 332,
        "endChar": 44
      },
      "revId": "dc6ed65da836eef10f2cad0f54d4559eeb42cb53",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c675aa48_daf16fab",
        "filename": "java/com/google/gerrit/server/git/TagSet.java",
        "patchSetId": 3
      },
      "lineNbr": 332,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-05-28T23:18:57Z",
      "side": 1,
      "message": "Because we always create a BitSet in addTag().\n\nIf we want to be paranoid about nulls, we could add null checks to all these. That is actually how we have it deployed internally, but that version of the code doesn\u0027t create empty BitSets on lines 360 and 363. I think with those empty BitSets, we\u0027re safe from NPEing ever.",
      "parentUuid": "77537992_b5ef8c5a",
      "range": {
        "startLine": 332,
        "startChar": 36,
        "endLine": 332,
        "endChar": 44
      },
      "revId": "dc6ed65da836eef10f2cad0f54d4559eeb42cb53",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}