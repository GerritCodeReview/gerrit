{
  "comments": [
    {
      "key": {
        "uuid": "5e14046a_271d2ef5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-24T22:09:11Z",
      "side": 1,
      "message": "This explanation is mentioned as an afterthought after the previous paragraph. I am not sure it is obvious that this problem should only happen in normal installations on the master on startup (I think that is what you are implying?) To make it more obvious what use case you are trying to improve I think that you want to start line 14 with something like \"Prior to this commit, on servers where an update does not originate (on other masters or slaves) and on server startup, the cache loader would...\"",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aaf62e6d_c0b58ce9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-25T13:58:08Z",
      "side": 1,
      "message": "Will update tomorrow",
      "parentUuid": "5e14046a_271d2ef5",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d728a0a7_c51c2be6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-26T11:27:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aaf62e6d_c0b58ce9",
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ec94dea1_cbbd2ba6",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-24T22:09:11Z",
      "side": 1,
      "message": "If I understand correctly, this history traversal is because we don\u0027t know what our own cached version is? It seems like we should be able to fix this somehow with a lot less code and less expense. Could we:\n\n1) store the sha1 of latest version somewhere\n2) only store one value cached value with an bogus key (\"latest\")\n3) grab any of the stored values and assume that it will be good enough for a diff since we are expiring them pretty quickly\n4) grab all the values and check which is the latest?",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b65343bf_78a04a0a",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T11:38:22Z",
      "side": 1,
      "message": "the traversal here only takes 20 lines of code. I\u0027m skeptical that you can do your 4 steps in less than that.",
      "parentUuid": "ec94dea1_cbbd2ba6",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0ba27a6_657baeee",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-25T13:58:08Z",
      "side": 1,
      "message": "Asking the cache about what it has (e.g. through #asMap) relies on how it\u0027s configured. If the size is \u003e 1 we\u0027d get two entries and then have to figure out which version is the more current one (your #1) that would require extra logic for storing that. I like the loader approach because it\u0027s simple and follows common patterns (just a LoadingCache with not much extras on the side).\n\nThis is also about what is most probable: In the most likely case, we have the n-1 version cached, so the RevWalk isn\u0027t really performing a RevWalk, it\u0027s just parsing the current commit which is has to do anyway and parsing the parent (which it also has to do anyway), so essentially it\u0027s free :-)",
      "parentUuid": "b65343bf_78a04a0a",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4c9199e3_2b1d0efc",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-25T17:14:02Z",
      "side": 1,
      "message": "I am assuming that you believe the walking is expensive since you are limiting it. I am also assuming that storing an older cached version was a miss-design in the first place, because of the race introduced by storing the value by it sha1 which is being fetched externally to the loader instead of just asking for the latest version. Eliminate this pattern, and I believe you will eliminate a bunch of old code and a bunch of new code and the race and the latency expense of walking.",
      "parentUuid": "a0ba27a6_657baeee",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d253a71_0fa3bf65",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T17:41:20Z",
      "side": 1,
      "message": "Storing cache data keyed by SHA1 is a feature. It means we can persist and replicate the data in the cache across tasks and datacenters without having to worry about race conditions.  If we store something in cache that is mutable, we\u0027d have to notify replicas that new data is available, which is more work, and creates problems if for some reason, a replica misses an update.\n\nIf you store something somewhere under the key \"latest\", how does a remote task know whether or not that entry is up to date wrt to the external-IDs ref?  \n\n\u003e grab all the values and check which is the latest?\n\nthe data in the cache may replicate slower to a different data center than the ext-ID ref; the latest value you get out of the cache may be completely irrelevant to the external ID we\u0027re trying to resolve.\n\n\nmaybe I don\u0027t understand your suggestions, though.",
      "parentUuid": "4c9199e3_2b1d0efc",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a15e759d_8c54e3ad",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-25T17:52:11Z",
      "side": 1,
      "message": "I thought we were talking about local H2 caches? In the open source world, these caches are not shared across servers? Are you using something that is not that in your servers?",
      "parentUuid": "7d253a71_0fa3bf65",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45f35f0f_e9c00516",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-25T18:07:52Z",
      "side": 1,
      "message": "Yes, I think you did understand my suggestion. My suggestion is based on the assumptions that H2 caches are local to a server.\n\nIt seems to me that the intent to build incremental updates based on the extId ref changing would be base on the idea that it  should be cheap enough to perform an H2 cache update and that there would be no point in replicating this update elsewhere.",
      "parentUuid": "a15e759d_8c54e3ad",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f40fc97_27156327",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T18:21:54Z",
      "side": 1,
      "message": "Most of the work that we do is motivated by our deployment at Google, where we store the cache in bigtable which replicates globally, but without guarantees, so it has to work for that case too.\n\nI suppose clustered deployments (like the gerrit on kubernetes that folks are working on) would use a similar setup.",
      "parentUuid": "45f35f0f_e9c00516",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a1b56ae_a24ab654",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2019-07-25T18:44:42Z",
      "side": 1,
      "message": "\u003e Most of the work that we do is motivated by our deployment at Google, where we store the cache in bigtable which replicates globally, but without guarantees, so it has to work for that case too.\n\nI don\u0027t have any problem with Google choosing to do things differently. I don\u0027t think Google-specific deployment should dictate design for the open source product.\n\n\u003e \n\u003e I suppose clustered deployments (like the gerrit on kubernetes that folks are working on) would use a similar setup.\n\nI don\u0027t believe they do. There\u0027s no mechanism to share H2/on-disk caches in open source Gerrit.",
      "parentUuid": "8f40fc97_27156327",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7c20fba_fd13a242",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-25T19:03:12Z",
      "side": 1,
      "message": "Thanks for clarifying. There is something I still don\u0027t understand about your replicated setup. Why are you trying to make cache updates on other nodes fast and incremental if you have a cache that gets replicated already? Perhaps this is a situation where trying to replicate the cache creates more problems than it solves? After all, the update is likely small, a single externalId or email, and that can get replicates quickly via git and then reloaded quickly into the remote cache.  Wheres as making an update to the cache which holds all the data and then replicating that requires replicating all of the cache which is likely much slower since it likely is not an incremental update, doesn\u0027t it require replicating the entire cache?",
      "parentUuid": "1a1b56ae_a24ab654",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9347a3b9_5f9b8975",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T19:08:13Z",
      "side": 1,
      "message": "\u003e I don\u0027t think Google-specific deployment should dictate design for the open source product.\n\nall of the persistent caches in Gerrit are immutable so we could persist them in bigtable. It\u0027s been like this since Google started running Gerrit in datacenters, around 2012 or so.\n\nIf you are concerned about this design choice, you are a bit late with speaking up.",
      "parentUuid": "1a1b56ae_a24ab654",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04ceb7f1_4a5cbdcb",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T19:15:44Z",
      "side": 1,
      "message": "\u003e Why are you trying to make cache updates on other nodes fast and incremental if you have a cache that gets replicated already? \n\nSome task has to be the first one to calculate the new cache value. This is currently extremely expensive. If we reuse a previous value, it becomes much faster.\n\nWe had an alternative plan where there was no longer a big cache value, thus solving the root of the problem, but you disagreed with that because of limitations in the packed-refs format. So here we are.",
      "parentUuid": "9347a3b9_5f9b8975",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "360087eb_5af42db2",
        "filename": "java/com/google/gerrit/server/account/externalids/ExternalIdCacheLoader.java",
        "patchSetId": 4
      },
      "lineNbr": 135,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-26T11:27:29Z",
      "side": 1,
      "message": "Immutable caches by source-of-truth-ref-SHA1 make things less complex. This applies to replication, but it also applies to concurrent local threads that might base their computation on a different state in Git because an update happened in between and then work with that state through the request. If caches are immutable and by SHA1 you can have a guarantee that your cache state matches your Git state.\n\nOur cache replication is best effort, so data might not be in the remote task when you need it. Generally, I can really recommend making persistent caches replicate (best effort) as we\u0027ve made good experiences with that. You can most likely also use a Redis, a distributed memcache or other technologies or make the H2 replicate best effort as well.\n\nIn any case, as Han-Wen said, this decision was made years ago and almost all caches we have work in this way. So a change like this that tweaks how a loader works is not a good place to start a discussion around if this decision is a good one or not. If you think it is not and have the capacity to rewrite to a different design you might have in mind, please feel free to write a design doc, get it approved and follow through with implementation and vetting in production in due time. I think that this process is independent of this change because it\u0027s a more general discussion.\n\nFor external IDs specifically, a cache-by-ref-SHA1 has a bunch of downsides, which is why I wrote the design doc that you are well aware of. This change is different in that it just tries to improve the way the cache value is computed based on the primary storage format we have. It\u0027s a strict improvement for any distributed setup (yes, also master/slave that is available to everyone via the replication plugin).\n\nI said this in the design doc, but I\u0027ll say it again here, I am not a fan of using data that is not just the ref SHA1 in the key (for example the Note name SHA1). I know some folks in the community work on their own master/master setup and using anything that is not just a ref-sha1 won\u0027t do anyone a favor their.\n\nQuite honestly, I think this change is hard to disagree on, even if you want to see it through the eyes of \"if something helps the deployment on googlesource.com while not harming open-source, it should still not be in core\" just because it helps master/slave and from looking at the thinking that the loader follows (diff instead of full reload when possible). I hope we can agree on that.",
      "parentUuid": "04ceb7f1_4a5cbdcb",
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ee95e4a_f4fc810c",
        "filename": "javatests/com/google/gerrit/server/account/externalids/ExternalIDCacheLoaderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T11:38:22Z",
      "side": 1,
      "message": "should you have a test that creates 15 updates, so we have coverage for the code path where you can\u0027t find the thing?",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e5cd7ec_17a47e05",
        "filename": "javatests/com/google/gerrit/server/account/externalids/ExternalIDCacheLoaderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-25T13:58:08Z",
      "side": 1,
      "message": "This is already there: fallsBackToFullReloadOnManyUpdatesOnBranch\n\nI can add another test where we don\u0027t use the barrier (say 5 updates) but just don\u0027t have an old state cached.",
      "parentUuid": "0ee95e4a_f4fc810c",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "815f06c5_95795cdb",
        "filename": "javatests/com/google/gerrit/server/account/externalids/ExternalIDCacheLoaderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-26T11:27:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8e5cd7ec_17a47e05",
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "db4802d4_7e5abde0",
        "filename": "javatests/com/google/gerrit/server/account/externalids/ExternalIDCacheLoaderTest.java",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-07-25T11:38:22Z",
      "side": 1,
      "message": "insert",
      "range": {
        "startLine": 181,
        "startChar": 24,
        "endLine": 181,
        "endChar": 40
      },
      "revId": "dc8096a0404da81dc379e9a2bf2872faf98c045d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}