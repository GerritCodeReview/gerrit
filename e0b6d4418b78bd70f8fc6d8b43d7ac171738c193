{
  "comments": [
    {
      "key": {
        "uuid": "fcc167c3_0480f6db",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-10-21T01:15:52Z",
      "side": 1,
      "message": "I see where you\u0027re coming from but it feels a little hacky to use this heuristic to see whether the file exists.\n\nIf I\u0027m reading DiffFormatter correctly, the way to tell that the file doesn\u0027t exist is if scan(a, b) returns an empty list.\n\nSo what I would do here is something like:\n\n DiffFormatter fmt \u003d new DiffFormatter(out);\n fmt.setReader(rw.getObjectReader(), repo.getConfig());\n ... other fmt options\n final List\u003cDiffEntry\u003e entries \u003d fmt.scan(base.getTree(), commit.getTree());\n if (path !\u003d null \u0026\u0026 entries.isEmpty()) {\n   throw RNFE\n }\n return new BinaryResult() {\n   ...\n   private void format(OutputStream out) {\n     ...\n     fmt.format(entries);\n     fmt.flush();\n   }\n }\n\nNotes:\n\n * Calling fmt.setReader means that you don\u0027t have to close the DiffFormatter, as the only thing DiffFormatter#close does is close the reader, but it skips that if you had previously called setReader.\n * It may look like this might waste more memory by holding on to a materialized List\u003cDiffEntry\u003e, but it doesn\u0027t. If you look at the implementation of fmt.format on line 112 above, it literally calls format(scan(a, b)), so the current implementation is already materializing the same list.",
      "range": {
        "startLine": 124,
        "startChar": 28,
        "endLine": 124,
        "endChar": 57
      },
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcbe6336_839a1e4b",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1029297
      },
      "writtenOn": "2016-10-21T17:44:21Z",
      "side": 1,
      "message": "I definitely agree that this feels a little bit hacky. \n\nI\u0027m trying to do it the way you write, that seems much better... But I\u0027m not entirely sure that I can do that, because the OutputStream with which the DiffFormatter is created is passed in as a param to writeTo.\n\nIs the correct approach to just throw RNFE inside format? That would require changing the BinaryResult class too.",
      "parentUuid": "fcc167c3_0480f6db",
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c16e7ce9_3a7d6125",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1029297
      },
      "writtenOn": "2016-10-24T18:50:46Z",
      "side": 1,
      "message": "Following up on this... Would a good solution be to do something like this before declaring the BinaryResult, or would having multiple tree walks result in a lot of resource duplication?\n\nhttp://stackoverflow.com/questions/1685228/how-to-cat-a-file-in-jgit",
      "parentUuid": "fcc167c3_0480f6db",
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "010334fc_9ca1257e",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-10-24T21:26:53Z",
      "side": 1,
      "message": "Yeah, good point.\n\n\u003e Is the correct approach to just throw RNFE inside format?\n\nProbably not, since by the time writeTo is called it\u0027s quite likely the response code and headers have been written, so it\u0027s too late.\n\nLet me think for a minute.",
      "parentUuid": "dcbe6336_839a1e4b",
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c16e7ce9_7ac1991c",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-10-24T21:53:28Z",
      "side": 1,
      "message": "I think you have to do some duplicate work, but not much.\n\nWhat you want to do is short-circuit if there is no diff between base and commit for the given path.\n\nThe quickest way to do this in JGit is to construct a non-recursive TreeWalk with a PathFilter, then iterate over both trees and compare the mode and ID of the next entry. This just compares SHA-1s in the trees, it doesn\u0027t do a textual diff, so it\u0027s very fast.\n\nIf the entires are the same, there is no diff and you can throw RNFE; if they\u0027re different, you can proceed to formatting the patch.\n\nThe main downside that I can think of for this approach is if we ever want to implement \"git diff -w\" in this endpoint. Then you would get a false positive for entries that differ only in whitespace.",
      "parentUuid": "010334fc_9ca1257e",
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c16e7ce9_1ac65d36",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/change/GetPatch.java",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-10-24T21:55:09Z",
      "side": 1,
      "message": "One unfortunate thing is that your current implementation *also* does a lot of duplicate work. BinaryResult#asString calls writeTo once to buffer the output, but then throws that buffer away, and the API glue later calls writeTo again. (I guess that could be fixed though.)",
      "parentUuid": "c16e7ce9_7ac1991c",
      "revId": "e0b6d4418b78bd70f8fc6d8b43d7ac171738c193",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}