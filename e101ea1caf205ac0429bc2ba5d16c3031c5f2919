{
  "pushCert": "certificate version 0.1\npusher Dave Borowitz \u003cdborowitz@google.com\u003e 1550078870 -0800\nnonce ANwvRnCzlLgF6zWSigbKmh3QG67lkGQUkuy9JjM68YpRJubN5blKjvkXDQSvqfNXFeSSh8EBLMrM\n\n0000000000000000000000000000000000000000 e52a4a1f0ab1048e03663ff1cb13e33ee8d5e221 refs/for/master\n-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCgAzFiEEpPm/sOxWgSqG5grhX9fFmpoSiIwFAlxkU5YVHGRib3Jvd2l0\nekBnb29nbGUuY29tAAoJEF/XxZqaEoiMrNgQAMHxEeWedsGyjqDY6n4MNWuqg3cO\nCVncb/GO84iagAVsPBihPir9EVwWjHvFC1QbrA9tqSSRPZgP7kwoU3T+XCQBqPqp\nru3utgU5fpz4f1dkbH58UKTrPsl8h9GLAXzW0LZi7ydBcmN5lRp776QWOgFzrbbE\nPssAe9aSgInT5ZpiUPgKsN4XleOYuqkF65N6joOvzrVzsXiqSGwwrwMFiz8eVVpq\n3uT+xuDlK60m/3KLvYkOy1ztDHnvP7QGVZ9upd4+FcfhOjkUdivWx/WoBj8Quz7Y\nhXVgF1nFm6c2ZF/i3hje99uN84iRprgfqUX+6gu4301LOtxZ85sUz2uTs15fqi0/\ny9OluAf4n2i+sQy0EfeJTbAyEkB66RWWaUd4kIwF5IY83ZY3eZfZCWmoPa+H3IbZ\nRCNlh3Pm9Z2o1sZde+KVwtfjVMc2zhSKjTdNFgVeUNsJsWI8/vGlQlJU1Q/jMmH3\nM7yycQIz1EtY++gewmSZ8AuWAqmhVp8xuDl5LaN1SNNHdHIcOViWFx7f/hKz+uAS\ncY18o9nFxdYYBtJLCtVkhOBJmwYYasEqwZO8LpN7FY48v/dodm9W5ixXQK+VwsBg\nRkCagrVgRZjELBkI43JQe/cTTxwyyGDXeHwa3Tdmds81Vs7IGq80hOLORBUccXXs\nyPqiBs4+rNWvah7R\n\u003dWeLq\n-----END PGP SIGNATURE-----\n",
  "comments": [
    {
      "key": {
        "uuid": "c109823f_0435217f",
        "filename": "java/com/google/gerrit/server/restapi/checker/UpdateChecker.java",
        "patchSetId": 6
      },
      "lineNbr": 81,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-02-14T00:12:52Z",
      "side": 1,
      "message": "I feel like we need some additional sanitization here. This should be a valid URL, and it definitely should not be, say, a javascript: URL. I might suggest allowing only http:// and https:// URLs.\n\nAlthough, this raises the larger question of at what level do we want to do input validation. If we only do the validation here as opposed to, say, CheckerConfigEntry, then how sure are we that all callers within Gerrit are using this high-level API? We would not want to accidentally call a low-level API with no validation and accidentally pass it some user-provided input.\n\nWould it make sense to change CheckerConfigEntry#updateConfigValue to possibly throw ConfigInvalidException, and do the validation there? There\u0027s still the question of how to propagate the exception message to turn it into a BadRequestException here, but that problem seems surmountable.",
      "revId": "e101ea1caf205ac0429bc2ba5d16c3031c5f2919",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4dc2d819_b958c403",
        "filename": "java/com/google/gerrit/server/restapi/checker/UpdateChecker.java",
        "patchSetId": 6
      },
      "lineNbr": 81,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-02-14T10:51:04Z",
      "side": 1,
      "message": "\u003e I feel like we need some additional sanitization here. This should be a valid URL,\n\u003e and it definitely should not be, say, a javascript: URL. I might suggest allowing only http://\n\u003e and https:// URLs.\n\nGood point. Do you think it would be enough to ensure that it starts with \"http://\" or \"https://\" and then check if new java.net.URL(url) throws MalformedUrlException?\n\n\u003e Although, this raises the larger question of at what level do we want to do input validation.\n\u003e If we only do the validation here as opposed to, say, CheckerConfigEntry, then how sure are\n\u003e we that all callers within Gerrit are using this high-level API? We would not want to\n\u003e accidentally call a low-level API with no validation and accidentally pass it some user-provided input.\n\nI think at the moment we do this kind of validation only on the high-level API and let the low-level API only care about a consistent format (e.g. don\u0027t write data that we could not load).\n\nBut yes, that\u0027s a valid question.\n\n\u003e Would it make sense to change CheckerConfigEntry#updateConfigValue to possibly throw ConfigInvalidException,\n\u003e and do the validation there? There\u0027s still the question of how to propagate the exception message to turn it\n\u003e into a BadRequestException here, but that problem seems surmountable.\n\nI\u0027m fine with this, but not sure if we want to do this right now or later.",
      "parentUuid": "c109823f_0435217f",
      "revId": "e101ea1caf205ac0429bc2ba5d16c3031c5f2919",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81998ac1_19cab6c2",
        "filename": "java/com/google/gerrit/server/restapi/checker/UpdateChecker.java",
        "patchSetId": 6
      },
      "lineNbr": 81,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-02-14T15:04:43Z",
      "side": 1,
      "message": "\u003e \u003e I feel like we need some additional sanitization here. This should be a valid URL,\n\u003e \u003e and it definitely should not be, say, a javascript: URL. I might suggest allowing only http://\n\u003e \u003e and https:// URLs.\n\u003e \n\u003e Good point. Do you think it would be enough to ensure that it starts with \"http://\" or \"https://\" and then check if new java.net.URL(url) throws MalformedUrlException?\n\nWell if you\u0027re going to parse it, might as well pull the protocol out with a method. But yeah I think running through java.net.URL is good enough.\n\n\u003e \u003e Although, this raises the larger question of at what level do we want to do input validation.\n\u003e \u003e If we only do the validation here as opposed to, say, CheckerConfigEntry, then how sure are\n\u003e \u003e we that all callers within Gerrit are using this high-level API? We would not want to\n\u003e \u003e accidentally call a low-level API with no validation and accidentally pass it some user-provided input.\n\u003e \n\u003e I think at the moment we do this kind of validation only on the high-level API and let the low-level API only care about a consistent format (e.g. don\u0027t write data that we could not load).\n\u003e\n\u003e But yes, that\u0027s a valid question.\n\u003e \n\u003e \u003e Would it make sense to change CheckerConfigEntry#updateConfigValue to possibly throw ConfigInvalidException,\n\u003e \u003e and do the validation there? There\u0027s still the question of how to propagate the exception message to turn it\n\u003e \u003e into a BadRequestException here, but that problem seems surmountable.\n\u003e \n\u003e I\u0027m fine with this, but not sure if we want to do this right now or later.\n\nI\u0027m ok with leaving it at the high level for now.\n\nThe reason I thought of this is that validation of the upcoming query field may be more complicated: it needs to not only be in valid syntax but also use only a subset of fields. Depending on how it\u0027s implemented, we might need a ChangeQueryBuilder for that, which will _not_ be available in CheckerConfigEntry (which is in the wrong package and can\u0027t take inject stuff).",
      "parentUuid": "4dc2d819_b958c403",
      "revId": "e101ea1caf205ac0429bc2ba5d16c3031c5f2919",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0604de06_a5490a71",
        "filename": "java/com/google/gerrit/server/restapi/checker/UpdateChecker.java",
        "patchSetId": 6
      },
      "lineNbr": 81,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2019-02-14T19:13:49Z",
      "side": 1,
      "message": "Done. The logic does need to not live in just this file, because it\u0027s also needed from CreateChecker, so I added a CheckerUrl class analogous to CheckerUuid and so on. The logic is still called only from this high level.",
      "parentUuid": "81998ac1_19cab6c2",
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "e101ea1caf205ac0429bc2ba5d16c3031c5f2919",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}