{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eff8ad5c_ec88d77b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 16,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2024-01-02T16:39:43Z",
      "side": 1,
      "message": "(and presumably before the task has been added to the queue?)",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f7fa5f2_0bc58b05",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 16,
      "author": {
        "id": 1148165
      },
      "writtenOn": "2024-01-03T02:43:22Z",
      "side": 1,
      "message": "The new task is added when the last task is about to end. It\u0027s inside task.run itself. (Which means periodic task add itself back to the queue at the end of execution)\nSo thread B will be blocked before the very ending of `task.run` in thread A",
      "parentUuid": "eff8ad5c_ec88d77b",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a23ef7af_6db4394d",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2024-01-02T16:39:43Z",
      "side": 1,
      "message": "This synchronized now covers quite a bit in here, which means it could block another thread for the duration of this entire method. Now in theory no other thread should ever enter this run() except in the case which you have outlined? If that is true, I wonder why this runningState was even needed, and how it ever helped solve any problem at all (aside from helping output the correct state in the task view)? That being said, now the synchronized in theory will block the \"new\" thread (#2 in your diagram) while the \"old\" thread (#1) cleans up this task, which includes calling executor.onStop() which includes calling all the potential listeners. That may be OK, but it isn\u0027t ideal since some of those could take a while freeing resources. It would be better if somehow the task were not \"re-added\" to the queue until the thread state were set to null again (seems hard to do), or perhaps instead, the thread could be added back to the queue if the \"if\" on line 674 fails?",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c2ae0e5d_f68722b1",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1148165
      },
      "writtenOn": "2024-01-03T02:43:22Z",
      "side": 1,
      "message": "I believe that runningState is specifically defined by Gerrit for the sole purpose of outputting states in ssh gerrit show-queue. When using the JDK native ScheduledFutureTask.scheduleAtFixedRate, there is no equivalent concept of runningState.\n\nI haven\u0027t identified any method to reintroduce a task to the queue when the \"if\" condition fails. This functionality is implemented in a non-public method within the JDK (WorkQueue.Task.run -\u003e ScheduledThreadPoolExecutor.reExecutePeriodic).\n\nThe usage of synchronized (this) exclusively locks the instance of WorkQueue.Task it is applied to. This means that other tasks will not be affected or blocked by this synchronization. I believe this level of locking is sufficiently narrow for performance considerations.",
      "parentUuid": "a23ef7af_6db4394d",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85f95f86_53929db2",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2024-01-03T03:13:52Z",
      "side": 1,
      "message": "\u003e I haven\u0027t identified any method to reintroduce a task to the queue when the \"if\" condition fails. This functionality is implemented in a non-public method within the JDK (WorkQueue.Task.run -\u003e ScheduledThreadPoolExecutor.reExecutePeriodic).\n\nWhat about calling executor.schedule() since we can get the delay using getDelay()? (I\u0027m not sure if that would be enough to reschedule it?)\n\n\u003e The usage of synchronized (this) exclusively locks the instance of WorkQueue.Task it is applied to. This means that other tasks will not be affected or blocked by this synchronization.\n\nThis isn\u0027t accurate. Indirectly, this will block another thread, which will affect and potentially prevent other tasks from starting. Rescheduling would lead to a more \"fair\" approach since it would delay the current task, which has not really completed yet, for another period, which seems appropriate if the \"stopping\"/cleanup isn\u0027t done yet.",
      "parentUuid": "c2ae0e5d_f68722b1",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "acd00e1a_bf9b4d16",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1148165
      },
      "writtenOn": "2024-01-03T07:48:35Z",
      "side": 1,
      "message": "\u003e \u003e I haven\u0027t identified any method to reintroduce a task to the queue when the \"if\" condition fails. This functionality is implemented in a non-public method within the JDK (WorkQueue.Task.run -\u003e ScheduledThreadPoolExecutor.reExecutePeriodic).\n\u003e \n\u003e What about calling executor.schedule() since we can get the delay using getDelay()? (I\u0027m not sure if that would be enough to reschedule it?)\n\u003e \n\n`executor.schedule` is for one time task. I\u0027m not sure if it will work if we used it on a periodic task.\n\n\u003e \u003e The usage of synchronized (this) exclusively locks the instance of WorkQueue.Task it is applied to. This means that other tasks will not be affected or blocked by this synchronization.\n\u003e \n\u003e This isn\u0027t accurate. Indirectly, this will block another thread, which will affect and potentially prevent other tasks from starting. Rescheduling would lead to a more \"fair\" approach since it would delay the current task, which has not really completed yet, for another period, which seems appropriate if the \"stopping\"/cleanup isn\u0027t done yet.\n\nI don\u0027t quite get it. `this` pointer points to the user defined task. And there is only one running task at a time per user-defined task. If there are other user defined tasks, they don\u0027t affect each other.\nIf another thread retreive the task from queue but find it\u0027s running, this is the only situation.\nWould mind giving me an example about how can this code block other threads? I can try to do an experiment.",
      "parentUuid": "85f95f86_53929db2",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72e33ed4_a0d23b8c",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1148165
      },
      "writtenOn": "2024-01-03T12:01:28Z",
      "side": 1,
      "message": "Let\u0027s break down this code.\nEvery call of WorkQueue.scheduleAtFixedRate create a WorkQueue.Task instance.\nLet\u0027s assume we call WorkQueue.scheduleAtFixedRate once, and there is a WorkQueue.Task instance A being added to the queue\n\nThe thread is:\n1. Enter into a infinite While loop to test if any WorkQueue.Task is in the queue.\n2. If so, retreive instance A from the queue.\n3. Run WorkQueue.Task.run\n4. check if runningState is null and then set it to STARTING\n5. Run RunnableScheduledFuture.run (task.run)\n    a. run the actual user defined Runnable\n    b. after execution, add the WorkQueue.Task instance A back to the queue.\n6. Set `runningState` to `null`\n\nAs we can see. Theoretically there is only one `instance A`.`run` is executed. Unless thread B preempt thread A between step 5.b and step 6.\nHowever even in this race condition, at most there are only 2 threads runs `WorkQueue.Task instance A`.`run`. In this case synchronized(this) uses spinlock. The performance should be fine\n\nAnd if `scheduleAtFixedRate` is called more than once, there will be other WorkQueue.Task instances. However they\u0027re not affected because synchronized only lock instance A",
      "parentUuid": "acd00e1a_bf9b4d16",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f2f96f8_7f5793d0",
        "filename": "java/com/google/gerrit/server/git/WorkQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 673,
      "author": {
        "id": 1010013
      },
      "writtenOn": "2024-01-03T21:21:27Z",
      "side": 1,
      "message": "\u003e 5. Run RunnableScheduledFuture.run (task.run)\n\u003e     a. run the actual user defined Runnable\n\u003e     b. after execution, add the WorkQueue.Task instance A back to the queue.\n\u003e 6. Set `runningState` to `null`\n\u003e \n\u003e As we can see. Theoretically there is only one `instance A`.`run` is executed. Unless thread B preempt thread A between step 5.b and step 6.\n\u003e However even in this race condition, at most there are only 2 threads runs `WorkQueue.Task instance A`.`run`. In this case synchronized(this) uses spinlock. The performance should be fine\n\nThere are other steps between 5.b and 6, it runs executor.stop() also, and that calls onStop() on all the registered TaskListeners. Imagine a workqueue with only 2 threads, execution.defaultThreadPoolSize for background threads (likely where you are seeing this issue?) defaults to 2. If thread B does what you say while thread A is calling all the registered listeners, then thread B will be blocked until all the listeners complete, and then all the other tasks in the queue will be blocked also since they are waiting for thread A or B to complete. The reason that queue is set to 2 threads is to avoid this kind of blockage.\n\nIf you want to test this, leave the default queue set to 2, and install a test plugin which registers an WorkQueue.TaskListener (see https://gerrit-review.googlesource.com/Documentation/dev-plugins.html#taskListeners) whose onStop() method has a long sleep in it. If you can reliably trigger thread B to get blocked between steps 5.b and 6 and before the executor.stop() method is called, then I believe it will block all other waiting tasks while the onStop() method is sleeping. To notice this blockage, you will need a backlog of other background tasks in the queue waiting to complete so that you can observe them waiting during the sleep (your test plugin could generate those if needed). This might be tricky to do since thread B is unlikely to be running the same scheduled Task as thread A if there are other blocked tasks in the queue.",
      "parentUuid": "72e33ed4_a0d23b8c",
      "revId": "e1d6f2df99e56bccccc44269a55e0a56bccbe324",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}