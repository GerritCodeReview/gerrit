{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "93be3230_e8bd040b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-02T14:09:49Z",
      "side": 1,
      "message": "Add \"Bug: Issue 13337\" footer",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7816625b_99adda56",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-02T14:18:22Z",
      "side": 1,
      "message": "Er, sorry: \"Feature: Issue 13337\"",
      "parentUuid": "93be3230_e8bd040b",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a84b042b_42accf81",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-08T15:03:10Z",
      "side": 1,
      "message": "I\u0027m sorry, but I\u0027m going to have to -2 this.\n\nThere are several reasons outlined in earlier comments. Let me summarize them again:\n\n* We don\u0027t have proper UI support for autocompletion, and indeed, I think you can’t even enter nested queries properly (how would you issue a query where the inner query uses a \" ?). \n\n* If we could nest queries, this would lead to a potential fan-out of queries (peers:”peers:\\” ... ), where one incoming query leads to multiple outgoing queries. This is a potential DOS vector for public instances, in particular, the googlesource deployment.\n\n* We carry the pager for this service. We can’t afford to address performance problems when they happen, because “happen” means a fire drill where our servers fall over. We also have latency SLOs for our service, which are hard to satisfy with a nested operator like this. Even for deployments without pager duties, having predictable latency on search queries is a valuable property. (Predictable latency is the prime reason why we have disabled the conflicts: operator on googlesource.com as well)\n\n* The feature seems very specific to a certain CI system, in a waterfall-like setting (where changes get cherry-picked across branches?). If we build a query operator that looks specifically like this, at a minimum, we\u0027d want to see evidence that this use-case is much more widespread than just this system at Qualcomm.\n\n* The feature is introducing a very specific form of joining results. If we go down this route, I think we should rather think about the query system holistically and provide a more generic join functionality, that allows joining on other keys. In this case, we should also build infrastructure to limit the fan-out of an incoming query, and to limit the amount of CPU time spent on answering a single query. \n\nAs a practical way out of this, we can commit to help you extend the support for plugin-provided predicates to they can take arguments. Then you can implement a ‘peers’ operator from a plugin. How does that sound?\n",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8f03bb8_0d8ff0c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-08T21:13:44Z",
      "side": 1,
      "message": "\u003e I\u0027m sorry, but I\u0027m going to have to -2 this.\n\u003e \n\u003e There are several reasons outlined in earlier comments. Let me summarize them again:\n\nThanks for this summary. It really helps!\n\n\u003e \n\u003e * We don\u0027t have proper UI support for autocompletion, and indeed, I think you can’t even enter nested queries properly (how would you issue a query where the inner query uses a \" ?). \n\nWe\u0027ll look into that, but I think using {} instead of \"\" helps with that issue.\nhttps://gerrit-review.googlesource.com/Documentation/user-search.html#_argument_quoting\n\n\u003e \n\u003e * If we could nest queries, this would lead to a potential fan-out of queries (peers:”peers:\\” ... ), where one incoming query leads to multiple outgoing queries. This is a potential DOS vector for public instances, in particular, the googlesource deployment.\n\nWe could limiting nesting to a single (or other fixed/configurable number) of sub queries. Would that address this concern?\n\n\u003e \n\u003e * We carry the pager for this service. We can’t afford to address performance problems when they happen, because “happen” means a fire drill where our servers fall over. We also have latency SLOs for our service, which are hard to satisfy with a nested operator like this. Even for deployments without pager duties, having predictable latency on search queries is a valuable property. (Predictable latency is the prime reason why we have disabled the conflicts: operator on googlesource.com as well)\n\nI don\u0027t believe the Gerrit project (i.e. open source community Gerrit) provides predictable latency on search queries. If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\n\u003e \n\u003e * The feature seems very specific to a certain CI system, in a waterfall-like setting (where changes get cherry-picked across branches?). If we build a query operator that looks specifically like this, at a minimum, we\u0027d want to see evidence that this use-case is much more widespread than just this system at Qualcomm.\n\nI think this feature is applicable to anyone looking for cherry-picks. Gerrit provides a cherry-pick feature, this operator makes those cherry-picks more discoverable. Yes, Qualcomm has CI systems (plural) that use this. I don\u0027t think it\u0027s a fair (or documented) criteria for a core change to say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\n\u003e \n\u003e * The feature is introducing a very specific form of joining results. If we go down this route, I think we should rather think about the query system holistically and provide a more generic join functionality, that allows joining on other keys. In this case, we should also build infrastructure to limit the fan-out of an incoming query, and to limit the amount of CPU time spent on answering a single query. \n\nJoining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\n\u003e \n\u003e As a practical way out of this, we can commit to help you extend the support for plugin-provided predicates to they can take arguments. Then you can implement a ‘peers’ operator from a plugin. How does that sound?\n\nPlugins don\u0027t need core support to do that already (we have existing plugins that do this). It\u0027s not relevant though as this change is intended to get the feature into core. We know we can do this in a plugin, but since we see broader value, we want to understand what it will take to get this into core.",
      "parentUuid": "a84b042b_42accf81",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "723f7a24_25552a12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-09T16:50:42Z",
      "side": 1,
      "message": "\nI\u0027ll be out next week, so further responses will be delayed.",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f02da33_99858682",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-09T16:50:42Z",
      "side": 1,
      "message": "\u003e Joining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\nSuch as?\n\n\u003e say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\nif this were a regular index feature (eg. adding a new field) we wouldn\u0027t have that many concerns. But this making more fundamental changes, so we want to be extra careful.\n\n\u003e If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\nthis is a measure of last resort; we\u0027d rather see core gerrit be the same everywhere.",
      "parentUuid": "e8f03bb8_0d8ff0c7",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6b425b7_6896c029",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-12T20:42:59Z",
      "side": 1,
      "message": "\u003e \u003e Joining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\u003e \n\u003e Such as?\n\nI\u0027m not claiming this is the complete set; however, I think \"ownerin:\", \"reviewerin:\", \"commit:\", \"label:\", \"has:draft\", \"is:watched\", \"is:reviewed\" and \"has:star\", still do something equivalent to a join. I could definitely be wrong about that, especially if I missed some preloading we do with ChangeDatas (we seem to for query output, but not during queries AFAICT).\n\nOften making joins fast comes down to picking the appropriate ChangeDataSource for the query. We can look at implementing that for peers (we\u0027ve done that internally) in a follow up change. Would that help?\n\n\u003e \n\u003e \u003e say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\u003e \n\u003e if this were a regular index feature (eg. adding a new field) we wouldn\u0027t have that many concerns. But this making more fundamental changes, so we want to be extra careful.\n\nWe\u0027re comfortable with \"extra careful\". What are you looking for to gain confidence in this change?\n\n\u003e \n\u003e \u003e If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\u003e \n\u003e this is a measure of last resort; we\u0027d rather see core gerrit be the same everywhere.\n\nWe would too, hopefully we can find a way to make that happen with this change. We\u0027ve been using this feature (albeit on a non-public facing server and with it as a ChangeDataSource) for 5 years without any issues. I think we can work together to find some ways to make it safer for you.",
      "parentUuid": "8f02da33_99858682",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66d2ebd9_374bc410",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-14T09:43:41Z",
      "side": 1,
      "message": "has:draft, label:, is:watched etc. aren\u0027t the same thing: They all just require a single round trip to the index whereas peers would require n round trips where n depends on the number of results in the sub-query.\n\nYou could try to batch queries together after retrieving the initial set (is:id1 OR id:id2) but there is also a maximum number of terms allowed depending on which index backend is used.",
      "parentUuid": "c6b425b7_6896c029",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ba14afc_a6f457f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-14T16:47:36Z",
      "side": 1,
      "message": "\u003e has:draft, label:, is:watched etc. aren\u0027t the same thing: They all just require a single round trip to the index whereas peers would require n round trips where n depends on the number of results in the sub-query.\n\nPre-Lucene those all were multiple round trips to the database (and since we\u0027re running 2.7 still, they continue to be so for us). Yes, having the index is nice and helps us avoid that most of the time. I don\u0027t think it should preclude features that do rely on more than a single round trip. Different operators can have different performance.\n\n\u003e \n\u003e You could try to batch queries together after retrieving the initial set (is:id1 OR id:id2) but there is also a maximum number of terms allowed depending on which index backend is used.",
      "parentUuid": "66d2ebd9_374bc410",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0342f3b_3e67c9b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-29T17:39:16Z",
      "side": 1,
      "message": "Han-Wen, I think you\u0027re back, can you PTAL?",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0afc2e6_714061e8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-11-03T09:39:01Z",
      "side": 1,
      "message": "I don\u0027t quite understand. In version without a change index, how would has:draft has caused n database lookups when serving n changes? How did the lookup work?",
      "parentUuid": "3ba14afc_a6f457f5",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1609af95_15021442",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-11-03T09:39:01Z",
      "side": 1,
      "message": "Han-Wen is actually out again :-)\n\nHere is my $0.02: We feel strongly about not having this operator on the instances that we maintain (aka googlesource.com) because of the performance and stability concern that Han-Wen cited. For Gerrit as a product, my personal opinion is that it should also rather not support this operator, because the use case is very specific and mainly targeting CI and other bots who could easily just implement this client-side. On top comes the poor support for nested queries in the Gerrit UI (that you could of course fix).\n\nThat doesn\u0027t necessarily prevent you from adding it to Gerrit (e.g. gating it by a config option). I think if there is interest in the community in this operator or at least the concerns that we voiced aren\u0027t shared, I\u0027d say you can add it if there\u0027s a way to disable it with a config.\n\nI\u0027ve added Luca, Saša and Sven for an opinion on this.",
      "parentUuid": "f0342f3b_3e67c9b6",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e422736f_b05190e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-11-03T15:18:34Z",
      "side": 1,
      "message": "\u003e Han-Wen is actually out again :-)\n\nThanks for letting us know. :)\n\n\u003e \n\u003e Here is my $0.02: We feel strongly about not having this operator on the instances that we maintain (aka googlesource.com) because of the performance and stability concern that Han-Wen cited. For Gerrit as a product, my personal opinion is that it should also rather not support this operator, because the use case is very specific and mainly targeting CI and other bots who could easily just implement this client-side. On top comes the poor support for nested queries in the Gerrit UI (that you could of course fix).\n\nWhile callers could implement this client side, that forces all clients to reimplement the same logic. It also means you can\u0027t use it as a task query in the task plugin.\n\n\u003e \n\u003e That doesn\u0027t necessarily prevent you from adding it to Gerrit (e.g. gating it by a config option). I think if there is interest in the community in this operator or at least the concerns that we voiced aren\u0027t shared, I\u0027d say you can add it if there\u0027s a way to disable it with a config.\n\u003e \n\u003e I\u0027ve added Luca, Saša and Sven for an opinion on this.\n\nThanks. I\u0027m curious if others have use cases for tracking propagation of changes across branches. I assumed this was a pretty common use case, but perhaps our internal branching is more extreme than others.",
      "parentUuid": "1609af95_15021442",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0192619_fa25da08",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-11-03T15:18:34Z",
      "side": 1,
      "message": "\u003e I don\u0027t quite understand. In version without a change index, how would has:draft has caused n database lookups when serving n changes? How did the lookup work?\n\nAll of these queries involved tables that were not the \u0027changes\u0027 table. gwtorm didn\u0027t do joins, so it would either use \u0027changes\u0027 as the source and then do lookups in the respective table, or use a different table (\u0027patch_comments\u0027 in the case of has:draft) as the source (the original idea of an operator implementing ChangeDataSource) and then lookup each change in \u0027changes\u0027 for the additional data.",
      "parentUuid": "f0afc2e6_714061e8",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3792f339_c39137c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1014252
      },
      "writtenOn": "2020-11-04T08:47:54Z",
      "side": 1,
      "message": "I double-checked with our CI team and our CI system has it\u0027s own data-structure (handled by the CI system itself) to determine which changes should be submitted together and wouldn\u0027t be assisted by this feature at all.\n\nThis leaves me with my personal opinion and I agree with Han-Wen\u0027s and Patrick\u0027s analysis.\nIt brings a lot of complexity and potential performance issues for a rather narrow use-case.\nIf you ask me, I think this should be in a plugin.",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "821ae05d_461809e5",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-05T10:11:44Z",
      "side": 1,
      "message": "Do you have users that need this functionality or is it bots that call Gerrit and want to resolve more changes?",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04e5d4b7_a35d75cb",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-05T19:14:42Z",
      "side": 1,
      "message": "Yes currently we have users that make use of this functionality in our gerrit version (forked from 2.7 version). Use cases for UX is low but primarily this functionality is used by the CI system.",
      "parentUuid": "821ae05d_461809e5",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d54ff290_a9bd9c6b",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-06T15:55:20Z",
      "side": 1,
      "message": "\u003e Use cases for UX is low but primarily this functionality is used by the CI system.\n\nIf the caller is a bot and human UI users aren\u0027t the concern, then I would really try to not implement this in Gerrit. It seems simpler to just have your CI resolve that by sending a second query.\n\nAny CI/bot you look at has workflows similar to this one where we could combine two requests inside Gerrit, but the bot can also just send a second request to resolve something. For some cases, I wouldn\u0027t worry much if we resolved things in Gerrit, but here we\u0027d be exposing sub-queries, so we have to parse the query twice, make sure the UI knows about nested queries and be mindful of the computational complexity.\n\nIf you absolutely need this to be implemented in Gerrit, we could expand the plugin infrastructure to allow for predicates to be exposed from plugins that also take an argument. You can already expose predicates from plugins (e.g. is:myPredicate_myPlugin) but IIRC they can\u0027t take arguments right now.",
      "parentUuid": "04e5d4b7_a35d75cb",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "342ae010_49ea59b5",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-06T18:53:28Z",
      "side": 1,
      "message": "\u003e \u003e Use cases for UX is low but primarily this functionality is used by the CI system.\n\u003e \n\u003e If the caller is a bot and human UI users aren\u0027t the concern, then I would really try to not implement this in Gerrit. It seems simpler to just have your CI resolve that by sending a second query.\n\u003e \nCertainly CI can do 2 queries but I think its a good utility that we\u0027ve had internally for a while and working well. To have it in Gerrit is more logical and will be beneficial for one and all rather than having every CI system implement on its own.\n\n\u003e Any CI/bot you look at has workflows similar to this one where we could combine two requests inside Gerrit, but the bot can also just send a second request to resolve something. For some cases, I wouldn\u0027t worry much if we resolved things in Gerrit, but here we\u0027d be exposing sub-queries, so we have to parse the query twice, make sure the UI knows about nested queries and be mindful of the computational complexity.\n\u003e \nI think it\u0027s better to solve such things in Gerrit. Having 2 request right away will likely put the same load on server as 2 back to back requests or may be less. We can surely follow up with performance improvements if there are concerns around that. This UI works well for us, welcome any suggestions on ways to improve it.\n\n\u003e If you absolutely need this to be implemented in Gerrit, we could expand the plugin infrastructure to allow for predicates to be exposed from plugins that also take an argument. You can already expose predicates from plugins (e.g. is:myPredicate_myPlugin) but IIRC they can\u0027t take arguments right now\nSurely this can be implemented in plugin but I think its a useful utility to have in Gerrit that can benefit all",
      "parentUuid": "d54ff290_a9bd9c6b",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "342f3577_b2ad3b5b",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 598,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-05T10:11:44Z",
      "side": 1,
      "message": "This is adding nested queries to change search, which I would really like to avoid. Maybe there is a solution to your problem that doesn\u0027t require nested queries. Would be good to learn about the context/background for that.\n\nNested queries make the query language more complex and add computational complexity as well. Besides, there are UX drawbacks. For example, the UI suggests predicates in the search field, but wouldn\u0027t suggest them for nested queries.",
      "range": {
        "startLine": 598,
        "startChar": 8,
        "endLine": 598,
        "endChar": 35
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f7db0a9_5aa85a45",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 598,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-05T19:14:42Z",
      "side": 1,
      "message": "\u003e This is adding nested queries to change search, which I would really like to avoid. Maybe there is a solution to your problem that doesn\u0027t require nested queries. Would be good to learn about the context/background for that.\n\nPrimary use case for our users is to identify the changes that can be integrated only if they don\u0027t have same Change-Id as that of changes that matches a particular criteria (query). A simple e.g. If user wants to filter the changes for integration that are only present in branch \u0027foo\u0027 but not present in branch \u0027bar\u0027 and there are changes being shared between branch foo and bar.\nDo you have an idea for another way to make it work for given use case?",
      "parentUuid": "342f3577_b2ad3b5b",
      "range": {
        "startLine": 598,
        "startChar": 8,
        "endLine": 598,
        "endChar": 35
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ea5ac8a_103363ae",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-05T09:58:47Z",
      "side": 1,
      "message": "Isn\u0027t this potentially quadratic?",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c48850a_3d315dbf",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-06T06:31:22Z",
      "side": 1,
      "message": "Yes it is for the use case I am trying to address. Do you see any downsides?",
      "parentUuid": "4ea5ac8a_103363ae",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63d49bf8_ee04f864",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-06T11:00:43Z",
      "side": 1,
      "message": "It means that random users can wedge individual servers down by simply executing a query that returns a lot of results repeatedly, like\n\n status:merged peers:\"status:merged\" \n\nit\u0027s also unclear in your implementation how often the search backend is actually called to produce the list for the subquery. If it is called N times, then a single query could exhaust search backend quota, bringing the entire service down across all our tenants.\n\nI would expect it to work like:\n\n * get subquery results, put ChangeIds in a HashSet\u003cString\u003e once\n * post-filter by checking HashSet\u003c\u003e membership, which is O(1).\n\nThese are technical concerns, btw. I agree with Patrick; we don\u0027t currently do joins in the search backend, and I\u0027d rather keep it that way for service stability and predictability.",
      "parentUuid": "0c48850a_3d315dbf",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}