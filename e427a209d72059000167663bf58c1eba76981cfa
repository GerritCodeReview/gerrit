{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "93be3230_e8bd040b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-02T14:09:49Z",
      "side": 1,
      "message": "Add \"Bug: Issue 13337\" footer",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7816625b_99adda56",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-02T14:18:22Z",
      "side": 1,
      "message": "Er, sorry: \"Feature: Issue 13337\"",
      "parentUuid": "93be3230_e8bd040b",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a84b042b_42accf81",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-08T15:03:10Z",
      "side": 1,
      "message": "I\u0027m sorry, but I\u0027m going to have to -2 this.\n\nThere are several reasons outlined in earlier comments. Let me summarize them again:\n\n* We don\u0027t have proper UI support for autocompletion, and indeed, I think you can’t even enter nested queries properly (how would you issue a query where the inner query uses a \" ?). \n\n* If we could nest queries, this would lead to a potential fan-out of queries (peers:”peers:\\” ... ), where one incoming query leads to multiple outgoing queries. This is a potential DOS vector for public instances, in particular, the googlesource deployment.\n\n* We carry the pager for this service. We can’t afford to address performance problems when they happen, because “happen” means a fire drill where our servers fall over. We also have latency SLOs for our service, which are hard to satisfy with a nested operator like this. Even for deployments without pager duties, having predictable latency on search queries is a valuable property. (Predictable latency is the prime reason why we have disabled the conflicts: operator on googlesource.com as well)\n\n* The feature seems very specific to a certain CI system, in a waterfall-like setting (where changes get cherry-picked across branches?). If we build a query operator that looks specifically like this, at a minimum, we\u0027d want to see evidence that this use-case is much more widespread than just this system at Qualcomm.\n\n* The feature is introducing a very specific form of joining results. If we go down this route, I think we should rather think about the query system holistically and provide a more generic join functionality, that allows joining on other keys. In this case, we should also build infrastructure to limit the fan-out of an incoming query, and to limit the amount of CPU time spent on answering a single query. \n\nAs a practical way out of this, we can commit to help you extend the support for plugin-provided predicates to they can take arguments. Then you can implement a ‘peers’ operator from a plugin. How does that sound?\n",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8f03bb8_0d8ff0c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-08T21:13:44Z",
      "side": 1,
      "message": "\u003e I\u0027m sorry, but I\u0027m going to have to -2 this.\n\u003e \n\u003e There are several reasons outlined in earlier comments. Let me summarize them again:\n\nThanks for this summary. It really helps!\n\n\u003e \n\u003e * We don\u0027t have proper UI support for autocompletion, and indeed, I think you can’t even enter nested queries properly (how would you issue a query where the inner query uses a \" ?). \n\nWe\u0027ll look into that, but I think using {} instead of \"\" helps with that issue.\nhttps://gerrit-review.googlesource.com/Documentation/user-search.html#_argument_quoting\n\n\u003e \n\u003e * If we could nest queries, this would lead to a potential fan-out of queries (peers:”peers:\\” ... ), where one incoming query leads to multiple outgoing queries. This is a potential DOS vector for public instances, in particular, the googlesource deployment.\n\nWe could limiting nesting to a single (or other fixed/configurable number) of sub queries. Would that address this concern?\n\n\u003e \n\u003e * We carry the pager for this service. We can’t afford to address performance problems when they happen, because “happen” means a fire drill where our servers fall over. We also have latency SLOs for our service, which are hard to satisfy with a nested operator like this. Even for deployments without pager duties, having predictable latency on search queries is a valuable property. (Predictable latency is the prime reason why we have disabled the conflicts: operator on googlesource.com as well)\n\nI don\u0027t believe the Gerrit project (i.e. open source community Gerrit) provides predictable latency on search queries. If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\n\u003e \n\u003e * The feature seems very specific to a certain CI system, in a waterfall-like setting (where changes get cherry-picked across branches?). If we build a query operator that looks specifically like this, at a minimum, we\u0027d want to see evidence that this use-case is much more widespread than just this system at Qualcomm.\n\nI think this feature is applicable to anyone looking for cherry-picks. Gerrit provides a cherry-pick feature, this operator makes those cherry-picks more discoverable. Yes, Qualcomm has CI systems (plural) that use this. I don\u0027t think it\u0027s a fair (or documented) criteria for a core change to say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\n\u003e \n\u003e * The feature is introducing a very specific form of joining results. If we go down this route, I think we should rather think about the query system holistically and provide a more generic join functionality, that allows joining on other keys. In this case, we should also build infrastructure to limit the fan-out of an incoming query, and to limit the amount of CPU time spent on answering a single query. \n\nJoining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\n\u003e \n\u003e As a practical way out of this, we can commit to help you extend the support for plugin-provided predicates to they can take arguments. Then you can implement a ‘peers’ operator from a plugin. How does that sound?\n\nPlugins don\u0027t need core support to do that already (we have existing plugins that do this). It\u0027s not relevant though as this change is intended to get the feature into core. We know we can do this in a plugin, but since we see broader value, we want to understand what it will take to get this into core.",
      "parentUuid": "a84b042b_42accf81",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "723f7a24_25552a12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-09T16:50:42Z",
      "side": 1,
      "message": "\nI\u0027ll be out next week, so further responses will be delayed.",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f02da33_99858682",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-09T16:50:42Z",
      "side": 1,
      "message": "\u003e Joining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\nSuch as?\n\n\u003e say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\nif this were a regular index feature (eg. adding a new field) we wouldn\u0027t have that many concerns. But this making more fundamental changes, so we want to be extra careful.\n\n\u003e If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\nthis is a measure of last resort; we\u0027d rather see core gerrit be the same everywhere.",
      "parentUuid": "e8f03bb8_0d8ff0c7",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6b425b7_6896c029",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-10-12T20:42:59Z",
      "side": 1,
      "message": "\u003e \u003e Joining results is not a new thing for Gerrit queries. There have been many instances of it in the past.\n\u003e \n\u003e Such as?\n\nI\u0027m not claiming this is the complete set; however, I think \"ownerin:\", \"reviewerin:\", \"commit:\", \"label:\", \"has:draft\", \"is:watched\", \"is:reviewed\" and \"has:star\", still do something equivalent to a join. I could definitely be wrong about that, especially if I missed some preloading we do with ChangeDatas (we seem to for query output, but not during queries AFAICT).\n\nOften making joins fast comes down to picking the appropriate ChangeDataSource for the query. We can look at implementing that for peers (we\u0027ve done that internally) in a follow up change. Would that help?\n\n\u003e \n\u003e \u003e say that use-cases are as widespread as you request here. Do you believe this is a general policy that the project should be (or already is) applying to changes?\n\u003e \n\u003e if this were a regular index feature (eg. adding a new field) we wouldn\u0027t have that many concerns. But this making more fundamental changes, so we want to be extra careful.\n\nWe\u0027re comfortable with \"extra careful\". What are you looking for to gain confidence in this change?\n\n\u003e \n\u003e \u003e If this becomes the only remaining concern, perhaps it would make sense for you to disable this on googlesource.com servers too.\n\u003e \n\u003e this is a measure of last resort; we\u0027d rather see core gerrit be the same everywhere.\n\nWe would too, hopefully we can find a way to make that happen with this change. We\u0027ve been using this feature (albeit on a non-public facing server and with it as a ChangeDataSource) for 5 years without any issues. I think we can work together to find some ways to make it safer for you.",
      "parentUuid": "8f02da33_99858682",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "821ae05d_461809e5",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-05T10:11:44Z",
      "side": 1,
      "message": "Do you have users that need this functionality or is it bots that call Gerrit and want to resolve more changes?",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04e5d4b7_a35d75cb",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-05T19:14:42Z",
      "side": 1,
      "message": "Yes currently we have users that make use of this functionality in our gerrit version (forked from 2.7 version). Use cases for UX is low but primarily this functionality is used by the CI system.",
      "parentUuid": "821ae05d_461809e5",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d54ff290_a9bd9c6b",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-06T15:55:20Z",
      "side": 1,
      "message": "\u003e Use cases for UX is low but primarily this functionality is used by the CI system.\n\nIf the caller is a bot and human UI users aren\u0027t the concern, then I would really try to not implement this in Gerrit. It seems simpler to just have your CI resolve that by sending a second query.\n\nAny CI/bot you look at has workflows similar to this one where we could combine two requests inside Gerrit, but the bot can also just send a second request to resolve something. For some cases, I wouldn\u0027t worry much if we resolved things in Gerrit, but here we\u0027d be exposing sub-queries, so we have to parse the query twice, make sure the UI knows about nested queries and be mindful of the computational complexity.\n\nIf you absolutely need this to be implemented in Gerrit, we could expand the plugin infrastructure to allow for predicates to be exposed from plugins that also take an argument. You can already expose predicates from plugins (e.g. is:myPredicate_myPlugin) but IIRC they can\u0027t take arguments right now.",
      "parentUuid": "04e5d4b7_a35d75cb",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "342ae010_49ea59b5",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-06T18:53:28Z",
      "side": 1,
      "message": "\u003e \u003e Use cases for UX is low but primarily this functionality is used by the CI system.\n\u003e \n\u003e If the caller is a bot and human UI users aren\u0027t the concern, then I would really try to not implement this in Gerrit. It seems simpler to just have your CI resolve that by sending a second query.\n\u003e \nCertainly CI can do 2 queries but I think its a good utility that we\u0027ve had internally for a while and working well. To have it in Gerrit is more logical and will be beneficial for one and all rather than having every CI system implement on its own.\n\n\u003e Any CI/bot you look at has workflows similar to this one where we could combine two requests inside Gerrit, but the bot can also just send a second request to resolve something. For some cases, I wouldn\u0027t worry much if we resolved things in Gerrit, but here we\u0027d be exposing sub-queries, so we have to parse the query twice, make sure the UI knows about nested queries and be mindful of the computational complexity.\n\u003e \nI think it\u0027s better to solve such things in Gerrit. Having 2 request right away will likely put the same load on server as 2 back to back requests or may be less. We can surely follow up with performance improvements if there are concerns around that. This UI works well for us, welcome any suggestions on ways to improve it.\n\n\u003e If you absolutely need this to be implemented in Gerrit, we could expand the plugin infrastructure to allow for predicates to be exposed from plugins that also take an argument. You can already expose predicates from plugins (e.g. is:myPredicate_myPlugin) but IIRC they can\u0027t take arguments right now\nSurely this can be implemented in plugin but I think its a useful utility to have in Gerrit that can benefit all",
      "parentUuid": "d54ff290_a9bd9c6b",
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "342f3577_b2ad3b5b",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 598,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2020-10-05T10:11:44Z",
      "side": 1,
      "message": "This is adding nested queries to change search, which I would really like to avoid. Maybe there is a solution to your problem that doesn\u0027t require nested queries. Would be good to learn about the context/background for that.\n\nNested queries make the query language more complex and add computational complexity as well. Besides, there are UX drawbacks. For example, the UI suggests predicates in the search field, but wouldn\u0027t suggest them for nested queries.",
      "range": {
        "startLine": 598,
        "startChar": 8,
        "endLine": 598,
        "endChar": 35
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f7db0a9_5aa85a45",
        "filename": "Documentation/user-search.txt",
        "patchSetId": 2
      },
      "lineNbr": 598,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-05T19:14:42Z",
      "side": 1,
      "message": "\u003e This is adding nested queries to change search, which I would really like to avoid. Maybe there is a solution to your problem that doesn\u0027t require nested queries. Would be good to learn about the context/background for that.\n\nPrimary use case for our users is to identify the changes that can be integrated only if they don\u0027t have same Change-Id as that of changes that matches a particular criteria (query). A simple e.g. If user wants to filter the changes for integration that are only present in branch \u0027foo\u0027 but not present in branch \u0027bar\u0027 and there are changes being shared between branch foo and bar.\nDo you have an idea for another way to make it work for given use case?",
      "parentUuid": "342f3577_b2ad3b5b",
      "range": {
        "startLine": 598,
        "startChar": 8,
        "endLine": 598,
        "endChar": 35
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ea5ac8a_103363ae",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-05T09:58:47Z",
      "side": 1,
      "message": "Isn\u0027t this potentially quadratic?",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c48850a_3d315dbf",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1096249
      },
      "writtenOn": "2020-10-06T06:31:22Z",
      "side": 1,
      "message": "Yes it is for the use case I am trying to address. Do you see any downsides?",
      "parentUuid": "4ea5ac8a_103363ae",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63d49bf8_ee04f864",
        "filename": "java/com/google/gerrit/server/query/change/PeersPredicate.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-06T11:00:43Z",
      "side": 1,
      "message": "It means that random users can wedge individual servers down by simply executing a query that returns a lot of results repeatedly, like\n\n status:merged peers:\"status:merged\" \n\nit\u0027s also unclear in your implementation how often the search backend is actually called to produce the list for the subquery. If it is called N times, then a single query could exhaust search backend quota, bringing the entire service down across all our tenants.\n\nI would expect it to work like:\n\n * get subquery results, put ChangeIds in a HashSet\u003cString\u003e once\n * post-filter by checking HashSet\u003c\u003e membership, which is O(1).\n\nThese are technical concerns, btw. I agree with Patrick; we don\u0027t currently do joins in the search backend, and I\u0027d rather keep it that way for service stability and predictability.",
      "parentUuid": "0c48850a_3d315dbf",
      "range": {
        "startLine": 43,
        "startChar": 9,
        "endLine": 43,
        "endChar": 17
      },
      "revId": "e427a209d72059000167663bf58c1eba76981cfa",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}