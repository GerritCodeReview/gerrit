{
  "comments": [
    {
      "key": {
        "uuid": "c905acff_7c85391b",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/notedb/ChangeRebuilderImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-06-16T15:05:22Z",
      "side": 1,
      "message": "oldNoteDbState can be null, fixed.",
      "revId": "e4f14be70656caaf55d46d3e42abff5f9bc11cdc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4fa29cc0_20a26ab0",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/notedb/ChangeRebuilderImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 194,
      "author": {
        "id": 1001240
      },
      "writtenOn": "2016-06-11T07:24:51Z",
      "side": 1,
      "message": "This may still be a race in the caller chain. ChangeNotes assumes the meta ObjectId is valid, but it might not be if we are racing with someone else who has updated the database but has not finished flushing the objects and making them available to this thread.\n\nI didn\u0027t see it when I wrote this commit. We may still want to do something like this to reduce the risk of concurrency failures on the database, but we may have to make the caller more resilient to newState being confusing for a short time during the race.",
      "revId": "e4f14be70656caaf55d46d3e42abff5f9bc11cdc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "141b5db9_e6a39eb3",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/notedb/ChangeRebuilderImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 194,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-06-14T16:24:11Z",
      "side": 1,
      "message": "Yep, you can\u0027t avoid races, you can only try to short-circuit the work that will cause extra contention.\n\nStepping back, the problem with the current approach is when we see that the state is out of date, we don\u0027t know *how* out of date. Maybe if we included a timestamp in the NoteDbChangeState, we could allow results that are stale up to some epsilon? That seems like it\u0027s just asking for inconsistency though.\n\nRelated: replication lag.",
      "parentUuid": "4fa29cc0_20a26ab0",
      "revId": "e4f14be70656caaf55d46d3e42abff5f9bc11cdc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "749bb98d_e18a4629",
        "filename": "gerrit-server/src/main/java/com/google/gerrit/server/notedb/ChangeRebuilderImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 194,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2016-06-14T20:09:01Z",
      "side": 1,
      "message": "We talked about this a bit in person. First: don\u0027t serve stale data. If there are 10 requests to read the change following a write and only 1 of them returns fresh data (i.e. including the latest write), that\u0027s bad.\n\nWe can reduce the reported error rate by parsing a ChangeNotes directly out of the ObjectInserter produced by the ChangeRebuilder even if the update fails. NoteDb rebuilds are idempotent so at least we know this will be some future state of the change graph. Unfortunately I suspect that bringing drafts into the picture may complicate things.",
      "parentUuid": "141b5db9_e6a39eb3",
      "revId": "e4f14be70656caaf55d46d3e42abff5f9bc11cdc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}