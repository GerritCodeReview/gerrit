{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d54fd428_774bc289",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2020-12-07T18:47:00Z",
      "side": 1,
      "message": "Shouldn\u0027t be optional",
      "range": {
        "startLine": 62,
        "startChar": 16,
        "endLine": 62,
        "endChar": 17
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53591ee2_679e1f51",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1013302
      },
      "writtenOn": "2020-12-08T08:45:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d54fd428_774bc289",
      "range": {
        "startLine": 62,
        "startChar": 16,
        "endLine": 62,
        "endChar": 17
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "655a9b1e_1322fc50",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 93,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2020-12-07T18:47:00Z",
      "side": 1,
      "message": "In this change you suggests to use exceptions and catch blocks for handling errors. This is one of a wide-using approach. Another wide-using approach is a return code.\n\nBelow I am trying to summarize pros/cons of both solutions:\n------------\nExceptions:\nPros:\n1) the main code path is clean\n2) A error is catched only at the point where it is clear what to do with the error, a SWE shouldn\u0027t care about the problem in the intermediate code\n\nCons: \n1) A SWE can forget to catch an exception; typescript can\u0027t help with that.\n2) It is always a question, where to catch an exception. In this change you catch an exception after the .then(...) block. As a result, if a code inside then generates an exceptions, this exception is shown as pageError, though it can be an internal error/bug in the code.\n3) minor problem: using it with async/await is not elegant:\nOption 1: \ntry {\n  const res \u003d await getRepoDashboards();\n  ....actions with res...\n} catch(e) {\n  handleAsPageError(e); // Problem: any exceptions after getRepoDashboards also goes here \n}\n\nOption 2:\nlet res: SomeType; // Problem 1: type is always required\ntry {\n  res \u003d getRepoDashboards(); \n} catch(e) {\n   handleAsPageError(e);\n   return; // Proble 2: this return is required\n}\nother code...\n------------------\n\nReturn code:\nPros:\n1) It is impossible to forget to check the result\n2) If method is changed to return a code - compiler automatically shows all places where changes should be done. With try/catch a SWE should manually search for all usages.\n3) async/await code looks better (discussable)\n\nCons:\n1) Code should care about the result at each level. However, usually it is a simple check.\n\nHow it can look in Typescript:\n\ntype RestApiResult\u003cT\u003e \u003d SuccessResult\u003cT\u003e | RestApiError;\n\ninterface SuccessResult\u003cT\u003e \u003d {\n    data: T;\n}\ninterface RestApiError {\n    err: Error;\n}\n\n\nexport isRestApiFailed\u003cT\u003e(x: RestApiResult\u003cT\u003e): x is RestApiError {...}\n...\n\nthis.restApiService.getRepoDashboards(repo).then(result \u003d\u003e {\n    if(isRestApiFailed(result)) {\n        handleAsPageError(result);\n        return; //or return result, if you want to propogate error\n    }\n    ... // Some action with result.data\n});\n\n// OR with async/await:\nconst result \u003d await this.restApiService.getRepoDashboards(repo);\nif(isRestApiFaild(result)) {\n   handleAsPageError(result);\n   return;\n}\n... // Some action with result.data\n----\n\nIn this solution, Typescript ensures that result.data is not accessible until you check for a error (or explicitly make a type conversion);\nAlso, if you forget a return inside if block, typescript again fails with a error.\n\nMy personal preferences for typescript is a \u0027return code\u0027 approach: compiler enforces correct error handling everywhere in code.",
      "range": {
        "startLine": 93,
        "startChar": 7,
        "endLine": 93,
        "endChar": 32
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73472758_25c6116e",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 93,
      "author": {
        "id": 1013302
      },
      "writtenOn": "2020-12-08T08:08:53Z",
      "side": 1,
      "message": "Thanks for looking deeply into this. I like design discussions. :-)\n\nMy personal preference is to prefer exceptions over error codes.\n\n\u003e Exceptions: A SWE can forget to catch an exception; typescript can\u0027t help with that.\n\nI don\u0027t think that is a big problem, because:\n1. We have uncaught exception handlers. We should just act on the data more.\n2. The bigger problem is that SWEs deal with errors in the wrong way, which is even worse than not dealing with the error at all (see 1).\n3. It is good to have the liberty of not dealing with an exception.\n\n\u003e Exceptions: It is always a question, where to catch an exception.\n\nThat is a feature, not a bug. :-) It is indeed a question, but has different answers. Sometimes I want to catch before and sometimes after then() for example. Same applies to async/await.\n\n\u003e Error Codes: It is impossible to forget to check the result.\n\nSure, but you are also forcing the caller to caller to deal with two different scenarios with a split type and an if-clause. Why is this better ...\n\n  apiCall.then(result \u003d\u003e {\n    if(isRestApiFailed(result)) {\n      // handle error\n      return;\n    }\n    // handle success\n  });\n\n... than that?\n\n  apiCall.catch(error \u003d\u003e {\n    // handle error\n  })\n  .then(result \u003d\u003e {\n    // handle success\n  });\n\nNote that catch() can also return something, if you want to. If you want to avoid the try-catch for async-await, then you could keep the catch() for error handling and only replace then() by await:\n\n  const result \u003d await apiCall.catch(error \u003d\u003e {\n    // handle error\n  });\n\nGenerally I would be interested in whether you would also argue to never use Exceptions in Java. There is also a related Java design discussion with regards to checked vs unchecked exceptions, where I am strongly leaning towards unchecked for 99% of the cases.\n\nNote also that we already have an error code in the HTTP response. And it does not help us at all, because in the api-helper we cannot deal with it. We have to convert it into an exception to make sense of it. And we also have the interesting problem of server errors (codes) vs network errors (exceptions) coming from different layers that we want to aggregate. IMO that also demonstrates the advantage of exceptions.\n\nHow do you deal with error codes when you are making multiple API calls in parallel (think Promise.all)?\n\nI think sometimes you want to deal with an HTTP response code in the service layer, e.g. getAccount() 404 meaning not-logged-in, or generally error conditions that are expected to happen. And at other times in UI components you just want to deal with *all* kinds of errors at the same time, because every error is unexpected.\n\nOK. Now we have a lot of arguments for both sides. Great that we have a team meeting later today. Then we can maybe continue the discussion in person. WDYT?",
      "parentUuid": "655a9b1e_1322fc50",
      "range": {
        "startLine": 93,
        "startChar": 7,
        "endLine": 93,
        "endChar": 32
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d5b7e3c_a4cc925e",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 93,
      "author": {
        "id": 1083225
      },
      "writtenOn": "2020-12-08T09:37:48Z",
      "side": 1,
      "message": "\u003e\u003e 2. The bigger problem is that SWEs deal with errors in the wrong way, which is even worse than not dealing with the error at all (see 1).\nWhat do you mean by dealing with errors the wrong way?\nDo you mean making the wrong decision between propagating the error or not.",
      "parentUuid": "73472758_25c6116e",
      "range": {
        "startLine": 93,
        "startChar": 7,
        "endLine": 93,
        "endChar": 32
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84ee71b1_a27efcba",
        "filename": "polygerrit-ui/app/elements/admin/gr-repo-dashboards/gr-repo-dashboards.ts",
        "patchSetId": 1
      },
      "lineNbr": 93,
      "author": {
        "id": 1085901
      },
      "writtenOn": "2020-12-08T10:26:58Z",
      "side": 1,
      "message": "In overall, I think the main questions are:\na) do we want to ensure, that all errors are catched in the code and spend less time in review (\"return code approach\"). Downside: additional if blocks in the code.\n\nb) do we want to have more freedom in error handling. Downside: some errors can be uncatched; if method returns undefined - does it mean error or something else? (see bellow)\n\n\nI think, everything else is a discussion about how to write/organized code. That is important, but we should first make a decision about the first part.\nBelow my answers: \n\n\u003e\u003e Generally I would be interested in whether you would also argue to never use Exceptions in Java.\u003c\u003c\n\nI think Java is out of scope for this discussion. Go doesn\u0027t have exceptions and was developed after Java. Weak argument :) Typescript has nice features and makes the “return code” approach much nicer and safer than in other languages. (shortly - i will not argue against exceptions in Java).\n\n\u003e\u003eSure, but you are also forcing the caller to caller to deal with two different scenarios with a split type and an if-clause. Why is this better ...\n  apiCall.then(result \u003d\u003e {\n    if(isRestApiFailed(result)) {\n      // handle error\n      return;\n    }\n    // handle success\n  });\n\n... than that?\n  apiCall.catch(error \u003d\u003e {\n    // handle error\n  })\n  .then(result \u003d\u003e {\n    // handle success\n  });\n\n\u003c\u003c\n\nIn the code with exceptions the if clause is also required:\n apiCall.catch(error \u003d\u003e {\n    // handle error\n  })\n  .then(result \u003d\u003e {\n     if(!result) return; //If error is catched, the result is empty\n      // handle success\n  });\n\nAnd then undefined return value should be propagated through all the methods that calls this code. This is similar to propagating result/error object in the \"return code\" approach.\n\n\u003e\u003eNote that catch() can also return something, if you want to. If you want to avoid the try-catch for async-await, then you could keep the catch() for error handling and only replace then() by await:\n\n  const result \u003d await apiCall.catch(error \u003d\u003e {\n    // handle error\n  });\n\u003c\u003c\n\nI would like to avoid this code - this is a mix of callbacks and async/await code.(in tests it might be ok). Btw, this code can be refactored to fix it - (extract apiCall.catch into a separate method with try/catch block).\n\n\u003e\u003e Note also that we already have an error code in the HTTP response. And it does not help us at all, because in the api-helper we cannot deal with it. We have to convert it into an exception to make sense of it. And we also have the interesting problem of server errors (codes) vs network errors (exceptions) coming from different layers that we want to aggregate. IMO that also demonstrates the advantage of exceptions.\n\u003c\u003c\n\nNot sure, that I understand this point. With exceptions we have to convert server errors(codes) into exceptions, while with \"return code\" approach we have to convert exceptions into \"return code\".\n\n\n\u003e\u003e How do you deal with error codes when you are making multiple API calls in parallel (think Promise.all)?\u003c\u003c\n\nI think, we shouldn\u0027t make parallel API calls with a raw Promise.all.\nThe Promise.all rejects as soon as one of the requests throws an exceptions.\nWe should stop/abort all other parallel requests to avoid race conditions with future requests. In other world, we should have some util method\n\n  parallelExecution(...): [...] { // or RestApiResponse\u003c[...]\u003e for \"return code\"\n     ... send requests, if one fails - abort other     \n  }\n\n\nThis method should be written once and can be written for both approaches.\n\n\u003e\u003eI think sometimes you want to deal with an HTTP response code in the service layer, e.g. getAccount() 404 meaning not-logged-in, or generally error conditions that are expected to happen. And at other times in UI components you just want to deal with *all* kinds of errors at the same time, because every error is unexpected.\u003c\u003c\n\nHere I also don\u0027t see a big difference. Special handling for 404 is possible in both cases.",
      "parentUuid": "6d5b7e3c_a4cc925e",
      "range": {
        "startLine": 93,
        "startChar": 7,
        "endLine": 93,
        "endChar": 32
      },
      "revId": "e5b03de791ff611a2d7e96754c9941447d53fc32",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}