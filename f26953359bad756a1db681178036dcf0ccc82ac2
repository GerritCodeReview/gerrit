{
  "comments": [
    {
      "key": {
        "uuid": "f0f0ed44_e658397d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "I think the fact that we now just have a single point where lock/unlock is called makes up for that.",
      "range": {
        "startLine": 60,
        "startChar": 11,
        "endLine": 60,
        "endChar": 41
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b2addc4_66f7723d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "Good point. Added this to the commit message.",
      "parentUuid": "f0f0ed44_e658397d",
      "range": {
        "startLine": 60,
        "startChar": 11,
        "endLine": 60,
        "endChar": 41
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "80459b03_ee3e62eb",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "Can you add javadoc that this method is thread safe?",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "703d1975_98fc0af7",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "80459b03_ee3e62eb",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cba5800b_97c4be2d",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 195,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "Can you add javadoc that this method is thread safe?",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24270cbb_068e24a8",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 195,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cba5800b_97c4be2d",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b406a9bc_4ba060b9",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 237,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "Can you add a javadoc that this method is only to be called after #lock was called?",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8090b511_03b64c98",
        "filename": "java/com/google/gerrit/server/notedb/RepoSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 237,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b406a9bc_4ba060b9",
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8fc2a842_b8efb68f",
        "filename": "javatests/com/google/gerrit/server/notedb/RepoSequenceTest.java",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "Wouldn\u0027t it be easier to just have a block strategy that blocks forever?\n\nThen you can dispatch a normal call after that with no lock failure and see if that makes it through.\n\nMaybe it\u0027s not easier coding-wise but I would argue that it is easier to understand than a block strategy that itself dispatches a call (which is something block strategies aren\u0027t supposed to do).",
      "range": {
        "startLine": 228,
        "startChar": 3,
        "endLine": 236,
        "endChar": 94
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc9f9a42_9b0a17ab",
        "filename": "javatests/com/google/gerrit/server/notedb/RepoSequenceTest.java",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "OK, I rewrote the test. Not sure if it\u0027s easier to follow now.",
      "parentUuid": "8fc2a842_b8efb68f",
      "range": {
        "startLine": 228,
        "startChar": 3,
        "endLine": 236,
        "endChar": 94
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e3373c96_22a4783b",
        "filename": "javatests/com/google/gerrit/server/notedb/RepoSequenceTest.java",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-12T07:57:09Z",
      "side": 1,
      "message": "I think it gets cleaner if you use properly named countdown latches. Here is my suggestion:\n\n  @Test\n  public void idCanBeRetrievedFromOtherThreadWhileWaitingToRetry() throws Exception {\n    // Seed existing ref value.\n    writeBlob(\"id\", \"1\");\n\n    // Let the first update of the sequence fail with LOCK_FAILURE, so that the update is retried.\n    CountDownLatch lockFailure \u003d new CountDownLatch(1);\n    CountDownLatch parallelSuccessfulSequenceGeneration \u003d new CountDownLatch(1);\n\n    AtomicBoolean doneBgUpdate \u003d new AtomicBoolean(false);\n    Runnable bgUpdate \u003d\n        () -\u003e {\n          if (!doneBgUpdate.getAndSet(true)) {\n            // Provoke a LOCK_FAILURE on the first attempt\n            writeBlob(\"id\", \"1234\");\n          }\n        };\n\n    BlockStrategy blockStrategy \u003d\n        t -\u003e {\n          // Keep blocking until we verified that another thread can retrieve a sequence number\n          // while we are blocking here.\n          lockFailure.countDown();\n          parallelSuccessfulSequenceGeneration.await(2, TimeUnit.SECONDS);\n        };\n\n    // Use batch size \u003d 1 to make each call go to NoteDb.\n    RepoSequence s \u003d\n        newSequence(\n            \"id\",\n            1,\n            1,\n            bgUpdate,\n            RepoSequence.retryerBuilder().withBlockStrategy(blockStrategy).build());\n\n    // Start a thread to get a sequence number. This thread needs to update the sequence in NoteDb,\n    // but due to the background update (see bgUpdate) the first attempt to update NoteDb fails\n    // with LOCK_FAILURE. RepoSequence uses a retryer to retry the NoteDb update on LOCK_FAILURE,\n    // but our block strategy ensures that this retry only happens after isBlocking was set to\n    // false.\n    Future\u003c?\u003e future \u003d\n        Executors.newFixedThreadPool(1)\n            .submit(\n                () -\u003e {\n                  // The background update sets the next available sequence number to 1234. Then the\n                  // test thread retrieves one sequence number, so that the next available sequence\n                  // number for this thread is 1235.\n                  expect.that(s.next()).isEqualTo(1235);\n                });\n\n    lockFailure.await(2, TimeUnit.SECONDS);\n\n    // Verify that we can retrieve a sequence number while the other thread is blocked. If the\n    // s.next() call hangs it means that the RepoSequence.counterLock was not released before the\n    // background thread started to block for retry. In this case the test would time out.\n    assertThat(s.next()).isEqualTo(1234);\n\n    // Stop blocking the retry of the background thread (and verify that it was still blocked).\n    parallelSuccessfulSequenceGeneration.countDown();\n\n    // Wait until the background thread is done.\n    future.get();\n\n    // Two successful acquire calls (because batch size \u003d\u003d 1).\n    assertThat(s.acquireCount).isEqualTo(2);\n  }\n\nStill not optimal, because the Runnable is just a workaround. Ideally, we can tell the storage to throw a LOCK_FAILURE on the first try, but that would be way more work.",
      "parentUuid": "fc9f9a42_9b0a17ab",
      "range": {
        "startLine": 228,
        "startChar": 3,
        "endLine": 236,
        "endChar": 94
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4762f249_9e86148b",
        "filename": "javatests/com/google/gerrit/server/notedb/RepoSequenceTest.java",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-06-11T13:36:21Z",
      "side": 1,
      "message": "nit: fits in previous line",
      "range": {
        "startLine": 255,
        "startChar": 22,
        "endLine": 255,
        "endChar": 29
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b85b6da4_7e6533e8",
        "filename": "javatests/com/google/gerrit/server/notedb/RepoSequenceTest.java",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1003935
      },
      "writtenOn": "2019-06-11T15:04:39Z",
      "side": 1,
      "message": "no longer applicable",
      "parentUuid": "4762f249_9e86148b",
      "range": {
        "startLine": 255,
        "startChar": 22,
        "endLine": 255,
        "endChar": 29
      },
      "revId": "f26953359bad756a1db681178036dcf0ccc82ac2",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}