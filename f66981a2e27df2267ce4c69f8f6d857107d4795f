{
  "comments": [
    {
      "key": {
        "uuid": "ff960353_fa84254a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T20:14:36Z",
      "side": 1,
      "message": "Gerrit master or slave?",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 17
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc110526_2319ed4a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-18T21:19:28Z",
      "side": 1,
      "message": "Wouldn\u0027t matter in this case, but I tested with 8081 being master (non-slave). Note: we should start no longer using such terms; cf. Issue 12945.",
      "parentUuid": "ff960353_fa84254a",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 17
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "598c39fb_7afdbcf1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T21:57:14Z",
      "side": 1,
      "message": "Yes, I am following the Git community discussion.\nThanks for the pointer: I\u0027ve added my comments there.",
      "parentUuid": "fc110526_2319ed4a",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 17
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c7a6995_83140d82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T22:25:46Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "598c39fb_7afdbcf1",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 17
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2daed1f9_0f34c296",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-25T22:39:41Z",
      "side": 1,
      "message": "Marking the left thread below as resolved, based on my answers. The discussion can of course unfold a bit more if more questions arise.",
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7312f22c_ac4ccceb",
        "filename": "e2e-tests/src/test/resources/data/com/google/gerrit/scenarios/CheckMasterBranchReplica1.json",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T20:14:36Z",
      "side": 1,
      "message": "HOSTNAME1?",
      "range": {
        "startLine": 3,
        "startChar": 19,
        "endLine": 3,
        "endChar": 27
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eadeef79_9bebd5e1",
        "filename": "e2e-tests/src/test/resources/data/com/google/gerrit/scenarios/CheckMasterBranchReplica1.json",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-18T21:19:28Z",
      "side": 1,
      "message": "No, as this specific test is based on a locahost-only setup. The port is 8081 though. Such tests can be used as examples to come up with other test cases or scenarios, as usual with these.",
      "parentUuid": "7312f22c_ac4ccceb",
      "range": {
        "startLine": 3,
        "startChar": 19,
        "endLine": 3,
        "endChar": 27
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e972d0e_3e8fdad4",
        "filename": "e2e-tests/src/test/resources/data/com/google/gerrit/scenarios/CheckMasterBranchReplica1.json",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T21:57:14Z",
      "side": 1,
      "message": "One Gerrit server with two listeners then?",
      "parentUuid": "eadeef79_9bebd5e1",
      "range": {
        "startLine": 3,
        "startChar": 19,
        "endLine": 3,
        "endChar": 27
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be63b51_0668cdf9",
        "filename": "e2e-tests/src/test/resources/data/com/google/gerrit/scenarios/CheckMasterBranchReplica1.json",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-19T01:15:29Z",
      "side": 1,
      "message": "Two gerrit server instances. One listening on port 8080 or default (the \"replicator\"), and the other operating on port 8081 (the replica). Both also have differing ssh ports of course.",
      "parentUuid": "0e972d0e_3e8fdad4",
      "range": {
        "startLine": 3,
        "startChar": 19,
        "endLine": 3,
        "endChar": 27
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09392677_3a77d34c",
        "filename": "e2e-tests/src/test/resources/data/com/google/gerrit/scenarios/CheckMasterBranchReplica1.json",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-19T22:04:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7be63b51_0668cdf9",
      "range": {
        "startLine": 3,
        "startChar": 19,
        "endLine": 3,
        "endChar": 27
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aca9ae75_cc07232f",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T20:14:36Z",
      "side": 1,
      "message": "isn\u0027t this all caps? HTTP_PORT1?",
      "range": {
        "startLine": 29,
        "startChar": 32,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0fa4b039_c0018631",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-18T21:19:28Z",
      "side": 1,
      "message": "No, as the core framework (super-parent GerritSimulation) converts these terms to properties internally.",
      "parentUuid": "aca9ae75_cc07232f",
      "range": {
        "startLine": 29,
        "startChar": 32,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff7f68b7_792b37c3",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T21:57:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0fa4b039_c0018631",
      "range": {
        "startLine": 29,
        "startChar": 32,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea5f3c55_8b249c05",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T20:14:36Z",
      "side": 1,
      "message": "This would actually just get the timing of the get branch operation, whilst here we are testing replication, correct? I would expect to get the replication time as a timing result.",
      "range": {
        "startLine": 47,
        "startChar": 12,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f80f7a0b_72d02756",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-18T21:19:28Z",
      "side": 1,
      "message": "This gets the replica\u0027s master branch revision [5] as per CheckMasterBranchReplica1.json. The lines below compare that revision with the one from the replication-initiating node. If they match, then the test passes, as the expected commit was actually replicated.\n\n[5] https://gerrit-documentation.storage.googleapis.com/Documentation/3.0.11/rest-api-projects.html#get-branch",
      "parentUuid": "ea5f3c55_8b249c05",
      "range": {
        "startLine": 47,
        "startChar": 12,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6d8f0a6_e69c1b05",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T21:57:14Z",
      "side": 1,
      "message": "Gotcha, my question was on the timing that Gatling reports as the performance of the execution. Gatling is a tool per measuring performance and scalability: knowing that the replication works for sure but also if it is fast or slow, scalable or not scalable.",
      "parentUuid": "f80f7a0b_72d02756",
      "range": {
        "startLine": 47,
        "startChar": 12,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b700e64d_7f50c699",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-19T01:15:29Z",
      "side": 1,
      "message": "However the scope of this showcase test scenario is simpler. This is just the beginning, a basic replication e2e test scenario for a simple localhost setup. And again, functional and not load or performance oriented. But it may serve as an example to help develop more complex or intense scenarios.\n\nWe need to start somewhere I think. This should feed the cause of iteratively sharing otherwise internal (duplicated, expensive) smoke and load test suites. Automating those e2e suites come with the price of repeating frameworks over and over. Plus, a second level of reuse is reached when the same framework resources get used not only for functional but also load purposes (and vice-versa). The gc-conductor case I previously mentioned is a good example of doing just that.",
      "parentUuid": "a6d8f0a6_e69c1b05",
      "range": {
        "startLine": 47,
        "startChar": 12,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "def7a85e_03ad6b30",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-19T22:04:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b700e64d_7f50c699",
      "range": {
        "startLine": 47,
        "startChar": 12,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "865051b3_8f371e24",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T20:14:36Z",
      "side": 1,
      "message": "Should this be set as a variable? So that it can be then executed with more users and test the performance of the replication?",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "031ab661_067d84d2",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-18T21:19:28Z",
      "side": 1,
      "message": "Not in this specific test case, but it could be done to come up with another test or scenario. This kind of e2e scenario is more functional than load or performance. But it does reuse the same Gatling core framework in Gerrit. This approach has been introduced at the beginning of [6] (below).\n\nBeside core, the high-availability and multi-site plugins started having such scenarios too. And gc-conductor (more recently) started having hybrid scenarios, i.e., testing e2e functionality using some load ([7]\u0027s topmost commits). Functional e2e then met load, hence this vision of reusing the same Gatling framework in Gerrit.\n\n[6] https://gerrit-documentation.storage.googleapis.com/Documentation/3.0.11/dev-e2e-tests.html\n[7] https://gerrit.googlesource.com/plugins/gc-conductor/+log/refs/heads/stable-3.0",
      "parentUuid": "865051b3_8f371e24",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6999d1e5_7b6ae463",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-18T21:57:14Z",
      "side": 1,
      "message": "I am wondering if then the test could be rewritten simpler without Gatling then? If we are not using Gatling for load testing, I am not sure is the right tool.\n\nE2E testing is cool and Gatling allows you to create scenarios. But the scenarios should be parametrised with variables to scale up users and demonstrate that the scenarios are scalable.\n\nIn the home page of Gatling you see \"load test as code\", where \"load\" is important.\n\nWe can definitely start with E2E tests but the \"load\" factor should be parametrised so that the scenarios can be replicated for load.\n\nExample: introduce variables for the number of users, for the project names, etc.\n\nHaving more users on different projects, each scenarios can work in isolation and not interfere between each other.  That allows later on to scale the users and projects and make sure that the timings are flat and the system is scalable.",
      "parentUuid": "031ab661_067d84d2",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "711c8f46_8dafdde3",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-19T01:15:29Z",
      "side": 1,
      "message": "Agree. Now, that is not exactly the scope or goal of this specific change, as previously discussed. But we should definitely continue growing the core framework and surrounding core or plugin scenarios, for load yes but also functional e2e reuse. That goal is why I\u0027ve been spending a lot of Ericsson\u0027s time (and my own), on iterating over humble steps that way.",
      "parentUuid": "6999d1e5_7b6ae463",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70330cd0_007c6443",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-19T22:04:56Z",
      "side": 1,
      "message": "Gotcha, however, replacing a \"magic value\" of 1 with a variable doesn\u0027t look like a big effort and could be included in this change.\n\nAlso, this part of the setup should be part of the scenario IMHO: setup is typically preparing more the environment while the scenario is executing the actions of the test case.",
      "parentUuid": "711c8f46_8dafdde3",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15ae74d9_77473ab4",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-25T22:39:41Z",
      "side": 1,
      "message": "\u003e Gotcha, however, replacing a \"magic value\" of 1 with a variable doesn\u0027t look like a big effort and could be included in this change.\n\nReplacing this constant (not a typical magic value) with a variable would mean, allowing this scenario to potentially create multiple changes. This would require the below approveChange and other steps to scale accordingly. Now, ApproveChange is not tailored to scale that way, at least not yet. -And so on for other reused scenarios herein.\n\nSo that goes beyond the simpler scope of this change. Now, using \u00271\u0027 (constant) here and below should suffice, for the purpose of this current set of scenarios.\n\n\u003e Also, this part of the setup should be part of the scenario IMHO: setup is typically preparing more the environment while the scenario is executing the actions of the test case.\n\nWith Gatling and this growing framework so far, the setUp part is the one calling the traffic generation shots. Meaning, setUp is mixing the scenario\u0027s traffic. The scenario then gets the fed data to use it within the requests it generates. Every core and plugin scenario has been built that way, up until now.\n\nMore scenarios can come out of these eventually; existing ones can be amended in follow-ups. Here and through the core framework so far, the emerging scenarios and examples happen to reuse each other. (Some plugins also started doing so.)",
      "parentUuid": "70330cd0_007c6443",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a0cab8c_f211a8e2",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-06-25T23:21:31Z",
      "side": 1,
      "message": "\u003e \u003e Gotcha, however, replacing a \"magic value\" of 1 with a variable doesn\u0027t look like a big effort and could be included in this change.\n\u003e \n\u003e Replacing this constant (not a typical magic value) with a variable would mean, allowing this scenario to potentially create multiple changes. \n\nTypo? You mean \"multiple users\"?\n\n\u003e This would require the below approveChange and other steps to scale accordingly.\n\nYeah, I believe because you have put the test code in the setup(), which is the source of the problems. Have you tried moving the steps into the scenario itself?\n\nWhen adding steps to the scenario you can use the session variables so that every \"user flow\" can get its values and therefore can be isolated form the others. In that way we can build scenarios that, in the future, can be scaled up.\n\nPutting the scenario in the setup isn\u0027t going in that direction, unfortunately :-(\n\n\u003e Now, ApproveChange is not tailored to scale that way, at least not yet. -And so on for other reused scenarios herein.\n\nGotcha, but with a simple change in the approach, not expensive at all, we can open the door to go there in the next follow-up changes. Keeping all the logic in the setup, instead, isn\u0027t open to follow-ups :-(\n\nHave you tried moving the logic into the scenario instead of the setup?\n\n\u003e So that goes beyond the simpler scope of this change. Now, using \u00271\u0027 (constant) here and below should suffice, for the purpose of this current set of scenarios.\n\nYou can also make it constant (a predefined val at the beginning) and reuse it throughout the test, without repeating \u00271\u0027 hardcoded everywhere.\n\nE.g: val numUsers \u003d 1\n\n\u003e \u003e Also, this part of the setup should be part of the scenario IMHO: setup is typically preparing more the environment while the scenario is executing the actions of the test case.\n\u003e \n\u003e With Gatling and this growing framework so far, the setUp part is the one calling the traffic generation shots. Meaning, setUp is mixing the scenario\u0027s traffic. The scenario then gets the fed data to use it within the requests it generates. Every core and plugin scenario has been built that way, up until now.\n\nSetting up the data for the tests is 100% fine, putting the logic of the scenario is a bit too much IMHO. The problem is that Gatling won\u0027t consider it as part of your test code and won\u0027t give you the metrics associated with it.\n\n\u003e More scenarios can come out of these eventually; existing ones can be amended in follow-ups. Here and through the core framework so far, the emerging scenarios and examples happen to reuse each other. (Some plugins also started doing so.)\n\nI would recommend to evolve the \"template\" on how we build Gatling tests moving forward, otherwise we\u0027ll end up creating a lot of code that won\u0027t be able to scale and benefit from the Gatling framework.",
      "parentUuid": "15ae74d9_77473ab4",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8823d7c_3e3f5c2f",
        "filename": "e2e-tests/src/test/scala/com/google/gerrit/scenarios/CheckMasterBranchReplica1.scala",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2020-06-26T19:37:16Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Gotcha, however, replacing a \"magic value\" of 1 with a variable doesn\u0027t look like a big effort and could be included in this change.\n\u003e \u003e \n\u003e \u003e Replacing this constant (not a typical magic value) with a variable would mean, allowing this scenario to potentially create multiple changes. \n\u003e \n\u003e Typo? You mean \"multiple users\"?\n\nNo, I really meant multiple changes.\n\n\u003e \u003e This would require the below approveChange and other steps to scale accordingly.\n\u003e \n\u003e Yeah, I believe because you have put the test code in the setup(), which is the source of the problems. Have you tried moving the steps into the scenario itself?\n\nThis should not be a problem in fact. This is what these scenarios were originally meant for after being merged in.\n\nAlmost two months ago, this review [8] discussed that specific topic prior to submission. In there, I\u0027m explaining why this framework needs both in-scenario and in-setUp steps. Answering the question above, yes; but then I had to make this a more advanced approach:\n\n[8] https://gerrit-review.googlesource.com/c/gerrit/+/263472/3/e2e-tests/src/test/scala/com/google/gerrit/scenarios/GerritSimulation.scala#42\n\nOf course that power makes such scenarios less intuitive, but with the ruling benefit of scenarios reuse. And some steps can still land in the so reused scenarios themselves. For scenarios that happen to compose or aggregate others, then their reused scenario steps land in setUp.\n\n\u003e When adding steps to the scenario you can use the session variables so that every \"user flow\" can get its values and therefore can be isolated form the others. In that way we can build scenarios that, in the future, can be scaled up.\n\u003e \n\u003e Putting the scenario in the setup isn\u0027t going in that direction, unfortunately :-(\n\nI definitely agree with the above paragraph. I tend to disagree with the last sentence though. Some scenarios are meant for scaling load, while others like such functional e2e ones aren\u0027t. But both classes of tests should be able to reuse some of their step implementations. This more recent set of plugin scenarios does enable functional/load reuse of e2e steps:\n\n[9] https://gerrit-review.googlesource.com/c/plugins/gc-conductor/+/272172\n\n\u003e \u003e Now, ApproveChange is not tailored to scale that way, at least not yet. -And so on for other reused scenarios herein.\n\u003e \n\u003e Gotcha, but with a simple change in the approach, not expensive at all, we can open the door to go there in the next follow-up changes. Keeping all the logic in the setup, instead, isn\u0027t open to follow-ups :-(\n\u003e \n\u003e Have you tried moving the logic into the scenario instead of the setup?\n\nI hope I was able to answer this and clarify that, up above.\n\n\u003e \u003e So that goes beyond the simpler scope of this change. Now, using \u00271\u0027 (constant) here and below should suffice, for the purpose of this current set of scenarios.\n\u003e \n\u003e You can also make it constant (a predefined val at the beginning) and reuse it throughout the test, without repeating \u00271\u0027 hardcoded everywhere.\n\u003e \n\u003e E.g: val numUsers \u003d 1\n\nUsing a single \u00271\u0027 value across similar steps has been reviewed and merged through previous changes. But I understand your concern and will work on a change to replace all those with a reused framework constant, properly named.\n\nThis needs its own change, as that reusable (and reused) constant doesn\u0027t exist yet in the framework. Introducing it means replacing all such values consistently, so not only the new ones from this specific change.\n\n\u003e \u003e \u003e Also, this part of the setup should be part of the scenario IMHO: setup is typically preparing more the environment while the scenario is executing the actions of the test case.\n\u003e \u003e \n\u003e \u003e With Gatling and this growing framework so far, the setUp part is the one calling the traffic generation shots. Meaning, setUp is mixing the scenario\u0027s traffic. The scenario then gets the fed data to use it within the requests it generates. Every core and plugin scenario has been built that way, up until now.\n\u003e \n\u003e Setting up the data for the tests is 100% fine, putting the logic of the scenario is a bit too much IMHO. The problem is that Gatling won\u0027t consider it as part of your test code and won\u0027t give you the metrics associated with it.\n\nThe reports I\u0027ve seen and used so far worked well enough for the purpose. Especially the ones coming out of [9] above, as a recent example. We can come up with any scenario structure we want, should we have differing report requirements.\n\nNew or similar scenarios can still be written using different approaches, no matter the framework above them -which should accommodate and evolve. This also goes with your trailing comment down below.\n\n\u003e \u003e More scenarios can come out of these eventually; existing ones can be amended in follow-ups. Here and through the core framework so far, the emerging scenarios and examples happen to reuse each other. (Some plugins also started doing so.)\n\u003e \n\u003e I would recommend to evolve the \"template\" on how we build Gatling tests moving forward, otherwise we\u0027ll end up creating a lot of code that won\u0027t be able to scale and benefit from the Gatling framework.\n\nAgree. This has been my wanted working mode since I started on this, close to 5 months and 50+- changes ago :)",
      "parentUuid": "9a0cab8c_f211a8e2",
      "range": {
        "startLine": 54,
        "startChar": 18,
        "endLine": 54,
        "endChar": 19
      },
      "revId": "f66981a2e27df2267ce4c69f8f6d857107d4795f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}