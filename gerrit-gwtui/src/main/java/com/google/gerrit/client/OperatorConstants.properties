format = FORMAT:
constraints = CONSTRAINTS:

ageTab = AGE
timeTab = TIME
changeTab = CHANGE
idTab = ID 
userTab = USER/GROUP
projectTab = PROJECT
hasTab = HAS
isTab = IS
statusTab = STATUS
relationTab = RELATION
booleanTab = BOOLEAN
magicalTab = MAGICAL
othersTab = OTHERS
elementsTab = ELEMENT
booleansTab = BOOLEAN

searchOperators = Search Operators
close = Close

ages = \
	ageKey,\
	ageDes,\
	ageFormat,\
	ageConstNum,\
	ageConst0,\
	ageConst1,\
	ageConst2,\
	ageConst3,\
	ageConst4,\
	ageConst5,\
	ageConst6
ageKey = age:'AGE'  
ageDes = Amount of time that has expired since the change was last updated with a review comment or new patch set.
ageFormat = The age must be specified to include a unit suffix, for example age:2d
ageConstNum = 1111111;
ageConst0 = s, sec, second, seconds
ageConst1 = m, min, minute, minutes
ageConst2 = h, hr, hour, hours
ageConst3 = d, day, days
ageConst4 = w, week, weeks (1 week is treated as 7 days)
ageConst5 = mon, month, months (1 month is treated as 30 days)
ageConst6 = y, year, years (1 year is treated as 365 days)

befores = \
	beforeKey,\
	beforeDes,\
	beforeFormat,\
	beforeConstNum,\
	beforeConst0,\
	beforeConst1
beforeKey = before:'TIME'
beforeDes = Changes modified before the given 'TIME', inclusive. 
beforeFormat = Must be in the format 2006-01-02[ 15:04:05[.890][ -0700]]
beforeConstNum = 11;
beforeConst0 = Omitting the time defaults to 00:00:00
beforeConst1 = Omitting the timezone defaults to UTC.

untils = \
	untilKey,\
	untilDes,\
	untilFormat,\
	untilConstNum,\
	untilConst0,\
	untilConst1
untilKey = until:'TIME'
untilDes = Changes modified before the given 'TIME', inclusive. 
untilFormat = Must be in the format 2006-01-02[ 15:04:05[.890][ -0700]]
untilConstNum = 11;
untilConst0 = Omitting the time defaults to 00:00:00
untilConst1 = Omitting the timezone defaults to UTC.
afters = \
	afterKey,\
	afterDes,\
	afterFormat,\
	afterConstNum,\
	afterConst0,\
	afterConst1
afterKey = after:'TIME'
afterDes = Changes modified after the given 'TIME', inclusive. 
afterFormat	= Must be in the format 2006-01-02[ 15:04:05[.890][ -0700]].
afterConstNum = 11;
afterConst0 = Omitting the time defaults to 00:00:00 
afterConst1 = Omitting the timezone defaults to UTC.
sinces = \
	sinceKey,\
	sinceDes,\
	sinceFormat,\
	sinceConstNum,\
	sinceConst0,\
	sinceConst1
sinceKey = since:'TIME'
sinceDes = Changes modified after the given 'TIME', inclusive. 
sinceFormat	= Must be in the format 2006-01-02[ 15:04:05[.890][ -0700]].
sinceConstNum = 11;
sinceConst0 = Omitting the time defaults to 00:00:00 
sinceConst1 = Omitting the timezone defaults to UTC.
changes = \
	changeKey,\
	changeDes
changeKey = change:'ID'
changeDes = Either a legacy numerical 'ID' such as 15183, or a newer style Change-Id that was scraped out of the commit message.
conflictss = \
	conflictsKey,\
	conflictsDes,\
	conflictsFormat
conflictsKey = conflicts:'ID'
conflictsDes = Changes that conflict with change 'ID'. 
conflictsFormat = Change 'ID' can be specified as a legacy numerical 'ID' such as 15183,\
		 or a newer style Change-Id that was scraped out of the commit message.
owners = \
	ownerKey,\
	ownerDes,\
	ownerConst
ownerKey = owner:'USER'/o:'USER'
ownerDes = Changes originally submitted by 'USER'. 
ownerConst =The special case of owner:self will find changes owned by the caller.
ownerins = \
	ownerinKey,\
	ownerinDes
ownerinKey = ownerin:'GROUP'
ownerinDes = Changes originally submitted by a user in 'GROUP'.
reviewers = \
	reviewerKey,\
	reviewerDes,\
	reviewerConst
reviewerKey = reviewer:'USER'/r:'USER'
reviewerDes = Changes that have been, or need to be, reviewed by 'USER'.
reviewerConst = The special case of reviewer:self will find changes where the caller has been added as a reviewer.
reviewerins = \
	reviewerinKey,\
	reviewerinDes
reviewerinKey = reviewerin:'GROUP'
reviewerinDes = Changes that have been, or need to be, reviewed by a user in 'GROUP'.
commits = \
	commitKey,\
	commitDes
commitKey = commit:'SHA1'
commitDes = Changes where 'SHA1' is one of the patch sets of the change.
projects = \
	projectKey,\
	projectDes,\
	projectConstNum,\
	projectConst0,\
	projectConst1
projectKey = project:'PROJECT'/p:'PROJECT'
projectDes = Changes occurring in 'PROJECT'. 
projectConstNum = 11;
projectConst0 = If 'PROJECT' starts with ^ it matches project names by regular expression.
projectConst1 = The dk.brics.automaton library is used for evaluation of such patterns.
projectss = \
	projectsKey,\
	projectsDes
projectsKey = projects:'PREFIX'
projectsDes = Changes occurring in projects starting with 'PREFIX'.
parentprojects = \
	parentprojectKey,\
	parentprojectDes
parentprojectKey = parentproject:'PROJECT'
parentprojectDes = Changes occurring in 'PROJECT' or in one of the child projects of 'PROJECT'.
branchs = \
	branchKey,\
	branchDes,\
	branchFormatNum,\
	branchFormat0,\
	branchFormat1
branchKey = branch:'BRANCH'
branchDes = Changes for 'BRANCH'. 
branchFormatNum = 11
branchFormat0 = The branch name is either the short name shown in the web interface or \
		the full name of the destination branch with the traditional 'refs/heads/' prefix. 
branchFormat1 = If 'BRANCH' starts with ^ it matches branch names by regular expression patterns.\
		The dk.brics.automaton library is used for evaluation of such patterns.
topics = \
	topicKey,\
	topicDes,\
	topicFormatNum,\
	topicFormat0,\
	topicFormat1
topicKey = topic:'TOPIC'
topicDes = Changes whose designated topic at upload was 'TOPIC'. \
		This is often combined with 'branch:' and 'project:' operators to select all related changes in a series.
topicFormatNum = 11
topicFormat0 = If 'TOPIC' starts with ^ it matches topic names by regular expression patterns.
topicFormat1 = The dk.brics.automaton library is used for evaluation of such patterns.
refs = \
	refKey,\
	refDes,\
	refNum,\
	refFormat0,\
	refFormat1
refKey = ref:'REF'
refDes = Changes where the destination branch is exactly the given 'REF' name. \
		Since 'REF' is absolute from the top of the repository it must start with 'refs/'.
refNum = 11;
refFormat0 = If 'REF' starts with ^ it matches reference names by regular expression patterns. 
refFormat1 = The dk.brics.automaton library is used for evaluation of such patterns.
trs = \
	trKey,\
	trDes
trKey = tr:'ID'
trDes = Search for changes whose commit message contains 'ID' and matches one \
		or more of the trackingid sections in the server\u2019s configuration file.\
		This is typically used to search for changes that fix a bug or defect by the issue tracking system's issue identifier.
bugs = \
	bugKey,\
	bugDes
bugKey = bug:'ID'
bugDes = Search for changes whose commit message contains 'ID' and matches one \
		or more of the trackingid sections in the server\u2019s configuration file.\
		This is typically used to search for changes that fix a bug or defect by the issue tracking system's issue identifier.
labels = \
	labelKey,\
	labelDes
labelKey = label:'VALUE'
labelDes = Matches changes where the approval score 'VALUE' has been set during a review. See labels below for more detail on the format of the argument.
messages = \
	messageKey,\
	messageDes
messageKey = message:'MESSAGE'
messageDes = Changes that match 'MESSAGE' arbitrary string in the commit message body.
comments = \
	commentKey,\
	commentDes
commentKey = comment:'TEXT'
commentDes = Changes that match 'TEXT' string in any comment left by a reviewer.
paths = \
	pathKey,\
	pathDes,\
	pathFormatNum,\
	pathFormat0,\
	pathFormat1,\
	pathFormat2,\
	pathFormat3,\
	pathFormat4
pathKey = path:'PATH'
pathDes = Matches any change touching file at 'PATH'. 
pathFormatNum = 11111
pathFormat0 = By default exact path matching is used, but regular expressions can be enabled by starting with ^. \
		For example, to match all XML files use file:^.*\\.xml$.
pathFormat1 = The dk.brics.automaton library is used for the evaluation of such patterns.
pathFormat2 = The ^ required at the beginning of the regular expression not only denotes a regular expression, \
		but it also has the usual meaning of anchoring the match to the start of the string.
pathFormat3 = To match all Java files, use file:^.*\\.java.\
 		entire regular expression pattern, including the ^ character, \
 		should be double quoted when using more complex construction (like ones using a bracket expression). 
pathFormat4 = For example, to match all XML files named like 'name1.xml', 'name2.xml', and 'name3.xml' use file:"^name[1-3].xml".
files = \
	fileKey,\
	fileDes,\
	fileFormat,\
	fileConst
fileKey = file:'NAME'/f:'NAME'
fileDes = Matches any change touching a file containing the path component 'NAME'. 
fileFormat = For example a file:src will match changes that modify files named gerrit-server/src/main/java/Foo.java. \
		Regular expression matching can be enabled by starting the string with ^. In this mode file: is an alias of path: (see above).
fileConst = Name matching is exact match, file:Foo.java finds any change touching a file named exactly \
		Foo.java and does not match AbstractFoo.java.
drafts = \
	draftKey,\
	draftDes
draftKey = has:draft
draftDes = True if there is a draft comment saved by the current user.
stars = \
	starKey,\
	starDes
starKey = has:star
starDes = Same as 'is:starred'.True if the change has been starred by the current user.
isstarreds = \
	isstarredKey,\
	isstarredDes
isstarredKey = is:starred
isstarredDes = Same as 'has:star'. True if the change has been starred by the current user.
iswatcheds = \
	iswatchedKey,\
	iswatchedDes
iswatchedKey = is:watched
iswatchedDes = True if this change matches one of the current user's watch filters, \
		and thus is likely to notify the user when it updates.
isrevieweds = \
	isreviewedKey,\
	isreviewedDes
isreviewedKey = is:reviewed
isreviewedDes = True if there is at least one non-zero score on the change, in any approval category, by any user.
isowners = \
	isownerKey,\
	isownerDes
isownerKey = is:owner
isownerDes = True on any change where the current user is the change owner. Same as owner:self.
isreviewers = \
	isreviewerKey,\
	isreviewerDes
isreviewerKey = is:reviewer
isreviewerDes = True on any change where the current user is a reviewer. Same as reviewer:self.
isopens = \
	isopenKey,\
	isopenDes
isopenKey = is:open
isopenDes = True if the change is either open or submitted, merge pending.
ispendings = \
	ispendingKey,\
	ispendingDes
ispendingKey = is:pending
ispendingDes = True if the change is either open or submitted, merge pending.
isdrafts = \
	isdraftKey,\
	isdraftDes	
isdraftKey = is:draft
isdraftDes = True if the change is a draft.
iscloseds = \
	isclosedKey,\
	isclosedDes
isclosedKey = is:closed
isclosedDes = True if the change is either merged or abandoned.
issubmitteds = \
	issubmittedKey,\
	issubmittedDes
issubmittedKey = is:submitted
issubmittedDes = Same as status:'STATE'
ismergeds = \
	ismergedKey,\
	ismergedDes
ismergedKey = is:merged
ismergedDes = Same as status:'STATE'
isabandoneds = \
	isabandonedKey,\
	isabandonedDes
isabandonedKey = is:abandoned
isabandonedDes = Same as status:'STATE'
ismergeables = \
	ismergeableKey,\
	ismergeableDes
ismergeableKey = is:mergeable
ismergeableDes = True if the change has no merge conflicts and could be merged into its destination branch.
statusopens = \
	statusopenKey,\
	statusopenDes
statusopenKey = status:open
statusopenDes = True if the change state is either 'review in progress' or 'submitted, merge pending'.
statuspendings = \
	statuspendingKey,\
	statuspendingDes
statuspendingKey = status:pending
statuspendingDes = True if the change state is either 'review in progress' or 'submitted, merge pending'.
statusrevieweds = \
	statusreviewedKey,\
	statusreviewedDes
statusreviewedKey = status:reviewed
statusreviewedDes = Same as 'is:reviewed', matches if there is at least one non-zero score on the change, in any approval category, by any user.
statussubmitteds = \
	statussubmittedKey,\
	statussubmittedDes
statussubmittedKey = status:submitted
statussubmittedDes = Change has been submitted, but is waiting for a dependency.
statuscloseds = \
	statusclosedKey,\
	statusclosedDes
statusclosedKey = status:closed
statusclosedDes = True if the change is either 'merged' or 'abandoned'.
statusmergeds = \
	statusmergedKey,\
	statusmergedDes
statusmergedKey = status:merged
statusmergedDes = Change has been merged into the branch.
statusabandoneds = \
	statusabandonedKey,\
	statusabandonedDes
statusabandonedKey = status:abandoned
statusabandonedDes = Change has been abandoned.
addeds = \
	addedKey,\
	addedDes,\
	addedFormatNum,\
	addedFormat0,\
	addedFormat1
addedKey = added:'RELATION''LINES'
addedDes = True if the number of lines added satisfies the given relation for the given number of lines.
addedFormatNum = 11
addedFormat0 = For example, added:>50 will be true for any change which adds at least 50 lines.
addedFormat1 =	Valid relations are >=, >, <=, <, or no relation, which will match if the number of lines is exactly equal.
deleteds = \
	deletedKey,\
	deletedDes,\
	deletedFormatNum,\
	deletedFormat0,\
	deletedFormat1
deletedKey = deleted:'RELATION''LINES'
deletedDes = True if the number of lines deleted satisfies the given relation for the given number of lines. 
deletedFormatNum = 11
deletedFormat0 = For example, deleted:>50 will be true for any change which deletes at least 50 lines.
deletedFormat1 = Valid relations are >=, >, <=, <, or no relation, which will match if the number of lines is exactly equal.
deltas = \
	deltaKey,\
	deltaDes,\
	deltaFormatNum,\
	deltaFormat0,\
	deltaFormat1
deltaKey = delta/size:'RELATION''LINES'
deltaDes = True if the number of lines changed satisfies the given relation for the given number of lines. 
deltaFormatNum = 11
deltaFormat0 = For example, delta:>50 will be true for any change which deltas at least 50 lines.
deltaFormat1 = Valid relations are >=, >, <=, <, or no relation, which will match if the number of lines is exactly equal.	
combys = \
	combyKey,\
	combyDes,\
	combyConst
combyKey = commentby:'USER'
combyDes = Changes containing a top-level or inline comment by 'USER'. 
combyConst = The special case of commentby:self will find changes where the caller has commented.
froms = \
	fromKey,\
	fromDes
fromKey = from:'USER'
fromDes = Changes containing a top-level or inline comment by 'USER', or owned by 'USER'.\
		Equivalent to (owner:USER OR commentby:USER).
reviewedbys = \
	reviewedbyKey,\
	reviewedbyDes
reviewedbyKey = reviewedby:'USER'
reviewedbyDes = Changes where 'USER' has commented on the change more recently than \
		the last update (comment or patch set) from the change owner.
authors = \
	authorKey,\
	authorDes
authorKey = author:'AUTHOR'
authorDes = Changes where 'AUTHOR' is the author of the current patch set.\
		'AUTHOR' may be the author\u2019s exact email address, or part of the name or email address.
committers = \
	committerKey,\
	committerDes
committerKey = committer:'COMMITTER'
committerDes = Changes where 'COMMITTER' is the committer of the current patch set. \
		'COMMITTER' may be the committer\u2019s exact email address, \
		or part of the name or email address.
negations = \
	negationKey,\
	negationDes,\
	negationFormatNum,\
	negationFormat0,\
	negationFormat1,\
	negationConst
negationKey = Negation
negationDes = Any operator can be negated by prefixing it with -
negationFormatNum = 11
negationFormat0 = -is:starred is the exact opposite of 
negationFormat1 = is:starred and will therefore return changes that are not starred by the current user.
negationConst = The operator NOT (in all caps) is a synonym.
ands = \
	andKey,\
	andDes
andKey = AND
andDes = The boolean operator AND (in all caps) can be used to join two other operators together.\
		This results in a restriction of the results, returning only changes that match both operators.
ors = \
	orKey,\
	orDes
orKey = OR
orDes = The boolean operator OR (in all caps) can be used to find changes that match either operator. \
		This increases the number of results that are returned, as more changes are considered.
visibletos = \
	visibletoKey,\
	visibletoDes,\
	visibletoFormat0,\
	visibletoFormat1,\
	visibletoFormatNum,\
	visibletoConst
visibletoKey = visibleto:'USER-or-GROUP'
visibletoDes = Matches changes that are visible to 'USER' or to anyone who is a member of 'GROUP'. 
visibletoFormat0 = Here group names may be specified as either an internal group name, \
		or if LDAP is being used, an external LDAP group name. 
visibletoFormat1 = The value may be wrapped in double quotes to include spaces or other special characters. \
		For example, to match an LDAP group: visibleto:"CN=Developers, DC=example, DC=com".
visibletoFormatNum = 11
visibletoConst = This operator may be useful to test access control rules, \
		however a change can only be matched if both the current user and the supplied user or group can see it. \
		This is due to the implicit 'is:visible' clause that is always added by the server.
isvisibles = \
	isvisibleKey,\
	isvisibleDes
isvisibleKey = is:visible
isvisibleDes = Magical internal flag to prove the current user has access to read the change. \
		This flag is always added to any query.
starredbys = \
	starredbyKey,\
	starredbyDes,\
	starredbyConst
starredbyKey = starredby:'USER'
starredbyDes = Matches changes that have been starred by 'USER'.
starredbyConst = The special case starredby:self applies to the caller.
watchedbys = \
	watchedbyKey,\
	watchedbyDes,\
	watchedbyConst
watchedbyKey = watchedby:'USER'
watchedbyDes = Matches changes that 'USER' has configured watch filters for. 
watchedbyConst = The special case watchedby:self applies to the caller.
draftbys = \
	draftbyKey,\
	draftbyDes,\
	drafybyConstNum,\
	drafybyConst0,\
	drafybyConst1
draftbyKey = draftby:'USER'
draftbyDes = Matches changes that 'USER' has left unpublished draft comments on. 
drafybyConstNum = 11
drafybyConst0 = Since the drafts are unpublished, it is not possible to see the draft text, \
		or even how many drafts there are. 
drafybyConst1 = The special case of draftby:self will find changes where the caller has created a draft comment.
limits = \
	limitKey,\
	limitDes,\
	limitConstNum,\
	limitConst0,\
	limitConst1
limitKey = limit:'CNT'
limitDes = Limit the returned results to no more than 'CNT' records. 
limitConstNum = 11
limitConst0 = This is automatically set to the page size configured in the current user\u2019s preferences.
limitConst1 = Including it in a web query may lead to unpredictable results with regards to pagination.