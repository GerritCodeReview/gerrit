BASE = get_base_path()
CORE = [
  'commit-message-length-validator',
  'download-commands',
  'hooks',
  'replication',
  'reviewnotes',
  'singleusergroup'
]

# custom plugins to include in the release.war
# Either define the list in CUSTOM here directly,
# or set plugins.use_custom_file in .buckconfig[.local]
# to a buck file path and define INCLUDE  to a list of
# plugins in this file (CUSTOM is supported as legacy
# name as well). Define EXCLUDE to a list of plugins
# to exclude. This can be used to build a custom release
# without certain core plugins.

CUSTOM = []
INCLUDE = []
EXCLUDE = []

local_override = read_config('plugins','local_override_file')
if local_override:
   include_defs(local_override)

#convert all list to sets to get a unique list of plugins
CUSTOM = set(CUSTOM)
CORE = set(CORE)
INCLUDE = set(INCLUDE)
EXCLUDE = set(EXCLUDE)

ALL = (CORE | CUSTOM | INCLUDE) - EXCLUDE

# buck audit parses and resolves all deps even if not reachable
# from the root(s) passed to audit. Filter dependencies to only
# the ones that currently exist to allow buck to parse cleanly.
# TODO(sop): buck should more lazily resolve deps
def core_plugins(names):
  from os import path
  h, n = [], []
  for p in names:
    if path.exists(path.join(BASE, p, 'BUCK')):
      h.append(p)
    else:
      n.append(p)
  return h, n
HAVE, NEED = core_plugins(ALL)

genrule(
  name = 'core',
  cmd = '' +
    ';'.join(['echo >&2 plugins/'+n+' is required.' for n in NEED]) +
    (';echo >&2;exit 1;' if NEED else '') +
    'mkdir -p $TMP/WEB-INF/plugins;' +
    'for s in ' +
    ' '.join(['$(location //%s/%s:%s)' % (BASE, n, n) for n in HAVE]) +
    ';do ln -s $s $TMP/WEB-INF/plugins;done;' +
    'cd $TMP;' +
    'zip -qr $OUT .',
  out = 'core.zip',
  visibility = ['//:release'],
)
