<!DOCTYPE html>
<!--
Copyright (C) 2017 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
<title>gr-rule-editor</title>

<script src="../../../bower_components/page/page.js"></script>
<script src="../../../bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
<script src="../../../bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="../../../test/common-test-setup.html"/>
<link rel="import" href="gr-rule-editor.html">

<script>void(0);</script>

<test-fixture id="basic">
  <template>
    <gr-rule-editor></gr-rule-editor>
  </template>
</test-fixture>

<script>
  suite('gr-rule-editor tests', () => {
    let element;
    let sandbox;

    setup(() => {
      sandbox = sinon.sandbox.create();
      element = fixture('basic');
    });

    teardown(() => {
      sandbox.restore();
    });

    suite('unit tests', () => {
      test('_computeForce, _computeForceClass, and _computeForceOptions',
          () => {
            const FORCE_PUSH_OPTIONS = [
              {
                name: 'No Force Push',
                value: false,
              },
              {
                name: 'Force Push',
                value: true,
              },
            ];

            const FORCE_EDIT_OPTIONS = [
              {
                name: 'No Force Edit',
                value: false,
              },
              {
                name: 'Force Edit',
                value: true,
              },
            ];
            let permission = 'push';
            assert.isTrue(element._computeForce(permission));
            assert.equal(element._computeForceClass(permission), 'force');
            assert.deepEqual(element._computeForceOptions(permission),
                FORCE_PUSH_OPTIONS);
            permission = 'editTopicName';
            assert.isTrue(element._computeForce(permission));
            assert.equal(element._computeForceClass(permission), 'force');
            assert.deepEqual(element._computeForceOptions(permission),
                FORCE_EDIT_OPTIONS);
            permission = 'submit';
            assert.isFalse(element._computeForce(permission));
            assert.equal(element._computeForceClass(permission), '');
            assert.deepEqual(element._computeForceOptions(permission), []);
          });

      test('_computeDeletedClass', () => {
        assert.equal(element._computeDeletedClass(true), 'deleted');
        assert.equal(element._computeDeletedClass(false), '');
      });

      test('_getDefaultRuleValues', () => {
        let permission = 'priority';
        let label;
        assert.deepEqual(element._getDefaultRuleValues(permission, label),
          {action: 'BATCH'});
        permission = 'label-Code-Review';
        label = {values: [
          {value: -2, text: 'This shall not be merged'},
          {value: -1, text: 'I would prefer this is not merged as is'},
          {value: -0, text: 'No score'},
          {value: 1, text: 'Looks good to me, but someone else must approve'},
          {value: 2, text: 'Looks good to me, approved'},
        ]};
        assert.deepEqual(element._getDefaultRuleValues(permission, label),
            {action: 'ALLOW', max: 2, min: -2});
        permission = 'push';
        label = undefined;
        assert.deepEqual(element._getDefaultRuleValues(permission, label),
          {action: 'ALLOW', force: false});
        permission = 'submit';
        assert.deepEqual(element._getDefaultRuleValues(permission, label),
            {action: 'ALLOW'});
      });

      test('_setDefaultRuleValues', () => {
        element.rule = {id: 123};
        const defaultValue = {action: 'ALLOW'};
        sandbox.stub(element, '_getDefaultRuleValues').returns(defaultValue);
        sandbox.stub(element, '_setOriginalRuleValues');
        element._setDefaultRuleValues();
        assert.isTrue(element._getDefaultRuleValues.called);
        assert.isTrue(element._setOriginalRuleValues.called);
        assert.equal(element.rule.value, defaultValue);
      });

      test('_computeOptions', () => {
        const PRIORITY_OPTIONS = [
          'BATCH',
          'INTERACTIVE',
        ];
        const DROPDOWN_OPTIONS = [
          'ALLOW',
          'DENY',
          'BLOCK',
        ];
        let permission = 'priority';
        assert.deepEqual(element._computeOptions(permission), PRIORITY_OPTIONS);
        permission = 'submit';
        assert.deepEqual(element._computeOptions(permission), DROPDOWN_OPTIONS);
      });

      test('_handleValueChange called with no value', () => {
        sandbox.stub(element, '_setDefaultRuleValues');
        sandbox.stub(element, '_setOriginalRuleValues');
        element.rule = {id: 123};
        assert.isTrue(element._setDefaultRuleValues.called);
        assert.isFalse(element._setOriginalRuleValues.called);
        assert.isFalse(element._modified);
      });

      test('_handleValueChange called with a value and no original set', () => {
        sandbox.stub(element, '_setDefaultRuleValues');
        sandbox.stub(element, '_setOriginalRuleValues');
        element.rule = {id: 123, value: {action: 'BATCH'}};
        assert.isFalse(element._setDefaultRuleValues.called);
        assert.isTrue(element._setOriginalRuleValues.called);
        assert.isFalse(element._modified);
      });

      test('_handleValueChange called with a value and original is set', () => {
        sandbox.stub(element, '_setDefaultRuleValues');
        sandbox.stub(element, '_setOriginalRuleValues');
        element._originalRuleValues = {id: 123, value: {action: 'BATCH'}};
        element.rule = {id: 123, value: {action: 'BATCH'}};
        assert.isFalse(element._setDefaultRuleValues.called);
        assert.isFalse(element._setOriginalRuleValues.called);
        assert.isTrue(element._modified);
      });

      test('_setOriginalRuleValues', () => {
        const value = {
          action: 'ALLOW',
          force: false,
        };
        element._setOriginalRuleValues(value);
        assert.deepEqual(element._originalRuleValues, value);
      });
    });

    suite('already existing generic rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'submit';
        element.rule = {
          id: '123',
          value: {
            action: 'ALLOW',
            force: false,
          },
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });

      test('values are set correctly', () => {
        assert.equal(element.$.action.bindValue, element.rule.value.action);
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMin'));
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMax'));
        assert.isFalse(element.$.force.classList.contains('force'));
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.action.bindValue = 'DENY';
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
        assert.equal(element.$.action.bindValue, 'ALLOW');
        assert.isFalse(element._modified);
      });

      test('remove rule and undo remove', () => {
        element.rule = {id: 123};
        assert.isFalse(
            element.$.deletedContainer.classList.contains('deleted'));
        MockInteractions.tap(element.$.removeBtn);
        assert.isTrue(element.$.deletedContainer.classList.contains('deleted'));
        assert.isTrue(element.rule.deleted);

        MockInteractions.tap(element.$.undoRemoveBtn);
        assert.isNotOk(element.rule.deleted);
      });
    });

    suite('new edit rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'editTopicName';
        element.rule = {
          id: '123',
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        // Since the element does not already have default values, they should
        // be set. The original values should be set to those too.
        assert.isFalse(element._modified);
        const expectedRuleValue = {
          action: 'ALLOW',
          force: false,
        };
        assert.deepEqual(element.rule.value, expectedRuleValue);
        assert.deepEqual(element._originalRuleValues, expectedRuleValue);
        test('values are set correctly', () => {
          assert.equal(element.$.action.bindValue, expectedRuleValue.action);
          assert.equal(element.$.force.bindValue, expectedRuleValue.action);
        });
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.force.bindValue = true;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('already existing rule with labels', () => {
      setup(() => {
        element.label = {values: [
          {value: -2, text: 'This shall not be merged'},
          {value: -1, text: 'I would prefer this is not merged as is'},
          {value: -0, text: 'No score'},
          {value: 1, text: 'Looks good to me, but someone else must approve'},
          {value: 2, text: 'Looks good to me, approved'},
        ]};
        element.group = 'Group Name';
        element.permission = 'label-Code-Review';
        element.rule = {
          id: '123',
          value: {
            action: 'ALLOW',
            force: false,
            max: 2,
            min: -2,
          },
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });

      test('values are set correctly', () => {
        assert.equal(element.$.action.bindValue, element.rule.value.action);
        assert.equal(
            Polymer.dom(element.root).querySelector('#labelMin').bindValue,
            element.rule.value.min);
        assert.equal(
            Polymer.dom(element.root).querySelector('#labelMax').bindValue,
            element.rule.value.max);
        assert.isFalse(element.$.force.classList.contains('force'));
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        Polymer.dom(element.root).querySelector('#labelMin').bindValue = 1;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('new rule with labels', () => {
      setup(() => {
        sandbox.spy(element, '_setDefaultRuleValues');
        element.label = {values: [
          {value: -2, text: 'This shall not be merged'},
          {value: -1, text: 'I would prefer this is not merged as is'},
          {value: -0, text: 'No score'},
          {value: 1, text: 'Looks good to me, but someone else must approve'},
          {value: 2, text: 'Looks good to me, approved'},
        ]};
        element.group = 'Group Name';
        element.permission = 'label-Code-Review';
        element.rule = {
          id: '123',
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        // Since the element does not already have default values, they should
        // be set. The original values should be set to those too.
        assert.isFalse(element._modified);
        assert.isTrue(element._setDefaultRuleValues.called);

        const expectedRuleValue = {
          max: element.label.values[element.label.values.length - 1].value,
          min: element.label.values[0].value,
          action: 'ALLOW',
        };
        assert.deepEqual(element.rule.value, expectedRuleValue);
        assert.deepEqual(element._originalRuleValues, expectedRuleValue);
        test('values are set correctly', () => {
          assert.equal(
              element.$.action.bindValue,
              expectedRuleValue.action);
          assert.equal(
              Polymer.dom(element.root).querySelector('#labelMin').bindValue,
              expectedRuleValue.min);
          assert.equal(
              Polymer.dom(element.root).querySelector('#labelMax').bindValue,
              expectedRuleValue.max);
        });
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        Polymer.dom(element.root).querySelector('#labelMin').bindValue = 1;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('already existing push rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'push';
        element.rule = {
          id: '123',
          value: {
            action: 'ALLOW',
            force: true,
          },
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });

      test('values are set correctly', () => {
        assert.isTrue(element.$.force.classList.contains('force'));
        assert.equal(element.$.action.bindValue, element.rule.value.action);
        assert.equal(
            Polymer.dom(element.root).querySelector('#force').bindValue,
            element.rule.value.force);
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMin'));
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMax'));
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.action.bindValue = false;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('new push rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'push';
        element.rule = {
          id: '123',
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        // Since the element does not already have default values, they should
        // be set. The original values should be set to those too.
        assert.isFalse(element._modified);
        const expectedRuleValue = {
          action: 'ALLOW',
          force: false,
        };
        assert.deepEqual(element.rule.value, expectedRuleValue);
        assert.deepEqual(element._originalRuleValues, expectedRuleValue);
        test('values are set correctly', () => {
          assert.equal(element.$.action.bindValue, expectedRuleValue.action);
          assert.equal(element.$.force.bindValue, expectedRuleValue.action);
        });
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.force.bindValue = true;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('already existing edit rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'editTopicName';
        element.rule = {
          id: '123',
          value: {
            action: 'ALLOW',
            force: true,
          },
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });

      test('values are set correctly', () => {
        assert.isTrue(element.$.force.classList.contains('force'));
        assert.equal(element.$.action.bindValue, element.rule.value.action);
        assert.equal(
            Polymer.dom(element.root).querySelector('#force').bindValue,
            element.rule.value.force);
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMin'));
        assert.isNotOk(Polymer.dom(element.root).querySelector('#labelMax'));
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.action.bindValue = false;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });

    suite('new edit rule', () => {
      setup(() => {
        element.group = 'Group Name';
        element.permission = 'editTopicName';
        element.rule = {
          id: '123',
        };
        element.section = 'refs/*';
        flushAsynchronousOperations();
      });

      test('_ruleValues and _originalRuleValues are set correctly', () => {
        // Since the element does not already have default values, they should
        // be set. The original values should be set to those too.
        assert.isFalse(element._modified);
        const expectedRuleValue = {
          action: 'ALLOW',
          force: false,
        };
        assert.deepEqual(element.rule.value, expectedRuleValue);
        assert.deepEqual(element._originalRuleValues, expectedRuleValue);
        test('values are set correctly', () => {
          assert.equal(element.$.action.bindValue, expectedRuleValue.action);
          assert.equal(element.$.force.bindValue, expectedRuleValue.action);
        });
      });

      test('modify and undo value', () => {
        assert.isFalse(element._modified);
        assert.isFalse(element.$.undoBtn.classList.contains('modified'));
        element.$.force.bindValue = true;
        flushAsynchronousOperations();
        assert.isTrue(element._modified);
        assert.isTrue(element.$.undoBtn.classList.contains('modified'));

        // The original value should now differ from the rule values.
        assert.notDeepEqual(element._originalRuleValues, element.rule.value);

        // After undoing the change, the original value should get reset.
        MockInteractions.tap(element.$.undoBtn);
        assert.deepEqual(element._originalRuleValues, element.rule.value);
      });
    });
  });
</script>
