<!DOCTYPE html>
<!--
@license
Copyright (C) 2016 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
<title>gr-rest-api-interface</title>

<script src="../../../bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
<script src="../../../bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="../../../test/common-test-setup.html"/>
<script src="../../../scripts/util.js"></script>

<link rel="import" href="gr-rest-api-interface.html">

<script>void(0);</script>

<test-fixture id="basic">
  <template>
    <gr-rest-api-interface></gr-rest-api-interface>
  </template>
</test-fixture>

<script>
  suite('gr-rest-api-interface tests', () => {
    let element;
    let sandbox;
    let ctr = 0;

    setup(() => {
      // Modify CANONICAL_PATH to effectively reset cache.
      ctr += 1;
      window.CANONICAL_PATH = `test${ctr}`;

      sandbox = sinon.sandbox.create();
      element = fixture('basic');
      element._projectLookup = {};
      const testJSON = ')]}\'\n{"hello": "bonjour"}';
      sandbox.stub(window, 'fetch').returns(Promise.resolve({
        ok: true,
        text() {
          return Promise.resolve(testJSON);
        },
      }));
    });

    teardown(() => {
      sandbox.restore();
    });

    test('JSON prefix is properly removed', async () => {
      const obj = await element._fetchJSON('/dummy/url');
      assert.deepEqual(obj, {hello: 'bonjour'});
    });

    test('cached results', async () => {
      let n = 0;
      sandbox.stub(element, '_fetchJSON', async () => ++n);
      const promises = [];
      promises.push(element._fetchSharedCacheURL('/foo'));
      promises.push(element._fetchSharedCacheURL('/foo'));
      promises.push(element._fetchSharedCacheURL('/foo'));

      const results = await Promise.all(promises);
      assert.deepEqual(results, [1, 1, 1]);

      const foo = await element._fetchSharedCacheURL('/foo');
      assert.equal(foo, 1);
    });

    test('cached promise', async () => {
      const promise = Promise.reject('foo');
      element._cache.set('/foo', promise);
      try {
        await element._fetchSharedCacheURL({url: '/foo'});
        assert.fail('expected exception');
      } catch (p) {
        assert.equal(p, 'foo');
      }
    });

    test('params are properly encoded', () => {
      let url = element._urlWithParams('/path/', {
        sp: 'hola',
        gr: 'guten tag',
        noval: null,
      });
      assert.equal(url,
          window.CANONICAL_PATH + '/path/?sp=hola&gr=guten%20tag&noval');

      url = element._urlWithParams('/path/', {
        sp: 'hola',
        en: ['hey', 'hi'],
      });
      assert.equal(url, window.CANONICAL_PATH + '/path/?sp=hola&en=hey&en=hi');

      // Order must be maintained with array params.
      url = element._urlWithParams('/path/', {
        l: ['c', 'b', 'a'],
      });
      assert.equal(url, window.CANONICAL_PATH + '/path/?l=c&l=b&l=a');
    });

    test('request callbacks can be canceled', async () => {
      let cancelCalled = false;
      window.fetch.returns(Promise.resolve({
        body: {
          cancel() { cancelCalled = true; },
        },
      }));
      const cancelCondition = () => { return true; };
      const obj = await element._fetchJSON(
          {url: '/dummy/url', cancelCondition});
      assert.isUndefined(obj);
      assert.isTrue(cancelCalled);
    });

    test('parent diff comments are properly grouped', async () => {
      sandbox.stub(element, '_fetchJSON', async () => ({
        '/COMMIT_MSG': [],
        'sieve.go': [
          {
            updated: '2017-02-03 22:32:28.000000000',
            message: 'this isn’t quite right',
          },
          {
            side: 'PARENT',
            message: 'how did this work in the first place?',
            updated: '2017-02-03 22:33:28.000000000',
          },
        ],
      }));
      const obj = await element._getDiffComments(
          '42', '', 'PARENT', 1, 'sieve.go');
      assert.equal(obj.baseComments.length, 1);
      assert.deepEqual(obj.baseComments[0], {
        side: 'PARENT',
        message: 'how did this work in the first place?',
        path: 'sieve.go',
        updated: '2017-02-03 22:33:28.000000000',
      });
      assert.equal(obj.comments.length, 1);
      assert.deepEqual(obj.comments[0], {
        message: 'this isn’t quite right',
        path: 'sieve.go',
        updated: '2017-02-03 22:32:28.000000000',
      });
    });

    test('_setRange', () => {
      const comments = [
        {
          id: 1,
          side: 'PARENT',
          message: 'how did this work in the first place?',
          updated: '2017-02-03 22:32:28.000000000',
          range: {
            start_line: 1,
            start_character: 1,
            end_line: 2,
            end_character: 1,
          },
        },
        {
          id: 2,
          in_reply_to: 1,
          message: 'this isn’t quite right',
          updated: '2017-02-03 22:33:28.000000000',
        },
      ];
      const expectedResult = {
        id: 2,
        in_reply_to: 1,
        message: 'this isn’t quite right',
        updated: '2017-02-03 22:33:28.000000000',
        range: {
          start_line: 1,
          start_character: 1,
          end_line: 2,
          end_character: 1,
        },
      };
      const comment = comments[1];
      assert.deepEqual(element._setRange(comments, comment), expectedResult);
    });

    test('_setRanges', () => {
      const comments = [
        {
          id: 3,
          in_reply_to: 2,
          message: 'this isn’t quite right either',
          updated: '2017-02-03 22:34:28.000000000',
        },
        {
          id: 2,
          in_reply_to: 1,
          message: 'this isn’t quite right',
          updated: '2017-02-03 22:33:28.000000000',
        },
        {
          id: 1,
          side: 'PARENT',
          message: 'how did this work in the first place?',
          updated: '2017-02-03 22:32:28.000000000',
          range: {
            start_line: 1,
            start_character: 1,
            end_line: 2,
            end_character: 1,
          },
        },
      ];
      const expectedResult = [
        {
          id: 1,
          side: 'PARENT',
          message: 'how did this work in the first place?',
          updated: '2017-02-03 22:32:28.000000000',
          range: {
            start_line: 1,
            start_character: 1,
            end_line: 2,
            end_character: 1,
          },
        },
        {
          id: 2,
          in_reply_to: 1,
          message: 'this isn’t quite right',
          updated: '2017-02-03 22:33:28.000000000',
          range: {
            start_line: 1,
            start_character: 1,
            end_line: 2,
            end_character: 1,
          },
        },
        {
          id: 3,
          in_reply_to: 2,
          message: 'this isn’t quite right either',
          updated: '2017-02-03 22:34:28.000000000',
          range: {
            start_line: 1,
            start_character: 1,
            end_line: 2,
            end_character: 1,
          },
        },
      ];
      assert.deepEqual(element._setRanges(comments), expectedResult);
    });

    test('differing patch diff comments are properly grouped', async () => {
      sandbox.stub(element, 'getFromProjectLookup')
          .returns(Promise.resolve('test'));
      sandbox.stub(element, '_fetchJSON', async request => {
        const url = request.url;
        if (url === '/changes/test~42/revisions/1') {
          return {
            '/COMMIT_MSG': [],
            'sieve.go': [
              {
                message: 'this isn’t quite right',
                updated: '2017-02-03 22:32:28.000000000',
              },
              {
                side: 'PARENT',
                message: 'how did this work in the first place?',
                updated: '2017-02-03 22:33:28.000000000',
              },
            ],
          };
        } else if (url === '/changes/test~42/revisions/2') {
          return {
            '/COMMIT_MSG': [],
            'sieve.go': [
              {
                message: 'What on earth are you thinking, here?',
                updated: '2017-02-03 22:32:28.000000000',
              },
              {
                side: 'PARENT',
                message: 'Yeah not sure how this worked either?',
                updated: '2017-02-03 22:33:28.000000000',
              },
              {
                message: '¯\\_(ツ)_/¯',
                updated: '2017-02-04 22:33:28.000000000',
              },
            ],
          };
        }
      });
      const obj = await element._getDiffComments(
          '42', '', 1, 2, 'sieve.go');
      assert.equal(obj.baseComments.length, 1);
      assert.deepEqual(obj.baseComments[0], {
        message: 'this isn’t quite right',
        path: 'sieve.go',
        updated: '2017-02-03 22:32:28.000000000',
      });
      assert.equal(obj.comments.length, 2);
      assert.deepEqual(obj.comments[0], {
        message: 'What on earth are you thinking, here?',
        path: 'sieve.go',
        updated: '2017-02-03 22:32:28.000000000',
      });
      assert.deepEqual(obj.comments[1], {
        message: '¯\\_(ツ)_/¯',
        path: 'sieve.go',
        updated: '2017-02-04 22:33:28.000000000',
      });
    });

    test('special file path sorting', () => {
      assert.deepEqual(
          ['.b', '/COMMIT_MSG', '.a', 'file'].sort(
              element.specialFilePathCompare),
          ['/COMMIT_MSG', '.a', '.b', 'file']);

      assert.deepEqual(
          ['.b', '/COMMIT_MSG', 'foo/bar/baz.cc', 'foo/bar/baz.h'].sort(
              element.specialFilePathCompare),
          ['/COMMIT_MSG', '.b', 'foo/bar/baz.h', 'foo/bar/baz.cc']);

      assert.deepEqual(
          ['.b', '/COMMIT_MSG', 'foo/bar/baz.cc', 'foo/bar/baz.hpp'].sort(
              element.specialFilePathCompare),
          ['/COMMIT_MSG', '.b', 'foo/bar/baz.hpp', 'foo/bar/baz.cc']);

      assert.deepEqual(
          ['.b', '/COMMIT_MSG', 'foo/bar/baz.cc', 'foo/bar/baz.hxx'].sort(
              element.specialFilePathCompare),
          ['/COMMIT_MSG', '.b', 'foo/bar/baz.hxx', 'foo/bar/baz.cc']);

      assert.deepEqual(
          ['foo/bar.h', 'foo/bar.hxx', 'foo/bar.hpp'].sort(
              element.specialFilePathCompare),
          ['foo/bar.h', 'foo/bar.hpp', 'foo/bar.hxx']);

      // Regression test for Issue 4448.
      assert.deepEqual(
          [
            'minidump/minidump_memory_writer.cc',
            'minidump/minidump_memory_writer.h',
            'minidump/minidump_thread_writer.cc',
            'minidump/minidump_thread_writer.h',
          ].sort(element.specialFilePathCompare),
          [
            'minidump/minidump_memory_writer.h',
            'minidump/minidump_memory_writer.cc',
            'minidump/minidump_thread_writer.h',
            'minidump/minidump_thread_writer.cc',
          ]);

      // Regression test for Issue 4545.
      assert.deepEqual(
          [
            'task_test.go',
            'task.go',
          ].sort(element.specialFilePathCompare),
          [
            'task.go',
            'task_test.go',
          ]);
    });

    suite('rebase action', () => {
      let resolve_fetchJSON;
      setup(() => {
        sandbox.stub(element, '_fetchJSON').returns(
            new Promise(resolve => {
              resolve_fetchJSON = resolve;
            }));
      });

      test('no rebase on current', async () => {
        const promise = new Promise(async resolve => {
          const response = await element.getChangeRevisionActions('42', '1337');
          assert.isTrue(response.rebase.enabled);
          assert.isFalse(response.rebase.rebaseOnCurrent);
          resolve();
        });
        resolve_fetchJSON({rebase: {}});
        await promise;
      });

      test('rebase on current', async () => {
        const promise = new Promise(async resolve => {
          const response = await element.getChangeRevisionActions(
              '42', '1337');
          assert.isTrue(response.rebase.enabled);
          assert.isTrue(response.rebase.rebaseOnCurrent);
          resolve();
        });
        resolve_fetchJSON({rebase: {enabled: true}});
        await promise;
      });
    });


    test('server error', async () => {
      const getResponseObjectStub = sandbox.stub(element, 'getResponseObject');
      window.fetch.returns(Promise.resolve({ok: false}));
      const serverErrorEventPromise = new Promise(resolve => {
        element.addEventListener('server-error', resolve);
      });

      const response = await element._fetchJSON({});
      assert.isUndefined(response);
      assert.isTrue(getResponseObjectStub.notCalled);
      await serverErrorEventPromise;
    });

    test('auth failure', async () => {
      const fakeAuthResponse = {
        ok: false,
        status: 403,
      };
      window.fetch.onFirstCall().returns(
          Promise.reject({message: 'Failed to fetch'}));
      window.fetch.onSecondCall().returns(Promise.resolve(fakeAuthResponse));
      // Emulate logged in.
      element._cache.set('/accounts/self/detail', {});
      const serverErrorStub = sandbox.stub();
      element.addEventListener('server-error', serverErrorStub);
      const authErrorStub = sandbox.stub();
      element.addEventListener('auth-error', authErrorStub);
      await element._fetchJSON('/bar');
      assert.isTrue(authErrorStub.called);
      assert.isFalse(serverErrorStub.called);
      assert.isFalse(element._cache.has('/accounts/self/detail'));
    });

    test('checkCredentials', async () => {
      const responses = [
        {
          ok: false,
          status: 403,
          async text() {},
        },
        {
          ok: true,
          status: 200,
          async text() { return ')]}\'{}'; },
        },
      ];
      window.fetch.restore();
      sandbox.stub(window, 'fetch', async url => {
        if (url === window.CANONICAL_PATH + '/accounts/self/detail') {
          return responses.shift();
        }
      });

      assert.isNotOk(await element.getLoggedIn());
      assert.isOk(await element.checkCredentials());
    });

    test('checkCredentials promise rejection', async () => {
      window.fetch.restore();
      element._cache.set('/accounts/self/detail', true);
      sandbox.spy(element, 'checkCredentials');
      sandbox.stub(window, 'fetch', async url => {
        throw new Error('Failed to fetch');
      });
      try {
        console.log('calling getConfig');
        await element.getConfig(true);
        assert.fail('expected exception');
      } catch (err) {
        // When the top-level fetch call throws an error, it invokes
        // checkCredentials, which in turn makes another fetch call.
        // The second fetch call also fails, which leads to a second
        // invocation of checkCredentials, which should immediately
        // return instead of making further fetch calls.
        console.log('making assertions');
        assert.isTrue(element.checkCredentials.calledTwice);
        assert.isTrue(window.fetch.calledTwice);
      }
    });

    test('legacy n,z key in change url is replaced', () => {
      const stub = sandbox.stub(element, '_fetchJSON')
          .returns(Promise.resolve([]));
      element.getChanges(1, null, 'n,z');
      assert.equal(stub.lastCall.args[0].params.S, 0);
    });

    test('saveDiffPreferences invalidates cache line', () => {
      const cacheKey = '/accounts/self/preferences.diff';
      sandbox.stub(element, '_send');
      element._cache.set(cacheKey, {tab_size: 4});
      element.saveDiffPreferences({tab_size: 8});
      assert.isTrue(element._send.called);
      assert.isFalse(element._cache.has(cacheKey));
    });

    test('getAccount when resp is null does not add anything to the cache',
        async () => {
          const cacheKey = '/accounts/self/detail';
          const stub = sandbox.stub(element, '_fetchSharedCacheURL',
              async () => undefined);

          const promise = new Promise(async resolve => {
            await element.getAccount();
            assert.isTrue(element._fetchSharedCacheURL.called);
            assert.isFalse(element._cache.has(cacheKey));
            resolve();
          });

          element._cache.set(cacheKey, 'fake cache');
          stub.lastCall.args[0].errFn();
          await promise;
        });

    test('getAccount does not add to the cache when resp.status is 403',
        async () => {
          const cacheKey = '/accounts/self/detail';
          const stub = sandbox.stub(element, '_fetchSharedCacheURL',
              async () => undefined);

          const promise = new Promise(async resolve => {
            await element.getAccount();
            assert.isTrue(element._fetchSharedCacheURL.called);
            assert.isFalse(element._cache.has(cacheKey));
            resolve();
          });
          element._cache.set(cacheKey, 'fake cache');
          stub.lastCall.args[0].errFn({status: 403});
          await promise;
        });

    test('getAccount when resp is successful', async () => {
      const cacheKey = '/accounts/self/detail';
      const stub = sandbox.stub(element, '_fetchSharedCacheURL',
          async () => undefined);

      const promise = new Promise(async resolve => {
        await element.getAccount();
        assert.isTrue(element._fetchSharedCacheURL.called);
        assert.equal(element._cache.get(cacheKey), 'fake cache');
        resolve();
      });
      element._cache.set(cacheKey, 'fake cache');

      stub.lastCall.args[0].errFn({});
      await promise;
    });

    const preferenceSetup = function(testJSON, loggedIn, smallScreen) {
      sandbox.stub(element, 'getLoggedIn', async () => loggedIn);
      sandbox.stub(element, '_isNarrowScreen', async () => smallScreen);
      sandbox.stub(element, '_fetchSharedCacheURL', async () => testJSON);
    };

    test('getPreferences returns correctly on small screens logged in',
        async () => {
          const testJSON = {diff_view: 'SIDE_BY_SIDE'};
          const loggedIn = true;
          const smallScreen = true;

          preferenceSetup(testJSON, loggedIn, smallScreen);

          const obj = await element.getPreferences();
          assert.equal(obj.default_diff_view, 'UNIFIED_DIFF');
          assert.equal(obj.diff_view, 'SIDE_BY_SIDE');
        });

    test('getPreferences returns correctly on small screens not logged in',
        async () => {
          const testJSON = {diff_view: 'SIDE_BY_SIDE'};
          const loggedIn = false;
          const smallScreen = true;

          preferenceSetup(testJSON, loggedIn, smallScreen);

          const obj = await element.getPreferences();
          assert.equal(obj.default_diff_view, 'UNIFIED_DIFF');
          assert.equal(obj.diff_view, 'SIDE_BY_SIDE');
        });

    test('getPreferences returns correctly on larger screens logged in',
        async () => {
          const testJSON = {diff_view: 'UNIFIED_DIFF'};
          const loggedIn = true;
          const smallScreen = false;

          preferenceSetup(testJSON, loggedIn, smallScreen);

          const obj = await element.getPreferences();
          assert.equal(obj.default_diff_view, 'UNIFIED_DIFF');
          assert.equal(obj.diff_view, 'UNIFIED_DIFF');
        });

    test('getPreferences returns correctly on larger screens not logged in',
        async () => {
          const testJSON = {diff_view: 'UNIFIED_DIFF'};
          const loggedIn = false;
          const smallScreen = false;

          preferenceSetup(testJSON, loggedIn, smallScreen);

          const obj = await element.getPreferences();
          assert.equal(obj.default_diff_view, 'UNIFIED_DIFF');
          assert.equal(obj.diff_view, 'SIDE_BY_SIDE');
        });

    test('savPreferences normalizes download scheme', () => {
      sandbox.stub(element, '_send');
      element.savePreferences({download_scheme: 'HTTP'});
      assert.isTrue(element._send.called);
      assert.equal(element._send.lastCall.args[0].body.download_scheme, 'http');
    });

    test('getDiffPreferences returns correct defaults', async () => {
      sandbox.stub(element, 'getLoggedIn', async () => false);

      const obj = await element.getDiffPreferences();
      assert.equal(obj.auto_hide_diff_table_header, true);
      assert.equal(obj.context, 10);
      assert.equal(obj.cursor_blink_rate, 0);
      assert.equal(obj.font_size, 12);
      assert.equal(obj.ignore_whitespace, 'IGNORE_NONE');
      assert.equal(obj.intraline_difference, true);
      assert.equal(obj.line_length, 100);
      assert.equal(obj.line_wrapping, false);
      assert.equal(obj.show_line_endings, true);
      assert.equal(obj.show_tabs, true);
      assert.equal(obj.show_whitespace_errors, true);
      assert.equal(obj.syntax_highlighting, true);
      assert.equal(obj.tab_size, 8);
      assert.equal(obj.theme, 'DEFAULT');
    });

    test('saveDiffPreferences set show_tabs to false', () => {
      sandbox.stub(element, '_send');
      element.saveDiffPreferences({show_tabs: false});
      assert.isTrue(element._send.called);
      assert.equal(element._send.lastCall.args[0].body.show_tabs, false);
    });

    test('getEditPreferences returns correct defaults', async () => {
      sandbox.stub(element, 'getLoggedIn', async () => false);

      const obj = await element.getEditPreferences();
      assert.equal(obj.auto_close_brackets, false);
      assert.equal(obj.cursor_blink_rate, 0);
      assert.equal(obj.hide_line_numbers, false);
      assert.equal(obj.hide_top_menu, false);
      assert.equal(obj.indent_unit, 2);
      assert.equal(obj.indent_with_tabs, false);
      assert.equal(obj.key_map_type, 'DEFAULT');
      assert.equal(obj.line_length, 100);
      assert.equal(obj.line_wrapping, false);
      assert.equal(obj.match_brackets, true);
      assert.equal(obj.show_base, false);
      assert.equal(obj.show_tabs, true);
      assert.equal(obj.show_whitespace_errors, true);
      assert.equal(obj.syntax_highlighting, true);
      assert.equal(obj.tab_size, 8);
      assert.equal(obj.theme, 'DEFAULT');
    });

    test('saveEditPreferences set show_tabs to false', () => {
      sandbox.stub(element, '_send');
      element.saveEditPreferences({show_tabs: false});
      assert.isTrue(element._send.called);
      assert.equal(element._send.lastCall.args[0].body.show_tabs, false);
    });

    test('confirmEmail', () => {
      sandbox.spy(element, '_send');
      element.confirmEmail('foo');
      assert.isTrue(element._send.calledOnce);
      assert.equal(element._send.lastCall.args[0].method, 'PUT');
      assert.equal(element._send.lastCall.args[0].url,
          '/config/server/email.confirm');
      assert.deepEqual(element._send.lastCall.args[0].body, {token: 'foo'});
    });

    test('GrReviewerUpdatesParser.parse is used', async () => {
      sandbox.stub(GrReviewerUpdatesParser, 'parse').returns(
          Promise.resolve('foo'));
      const result = await element.getChangeDetail(42);
      assert.isTrue(GrReviewerUpdatesParser.parse.calledOnce);
      assert.equal(result, 'foo');
    });

    test('setAccountStatus', async () => {
      sandbox.stub(element, '_send').returns(Promise.resolve('OOO'));
      element._cache.set('/accounts/self/detail', {});
      await element.setAccountStatus('OOO');
      assert.isTrue(element._send.calledOnce);
      assert.equal(element._send.lastCall.args[0].method, 'PUT');
      assert.equal(element._send.lastCall.args[0].url,
          '/accounts/self/status');
      assert.deepEqual(element._send.lastCall.args[0].body,
          {status: 'OOO'});
      assert.deepEqual(element._cache.get('/accounts/self/detail'),
          {status: 'OOO'});
    });

    suite('draft comments', () => {
      test('_sendDiffDraftRequest pending requests tracked', async () => {
        const obj = element._pendingRequests;
        sandbox.stub(element, '_getChangeURLAndSend', () => mockPromise());
        assert.notOk(element.hasPendingDiffDrafts());

        element._sendDiffDraftRequest(null, null, null, {});
        assert.equal(obj.sendDiffDraft.length, 1);
        assert.isTrue(!!element.hasPendingDiffDrafts());

        element._sendDiffDraftRequest(null, null, null, {});
        assert.equal(obj.sendDiffDraft.length, 2);
        assert.isTrue(!!element.hasPendingDiffDrafts());

        for (const promise of obj.sendDiffDraft) { promise.resolve(); }

        await element.awaitPendingDiffDrafts();
        assert.equal(obj.sendDiffDraft.length, 0);
        assert.isFalse(!!element.hasPendingDiffDrafts());
      });

      suite('_failForCreate200', () => {
        test('_sendDiffDraftRequest checks for 200 on create', async () => {
          const sendPromise = Promise.resolve();
          sandbox.stub(element, '_getChangeURLAndSend').returns(sendPromise);
          const failStub = sandbox.stub(element, '_failForCreate200')
              .returns(Promise.resolve());
          await element._sendDiffDraftRequest('PUT', 123, 4, {});
          assert.isTrue(failStub.calledOnce);
          assert.isTrue(failStub.calledWithExactly(sendPromise));
        });

        test('_sendDiffDraftRequest no checks for 200 on non create',
            async () => {
              sandbox.stub(element, '_getChangeURLAndSend')
                  .returns(Promise.resolve());
              const failStub = sandbox.stub(element, '_failForCreate200')
                  .returns(Promise.resolve());
              await element._sendDiffDraftRequest('PUT', 123, 4, {id: '123'});
              assert.isFalse(failStub.called);
            });

        test('_failForCreate200 fails on 200', async () => {
          const result = {
            ok: true,
            status: 200,
            headers: {entries: () => [
              ['Set-CoOkiE', 'secret'],
              ['Innocuous', 'hello'],
            ]},
          };
          try {
            await element._failForCreate200(Promise.resolve(result));
            assert.fail('Promise should not resolve');
          } catch (e) {
            assert.isOk(e);
            assert.include(e.message, 'Saving draft resulted in HTTP 200');
            assert.include(e.message, 'hello');
            assert.notInclude(e.message, 'secret');
          }
        });

        test('_failForCreate200 does not fail on 201', async () => {
          const result = {
            ok: true,
            status: 201,
            headers: {entries: () => []},
          };
          await element._failForCreate200(Promise.resolve(result));
        });
      });
    });

    test('saveChangeEdit', async () => {
      element._projectLookup = {1: 'test'};
      const change_num = '1';
      const file_name = 'index.php';
      const file_contents = '<?php';
      sandbox.stub(element, '_send').returns(
          Promise.resolve([change_num, file_name, file_contents]));
      sandbox.stub(element, 'getResponseObject')
          .returns(Promise.resolve([change_num, file_name, file_contents]));
      element._cache.set(
          '/changes/' + change_num + '/edit/' + file_name, {});
      await element.saveChangeEdit(change_num, file_name, file_contents);
      assert.isTrue(element._send.calledOnce);
      assert.equal(element._send.lastCall.args[0].method, 'PUT');
      assert.equal(element._send.lastCall.args[0].url,
          '/changes/test~1/edit/' + file_name);
      assert.equal(element._send.lastCall.args[0].body, file_contents);
    });

    test('putChangeCommitMessage', async () => {
      element._projectLookup = {1: 'test'};
      const change_num = '1';
      const message = 'this is a commit message';
      sandbox.stub(element, '_send').returns(
          Promise.resolve([change_num, message]));
      sandbox.stub(element, 'getResponseObject')
          .returns(Promise.resolve([change_num, message]));
      element._cache.set('/changes/' + change_num + '/message', {});
      await element.putChangeCommitMessage(change_num, message);
      assert.isTrue(element._send.calledOnce);
      assert.equal(element._send.lastCall.args[0].method, 'PUT');
      assert.equal(element._send.lastCall.args[0].url,
          '/changes/test~1/message');
      assert.deepEqual(element._send.lastCall.args[0].body, {message});
    });

    test('startWorkInProgress', () => {
      const sendStub = sandbox.stub(element, '_getChangeURLAndSend')
          .returns(Promise.resolve('ok'));
      element.startWorkInProgress('42');
      assert.isTrue(sendStub.calledOnce);
      assert.equal(sendStub.lastCall.args[0].changeNum, '42');
      assert.equal(sendStub.lastCall.args[0].method, 'POST');
      assert.isNotOk(sendStub.lastCall.args[0].patchNum);
      assert.equal(sendStub.lastCall.args[0].endpoint, '/wip');
      assert.deepEqual(sendStub.lastCall.args[0].body, {});

      element.startWorkInProgress('42', 'revising...');
      assert.isTrue(sendStub.calledTwice);
      assert.equal(sendStub.lastCall.args[0].changeNum, '42');
      assert.equal(sendStub.lastCall.args[0].method, 'POST');
      assert.isNotOk(sendStub.lastCall.args[0].patchNum);
      assert.equal(sendStub.lastCall.args[0].endpoint, '/wip');
      assert.deepEqual(sendStub.lastCall.args[0].body,
          {message: 'revising...'});
    });

    test('startReview', () => {
      const sendStub = sandbox.stub(element, '_getChangeURLAndSend')
          .returns(Promise.resolve({}));
      element.startReview('42', {message: 'Please review.'});
      assert.isTrue(sendStub.calledOnce);
      assert.equal(sendStub.lastCall.args[0].changeNum, '42');
      assert.equal(sendStub.lastCall.args[0].method, 'POST');
      assert.isNotOk(sendStub.lastCall.args[0].patchNum);
      assert.equal(sendStub.lastCall.args[0].endpoint, '/ready');
      assert.deepEqual(sendStub.lastCall.args[0].body,
          {message: 'Please review.'});
    });

    test('deleteComment', async () => {
      const sendStub = sandbox.stub(element, '_getChangeURLAndSend')
          .returns(Promise.resolve('some response'));
      const response =
          await element.deleteComment('foo', 'bar', '01234', 'removal reason');
      assert.equal(response, 'some response');
      assert.isTrue(sendStub.calledOnce);
      assert.equal(sendStub.lastCall.args[0].changeNum, 'foo');
      assert.equal(sendStub.lastCall.args[0].method, 'POST');
      assert.equal(sendStub.lastCall.args[0].patchNum, 'bar');
      assert.equal(sendStub.lastCall.args[0].endpoint,
          '/comments/01234/delete');
      assert.deepEqual(sendStub.lastCall.args[0].body,
          {reason: 'removal reason'});
    });

    test('createRepo encodes name', async () => {
      const sendStub = sandbox.stub(element, '_send')
          .returns(Promise.resolve());
      await element.createRepo({name: 'x/y'});
      assert.isTrue(sendStub.calledOnce);
      assert.equal(sendStub.lastCall.args[0].url, '/projects/x%2Fy');
    });

    test('queryChangeFiles', async () => {
      const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
          .returns(Promise.resolve());
      await element.queryChangeFiles('42', 'edit', 'test/path.js');
      assert.equal(fetchStub.lastCall.args[0].changeNum, '42');
      assert.equal(fetchStub.lastCall.args[0].endpoint,
          '/files?q=test%2Fpath.js');
      assert.equal(fetchStub.lastCall.args[0].patchNum, 'edit');
    });

    suite('getRepos', () => {
      const defaultQuery = 'state%3Aactive%20OR%20state%3Aread-only';

      setup(() => {
        sandbox.stub(element, '_fetchSharedCacheURL');
      });

      test('normal use', () => {
        element.getRepos('test', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=test');

        element.getRepos(null, 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            `/projects/?n=26&S=0&query=${defaultQuery}`);

        element.getRepos('test', 25, 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=25&query=test');
      });

      test('with blank', () => {
        element.getRepos('test/test', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Atest%20AND%20inname%3Atest');
      });

      test('with hyphen', () => {
        element.getRepos('foo-bar', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Afoo%20AND%20inname%3Abar');
      });

      test('with leading hyphen', () => {
        element.getRepos('-bar', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Abar');
      });

      test('with trailing hyphen', () => {
        element.getRepos('foo-bar-', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Afoo%20AND%20inname%3Abar');
      });

      test('with underscore', () => {
        element.getRepos('foo_bar', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Afoo%20AND%20inname%3Abar');
      });

      test('with underscore', () => {
        element.getRepos('foo_bar', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            '/projects/?n=26&S=0&query=inname%3Afoo%20AND%20inname%3Abar');
      });

      test('hyphen only', () => {
        element.getRepos('-', 25);
        assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
            `/projects/?n=26&S=0&query=${defaultQuery}`);
      });
    });

    test('getGroups filter regex', () => {
      sandbox.stub(element, '_fetchSharedCacheURL');
      element.getGroups('^test.*', 25);
      assert.equal(element._fetchSharedCacheURL.lastCall.args[0].url,
          '/groups/?n=26&S=0&r=%5Etest.*');
    });

    test('gerrit auth is used', () => {
      sandbox.stub(Gerrit.Auth, 'fetch').returns(Promise.resolve());
      element._fetchJSON('foo');
      assert(Gerrit.Auth.fetch.called);
    });

    test('getSuggestedAccounts does not return _fetchJSON', async () => {
      const _fetchJSONSpy = sandbox.spy(element, '_fetchJSON');
      const accts = await element.getSuggestedAccounts();
      assert.isFalse(_fetchJSONSpy.called);
      assert.equal(accts.length, 0);
    });

    test('_fetchJSON gets called by getSuggestedAccounts', async () => {
      const _fetchJSONStub = sandbox.stub(element, '_fetchJSON',
          async () => undefined);
      await element.getSuggestedAccounts('own');
      assert.deepEqual(_fetchJSONStub.lastCall.args[0].params, {
        q: 'own',
        suggest: null,
      });
    });

    suite('_getChangeDetail', () => {
      test('_getChangeDetail passes params to ETags decorator', async () => {
        const changeNum = 4321;
        element._projectLookup[changeNum] = 'test';
        const params = {foo: 'bar'};
        const expectedUrl =
            window.CANONICAL_PATH + '/changes/test~4321/detail?foo=bar';
        sandbox.stub(element._etags, 'getOptions');
        sandbox.stub(element._etags, 'collect');
        await element._getChangeDetail(changeNum, params);
        assert.isTrue(element._etags.getOptions.calledWithExactly(
            expectedUrl));
        assert.equal(element._etags.collect.lastCall.args[0], expectedUrl);
      });

      test('_getChangeDetail calls errFn on 500', async () => {
        const errFn = sinon.stub();
        sandbox.stub(element, 'getChangeActionURL')
            .returns(Promise.resolve(''));
        sandbox.stub(element, '_fetchRawJSON')
            .returns(Promise.resolve({ok: false, status: 500}));
        await element._getChangeDetail(123, {}, errFn);
        assert.isTrue(errFn.called);
      });

      test('_getChangeDetail populates _projectLookup', async () => {
        sandbox.stub(element, 'getChangeActionURL')
            .returns(Promise.resolve(''));
        sandbox.stub(element, '_fetchRawJSON')
            .returns(Promise.resolve({ok: true}));

        const mockResponse = {_number: 1, project: 'test'};
        sandbox.stub(element, '_readResponsePayload').returns(Promise.resolve({
          parsed: mockResponse,
          raw: JSON.stringify(mockResponse),
        }));
        await element._getChangeDetail(1);
        assert.equal(Object.keys(element._projectLookup).length, 1);
        assert.equal(element._projectLookup[1], 'test');
      });

      suite('_getChangeDetail ETag cache', () => {
        let requestUrl;
        let mockResponseSerial;
        let collectSpy;
        let getPayloadSpy;

        setup(() => {
          requestUrl = '/foo/bar';
          const mockResponse = {foo: 'bar', baz: 42};
          mockResponseSerial = element.JSON_PREFIX +
              JSON.stringify(mockResponse);
          sandbox.stub(element, '_urlWithParams').returns(requestUrl);
          sandbox.stub(element, 'getChangeActionURL')
              .returns(Promise.resolve(requestUrl));
          collectSpy = sandbox.spy(element._etags, 'collect');
          getPayloadSpy = sandbox.spy(element._etags, 'getCachedPayload');
        });

        test('contributes to cache', async () => {
          sandbox.stub(element, '_fetchRawJSON').returns(Promise.resolve({
            text: () => Promise.resolve(mockResponseSerial),
            status: 200,
            ok: true,
          }));

          await element._getChangeDetail(123, {});
          assert.isFalse(getPayloadSpy.called);
          assert.isTrue(collectSpy.calledOnce);
          const cachedResponse = element._etags.getCachedPayload(requestUrl);
          assert.equal(cachedResponse, mockResponseSerial);
        });

        test('uses cache on HTTP 304', async () => {
          sandbox.stub(element, '_fetchRawJSON').returns(Promise.resolve({
            text: () => Promise.resolve(mockResponseSerial),
            status: 304,
            ok: true,
          }));

          await element._getChangeDetail(123, {});
          assert.isFalse(collectSpy.called);
          assert.isTrue(getPayloadSpy.calledOnce);
        });
      });
    });

    test('setInProjectLookup', () => {
      element.setInProjectLookup('test', 'project');
      assert.deepEqual(element._projectLookup, {test: 'project'});
    });

    suite('getFromProjectLookup', () => {
      test('getChange fails', async () => {
        sandbox.stub(element, 'getChange')
            .returns(Promise.resolve(null));
        const val = await element.getFromProjectLookup();
        assert.strictEqual(val, undefined);
        assert.deepEqual(element._projectLookup, {});
      });

      test('getChange succeeds, no project', async () => {
        sandbox.stub(element, 'getChange').returns(Promise.resolve(null));
        const val = await element.getFromProjectLookup();
        assert.strictEqual(val, undefined);
        assert.deepEqual(element._projectLookup, {});
      });

      test('getChange succeeds with project', async () => {
        sandbox.stub(element, 'getChange')
            .returns(Promise.resolve({project: 'project'}));
        const val = await element.getFromProjectLookup('test');
        assert.equal(val, 'project');
        assert.deepEqual(element._projectLookup, {test: 'project'});
      });
    });

    suite('getChanges populates _projectLookup', () => {
      test('multiple queries', async () => {
        sandbox.stub(element, '_fetchJSON')
            .returns(Promise.resolve([
              [
                {_number: 1, project: 'test'},
                {_number: 2, project: 'test'},
              ], [
                {_number: 3, project: 'test/test'},
              ],
            ]));
        // When opt_query instanceof Array, _fetchJSON returns
        // Array<Array<Object>>.
        await element.getChanges(null, []);
        assert.equal(Object.keys(element._projectLookup).length, 3);
        assert.equal(element._projectLookup[1], 'test');
        assert.equal(element._projectLookup[2], 'test');
        assert.equal(element._projectLookup[3], 'test/test');
      });

      test('no query', async () => {
        sandbox.stub(element, '_fetchJSON')
            .returns(Promise.resolve([
              {_number: 1, project: 'test'},
              {_number: 2, project: 'test'},
              {_number: 3, project: 'test/test'},
            ]));

        // When opt_query !instanceof Array, _fetchJSON returns
        // Array<Object>.
        await element.getChanges();
        assert.equal(Object.keys(element._projectLookup).length, 3);
        assert.equal(element._projectLookup[1], 'test');
        assert.equal(element._projectLookup[2], 'test');
        assert.equal(element._projectLookup[3], 'test/test');
      });
    });

    test('_getChangeURLAndFetch', async () => {
      element._projectLookup = {1: 'test'};
      const fetchStub = sandbox.stub(element, '_fetchJSON')
          .returns(Promise.resolve());
      const req = {changeNum: 1, endpoint: '/test', patchNum: 1};
      await element._getChangeURLAndFetch(req);
      assert.equal(fetchStub.lastCall.args[0].url,
          '/changes/test~1/revisions/1/test');
    });

    test('_getChangeURLAndSend', async () => {
      element._projectLookup = {1: 'test'};
      const sendStub = sandbox.stub(element, '_send')
          .returns(Promise.resolve());

      const req = {
        changeNum: 1,
        method: 'POST',
        patchNum: 1,
        endpoint: '/test',
      };
      await element._getChangeURLAndSend(req);
      assert.isTrue(sendStub.calledOnce);
      assert.equal(sendStub.lastCall.args[0].method, 'POST');
      assert.equal(sendStub.lastCall.args[0].url,
          '/changes/test~1/revisions/1/test');
    });

    suite('reading responses', () => {
      test('_readResponsePayload', async () => {
        const mockObject = {foo: 'bar', baz: 'foo'};
        const serial = element.JSON_PREFIX + JSON.stringify(mockObject);
        const mockResponse = {text: () => Promise.resolve(serial)};
        const payload = await element._readResponsePayload(mockResponse);
        assert.deepEqual(payload.parsed, mockObject);
        assert.equal(payload.raw, serial);
      });

      test('_parsePrefixedJSON', () => {
        const obj = {x: 3, y: {z: 4}, w: 23};
        const serial = element.JSON_PREFIX + JSON.stringify(obj);
        const result = element._parsePrefixedJSON(serial);
        assert.deepEqual(result, obj);
      });
    });

    test('setChangeTopic', async () => {
      const sendSpy = sandbox.spy(element, '_getChangeURLAndSend');
      await element.setChangeTopic(123, 'foo-bar');
      assert.isTrue(sendSpy.calledOnce);
      assert.deepEqual(sendSpy.lastCall.args[0].body, {topic: 'foo-bar'});
    });

    test('setChangeHashtag', async () => {
      const sendSpy = sandbox.spy(element, '_getChangeURLAndSend');
      await element.setChangeHashtag(123, 'foo-bar');
      assert.isTrue(sendSpy.calledOnce);
      assert.equal(sendSpy.lastCall.args[0].body, 'foo-bar');
    });

    test('generateAccountHttpPassword', async () => {
      const sendSpy = sandbox.spy(element, '_send');
      await element.generateAccountHttpPassword();
      assert.isTrue(sendSpy.calledOnce);
      assert.deepEqual(sendSpy.lastCall.args[0].body, {generate: true});
    });

    suite('getChangeFiles', () => {
      test('patch only', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        const range = {basePatchNum: 'PARENT', patchNum: 2};
        await element.getChangeFiles(123, range);
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 2);
        assert.isNotOk(fetchStub.lastCall.args[0].params);
      });

      test('simple range', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        const range = {basePatchNum: 4, patchNum: 5};
        await element.getChangeFiles(123, range);
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 5);
        assert.isOk(fetchStub.lastCall.args[0].params);
        assert.equal(fetchStub.lastCall.args[0].params.base, 4);
        assert.isNotOk(fetchStub.lastCall.args[0].params.parent);
      });

      test('parent index', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        const range = {basePatchNum: -3, patchNum: 5};
        await element.getChangeFiles(123, range);
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 5);
        assert.isOk(fetchStub.lastCall.args[0].params);
        assert.isNotOk(fetchStub.lastCall.args[0].params.base);
        assert.equal(fetchStub.lastCall.args[0].params.parent, 3);
      });
    });

    suite('getDiff', () => {
      test('patchOnly', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        await element.getDiff(123, 'PARENT', 2, 'foo/bar.baz');
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 2);
        assert.isOk(fetchStub.lastCall.args[0].params);
        assert.isNotOk(fetchStub.lastCall.args[0].params.parent);
        assert.isNotOk(fetchStub.lastCall.args[0].params.base);
      });

      test('simple range', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        await element.getDiff(123, 4, 5, 'foo/bar.baz');
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 5);
        assert.isOk(fetchStub.lastCall.args[0].params);
        assert.isNotOk(fetchStub.lastCall.args[0].params.parent);
        assert.equal(fetchStub.lastCall.args[0].params.base, 4);
      });

      test('parent index', async () => {
        const fetchStub = sandbox.stub(element, '_getChangeURLAndFetch')
            .returns(Promise.resolve());
        await element.getDiff(123, -3, 5, 'foo/bar.baz');
        assert.isTrue(fetchStub.calledOnce);
        assert.equal(fetchStub.lastCall.args[0].patchNum, 5);
        assert.isOk(fetchStub.lastCall.args[0].params);
        assert.isNotOk(fetchStub.lastCall.args[0].params.base);
        assert.equal(fetchStub.lastCall.args[0].params.parent, 3);
      });
    });

    test('getDashboard', () => {
      const fetchStub = sandbox.stub(element, '_fetchSharedCacheURL');
      element.getDashboard('gerrit/project', 'default:main');
      assert.isTrue(fetchStub.calledOnce);
      assert.equal(
          fetchStub.lastCall.args[0].url,
          '/projects/gerrit%2Fproject/dashboards/default%3Amain');
    });

    test('getFileContent', async () => {
      sandbox.stub(element, '_getChangeURLAndSend')
          .returns(Promise.resolve({
            ok: 'true',
            headers: {
              get(header) {
                if (header === 'X-FYI-Content-Type') {
                  return 'text/java';
                }
              },
            },
          }));

      sandbox.stub(element, 'getResponseObject')
          .returns(Promise.resolve('new content'));

      const edit = (async () => {
        const res = await element.getFileContent('1', 'tst/path', 'EDIT');
        assert.deepEqual(res,
            {content: 'new content', type: 'text/java', ok: true});
      })();

      const normal = (async () => {
        const res = await element.getFileContent('1', 'tst/path', '3');
        assert.deepEqual(res,
            {content: 'new content', type: 'text/java', ok: true});
      })();

      await Promise.all([edit, normal]);
    });

    test('getFileContent suppresses 404s', async () => {
      const promise = new Promise(resolve => {
        const handler = e => {
          assert.isFalse(e.detail.res.status === 404);
          resolve();
        };
        element.addEventListener('server-error', handler);
      });

      const res = {status: 404};
      sandbox.stub(Gerrit.Auth, 'fetch').returns(Promise.resolve(res));
      sandbox.stub(element, '_changeBaseURL').returns(Promise.resolve(''));
      await element.getFileContent('1', 'tst/path', '1');
      flushAsynchronousOperations();

      res.status = 500;
      await element.getFileContent('1', 'tst/path', '1');

      await promise;
    });

    test('getChangeFilesOrEditFiles is edit-sensitive', async () => {
      const fn = element.getChangeOrEditFiles.bind(element);
      const getChangeFilesStub = sandbox.stub(element, 'getChangeFiles')
          .returns(Promise.resolve({}));
      const getChangeEditFilesStub = sandbox.stub(element, 'getChangeEditFiles')
          .returns(Promise.resolve({}));

      await fn('1', {patchNum: 'edit'});
      assert.isTrue(getChangeEditFilesStub.calledOnce);
      assert.isFalse(getChangeFilesStub.called);

      await fn('1', {patchNum: '1'});
      assert.isTrue(getChangeEditFilesStub.calledOnce);
      assert.isTrue(getChangeFilesStub.calledOnce);
    });

    test('_fetch forwards request and logs', async () => {
      const logStub = sandbox.stub(element, '_logCall');
      const response = {status: 404, text: sinon.stub()};
      const url = 'my url';
      const fetchOptions = {method: 'DELETE'};
      sandbox.stub(element._auth, 'fetch').returns(Promise.resolve(response));
      const startTime = 123;
      sandbox.stub(Date, 'now').returns(startTime);
      const req = {url, fetchOptions};
      await element._fetch(req);
      assert.isTrue(logStub.calledOnce);
      assert.isTrue(logStub.calledWith(req, startTime, response.status));
      assert.isFalse(response.text.called);
    });

    test('_logCall only reports requests with anonymized URLss', () => {
      sandbox.stub(Date, 'now').returns(200);
      const handler = sinon.stub();
      element.addEventListener('rpc-log', handler);

      element._logCall({url: 'url'}, 100, 200);
      assert.isFalse(handler.called);

      element._logCall({url: 'url', anonymizedUrl: 'not url'}, 100, 200);
      flushAsynchronousOperations();
      assert.isTrue(handler.calledOnce);
    });
  });
</script>
