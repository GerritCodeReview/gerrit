// Copyright (C) 2017 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
(function(window) {
  'use strict';

  // Prevent redefinition.
  if (window.GrReviewerUpdatesParser) { return; }

  function GrReviewerUpdatesParser() {
    this._lastState = {};
  };

  GrReviewerUpdatesParser.parse = function(change) {
    var parser = new GrReviewerUpdatesParser();
    parser._filterRemovedMessages(change);
    parser._groupUpdates(change);
    parser._formatUpdates(change);
    return change;
  };

  GrReviewerUpdatesParser.prototype._batch = null;
  GrReviewerUpdatesParser.prototype._updateItems = null;
  GrReviewerUpdatesParser.prototype._lastState = null;

  GrReviewerUpdatesParser.prototype._filterRemovedMessages = function(change) {
    change.messages = change.messages.filter(function(message) {
      return message.tag != 'autogenerated:gerrit:deleteReviewer';
    });
  };

  GrReviewerUpdatesParser.prototype._startBatch = function(update) {
    this._updateItems = [];
    return {
      author: update.updated_by,
      date: update.updated,
      type: 'REVIEWER_UPDATE',
    };
  };

  GrReviewerUpdatesParser.prototype._completeBatch = function(update) {
    var items = [];
    for (var accountId in this._updateItems) {
      if (!this._updateItems.hasOwnProperty(accountId)) continue;
      var updateItem = this._updateItems[accountId];
      if (this._lastState[accountId] !== updateItem.state) {
        this._lastState[accountId] = updateItem.state;
        items.push(updateItem);
      }
    }
    if (items.length) {
      this._batch.updates = items;
    }
  };

  GrReviewerUpdatesParser.prototype._groupUpdates = function(change) {
    var updates = change.reviewer_updates;
    var result = updates.reduce(function(result, update) {
      if (!this._batch) {
        this._batch = this._startBatch(update);
      }
      var updateDate = util.parseDate(update.updated).getTime();
      var batchUpdateDate = util.parseDate(this._batch.date).getTime();
      var reviewerId = update.reviewer._account_id.toString();
      if (updateDate - batchUpdateDate > 6000 ||
          update.updated_by._account_id !== this._batch.author._account_id) {
        this._completeBatch();
        if (this._batch.updates && this._batch.updates.length) {
          result.push(this._batch);
        }
        this._batch = this._startBatch(update);
      }
      this._updateItems[reviewerId] = {
        reviewer: update.reviewer,
        state: update.state,
      };
      if (this._lastState[reviewerId]) {
        this._updateItems[reviewerId].prev_state = this._lastState[reviewerId];
      }
      return result;
    }.bind(this), []);
    this._completeBatch();
    if (this._batch.updates && this._batch.updates.length) {
      result.push(this._batch);
    }
    change.reviewer_updates = result;
  };

  GrReviewerUpdatesParser.prototype._getUpdateMessage = function(prev, state) {
    if (prev === 'REMOVED' || !prev) {
      return 'added to ' + state + ': ';
    } else if (state === 'REMOVED') {
      return 'removed ' + (prev ? ('from ' + prev) : '') + ': ';
    } else {
      return 'moved from ' + prev + ' to ' + state + ': ';
    }
  };

  GrReviewerUpdatesParser.prototype._formatUpdates = function(change) {
    change.reviewer_updates.forEach(function(update) {
      // Fail-safe for previous API version.
      if (!update.updates) {
        return;
      }
      // Reviewers grouped by update message (eg 'added to cc').
      var grouppedReviewers = update.updates.reduce(function(result, item) {
        var message = this._getUpdateMessage(item.prev_state, item.state);
        if (!result[message]) {
          result[message] = [];
        }
        result[message].push(item.reviewer);
        return result;
      }.bind(this), {});
      var newUpdates = [];
      for (var message in grouppedReviewers) {
        if (grouppedReviewers.hasOwnProperty(message)) {
          newUpdates.push({
            message: message,
            reviewers: grouppedReviewers[message],
          });
        }
      }
      update.updates = newUpdates;
    }.bind(this));
  };

  window.GrReviewerUpdatesParser = GrReviewerUpdatesParser;

})(window);
